(* THIS FILE WAS AUTOMATICALLY GENERATED BY CAT'ING LIBRARY SOURCES *)
[@@@ocaml.warning "-27-32-35"]
module Mach_lib = struct
(* THIS FILE WAS AUTOMATICALLY GENERATED BY CAT'ING LIBRARY SOURCES *)
[@@@ocaml.warning "-27-32-35"]
module Mach_error = struct
exception Mach_user_error of string

let user_errorf fmt = Printf.ksprintf (fun msg -> raise (Mach_user_error msg)) fmt

type t = [`User_error of string]
end
module Mach_std = struct
(** Standard utility functions used across the Mach code. *)

open Printf

module Filename = struct
  include Filename
  let (/) = concat
end

module Buffer = struct
  include Buffer
  let output_line oc line = output_string oc line; output_char oc '\n'
end

module SS = Set.Make(String)
module SM = Map.Make(String)

type 'a with_loc = { v: 'a; filename: string; line: int }

let equal_without_loc a b = a.v = b.v

let failwithf fmt = ksprintf failwith fmt

let command_exists cmd =
  Sys.command (sprintf "command -v %s >/dev/null 2>&1" (Filename.quote cmd)) = 0

let run_cmd cmd =
  let ic = Unix.open_process_in cmd in
  let output = try Some (input_line ic) with End_of_file -> None in
  match Unix.close_process_in ic with
  | Unix.WEXITED 0 -> output
  | _ -> None

let run_cmd_lines cmd =
  let ic = Unix.open_process_in cmd in
  let lines = In_channel.input_lines ic in
  match Unix.close_process_in ic with
  | Unix.WEXITED 0 -> lines
  | _ -> []

let rec mkdir_p path =
  if Sys.file_exists path then ()
  else begin
    mkdir_p (Filename.dirname path);
    (try Unix.mkdir path 0o755 with Unix.Unix_error (Unix.EEXIST, _, _) -> ())
  end

let rm_rf path =
  let cmd = sprintf "rm -rf %s" (Filename.quote path) in
  if Sys.command cmd <> 0 then failwithf "Command failed: %s" cmd

let write_file path content =
  Out_channel.with_open_text path (fun oc -> output_string oc content)
end
module S = struct
(* s.ml - Module signatures for mach *)

module type BUILD = sig
  type t
  val create : unit -> t
  val contents : t -> string

  val var : t -> string -> string -> unit
  val include_ : t -> string -> unit
  val rule : t -> target:string -> deps:string list -> string list -> unit
  val rulef : t -> target:string -> deps:string list -> ('a, unit, string, unit) format4 -> 'a
  val rule_phony : t -> target:string -> deps:string list -> unit
end
end
module Ninja : sig
(* ninja.mli - Ninja build backend *)

include S.BUILD
end = struct
(* ninja.ml - Ninja build backend *)

open Printf

type t = Buffer.t

let create () =
  let buf = Buffer.create 1024 in
  bprintf buf "rule cmd\n  command = $cmd\n\n";
  buf

let var buf name value =
  bprintf buf "%s = %s\n\n" name value

let contents = Buffer.contents

let include_ buf path = bprintf buf "subninja %s\n" path

let rule buf ~target ~deps recipe =
  bprintf buf "build %s:" target;
  (match recipe with
  | [] ->
    bprintf buf " phony";
    List.iter (bprintf buf " %s") deps;
    Buffer.add_char buf '\n'
  | _ ->
    bprintf buf " cmd";
    List.iter (bprintf buf " %s") deps;
    Buffer.add_char buf '\n';
    bprintf buf "  cmd = %s\n" (String.concat " && " recipe));
  Buffer.add_char buf '\n'

let rulef buf ~target ~deps fmt =
  ksprintf (fun recipe -> rule buf ~target ~deps [recipe]) fmt

let rule_phony buf ~target ~deps =
  bprintf buf "build %s: phony" target;
  List.iter (bprintf buf " %s") deps;
  Buffer.add_char buf '\n';
  Buffer.add_char buf '\n'
end
module Makefile : sig
(* makefile.mli - Makefile generation backend *)

include S.BUILD
end = struct
(* makefile.ml - Makefile generation backend *)

open Printf

type t = Buffer.t

let create () = Buffer.create 1024

let var buf name value =
  bprintf buf "%s = %s\n\n" name value

let contents = Buffer.contents

let include_ buf path = bprintf buf "include %s\n" path

let rule buf ~target ~deps recipe =
  bprintf buf "%s:" target;
  List.iter (bprintf buf " %s") deps;
  Buffer.add_char buf '\n';
  List.iter (bprintf buf "\t%s\n") recipe;
  Buffer.add_char buf '\n'

let rulef buf ~target ~deps fmt =
  ksprintf (fun recipe -> rule buf ~target ~deps [recipe]) fmt

let rule_phony buf ~target ~deps =
  bprintf buf ".PHONY: %s\n" target;
  rule buf ~target ~deps []
end
module Mach_module : sig
(** Modules which are build with mach are .ml files with mach directives. This
    module helps processing those. *)

open! Mach_std

(** Extract #require directives from a source file *)
val extract_requires : string -> (requires:string with_loc list * libs:string with_loc list, Mach_error.t) result

(** Extract #require directives from a source file, raises on error *)
val extract_requires_exn : string -> requires:string with_loc list * libs:string with_loc list

(** Preprocess source file, stripping directives while preserving line numbers *)
val preprocess_source : source_path:string -> out_channel -> in_channel -> unit
end = struct
open! Mach_std
open Printf

(* --- Parsing --- *)

let is_empty_line line = String.for_all (function ' ' | '\t' -> true | _ -> false) line
let is_shebang line = String.length line >= 2 && line.[0] = '#' && line.[1] = '!'
let is_directive line = String.length line >= 1 && line.[0] = '#'

let preprocess_source ~source_path oc ic =
  fprintf oc "# 1 %S\n" source_path;
  let rec loop in_header =
    match In_channel.input_line ic with
    | None -> ()
    | Some line when is_empty_line line -> Buffer.output_line oc line; loop in_header
    | Some line when in_header && is_directive line -> Buffer.output_line oc ""; loop true
    | Some line -> Buffer.output_line oc line; loop false
  in
  loop true

let is_require_path s = String.contains s '/'

let resolve_require ~source_path ~line path =
  let base_path =
    if Filename.is_relative path
    then Filename.concat (Filename.dirname source_path) path
    else path
  in
  let candidates = [base_path ^ ".ml"; base_path ^ ".mlx"] in
  let rec find_file = function
    | [] ->
        Mach_error.user_errorf "%s:%d: %s: No such file or directory" source_path line path
    | candidate :: rest ->
        if Sys.file_exists candidate then
          try Unix.realpath candidate
          with Unix.Unix_error (err, _, _) ->
            Mach_error.user_errorf "%s:%d: %s: %s" source_path line path (Unix.error_message err)
        else
          find_file rest
  in
  find_file candidates

let extract_requires_exn source_path : requires:string with_loc list * libs:string with_loc list =
  let rec parse line_num (~requires, ~libs) ic =
    match In_channel.input_line ic with
    | Some line when is_shebang line -> parse (line_num + 1) (~requires, ~libs) ic
    | Some line when is_directive line ->
      let req =
        try Scanf.sscanf line "#require %S%_s" Fun.id
        with Scanf.Scan_failure _ | End_of_file -> Mach_error.user_errorf "%s:%d: invalid #require directive" source_path line_num
      in
      if is_require_path req then
        let resolved = resolve_require ~source_path ~line:line_num req in
        let requires = { v = resolved; filename = source_path; line = line_num } :: requires in
        parse (line_num + 1) (~requires, ~libs) ic
      else
        let lib = { v = req; filename = source_path; line = line_num } in
        parse (line_num + 1) (~requires, ~libs:(lib :: libs)) ic
    | Some line when is_empty_line line -> parse (line_num + 1) (~requires, ~libs) ic
    | None | Some _ -> ~requires:(List.rev requires), ~libs:(List.rev libs)
  in
  In_channel.with_open_text source_path (parse 1 (~requires:[], ~libs:[]))

let extract_requires source_path =
  try Ok (extract_requires_exn source_path)
  with Mach_error.Mach_user_error msg -> Error (`User_error msg)
end
module Mach_log : sig
type verbose = Quiet | Verbose | Very_verbose | Very_very_verbose

val verbose : verbose ref

val log_verbose : ('a, unit, string, unit) format4 -> 'a
val log_very_verbose : ('a, unit, string, unit) format4 -> 'a
end = struct
type verbose = Quiet | Verbose | Very_verbose | Very_very_verbose

let verbose = ref Quiet

let log_at level fmt =
  Printf.ksprintf (fun msg -> if !verbose >= level then Printf.eprintf "%s\n%!" msg) fmt

let log_verbose fmt = log_at Verbose fmt
let log_very_verbose fmt = log_at Very_verbose fmt
end
module Mach_config : sig
(** Mach configuration discovery and parsing *)

open! Mach_std

(** Build backend type *)
type build_backend = Make | Ninja

val build_backend_to_string : build_backend -> string
val build_backend_of_string : string -> build_backend

(** Ocamlfind information *)
type ocamlfind_info = {
  ocamlfind_version : string option;
  ocamlfind_libs : string SM.t;  (** package name -> version *)
}

(** Detected toolchain versions *)
type toolchain = {
  ocaml_version : string;
  ocamlfind : ocamlfind_info Lazy.t;  (** lazily discovered on first #require "lib" *)
}

(** Mach configuration *)
type t = {
  home : string;
  build_backend : build_backend;
  mach_executable_path : string;
  toolchain : toolchain;
}

(** Get the current configuration.
    Resolution order:
    1. $MACH_HOME env var if set
    2. Walk up from cwd to find Mach file
    3. Fall back to $XDG_STATE_HOME/mach (or ~/.local/state/mach) *)
val get : unit -> (t, Mach_error.t) result

(** Get build directory for a script path *)
val build_dir_of : t -> string -> string
end = struct
(* mach_config - Mach configuration discovery and parsing *)

open! Mach_std
open Printf

(* --- Build backend types --- *)

type build_backend = Make | Ninja

let build_backend_to_string = function Make -> "make" | Ninja -> "ninja"
let build_backend_of_string = function
  | "make" -> Make
  | "ninja" -> Ninja
  | s -> failwith (sprintf "unknown build backend: %s" s)

(* --- Toolchain detection --- *)

type ocamlfind_info = {
  ocamlfind_version: string option;
  ocamlfind_libs: string SM.t;  (* package name -> version *)
}

type toolchain = {
  ocaml_version: string;
  ocamlfind: ocamlfind_info Lazy.t;
}

let detect_ocamlfind () =
  if command_exists "ocamlfind" then
    let version = run_cmd "ocamlfind query -format '%v' findlib" in
    let libs =
      run_cmd_lines "ocamlfind list"
      |> List.fold_left (fun acc line ->
           match Scanf.sscanf_opt line "%s %_s@(version: %[^)])" (fun n v -> n, v) with
           | Some (name, ver) -> SM.add name ver acc
           | None -> failwithf "unable to parse `ocamlfind list` line: %s" line)
         SM.empty
    in
    { ocamlfind_version = version; ocamlfind_libs = libs }
  else
    { ocamlfind_version = None; ocamlfind_libs = SM.empty }

let detect_toolchain () =
  let ocaml_version =
    match run_cmd "ocamlopt -version" with
    | Some v -> v
    | None -> Mach_error.user_errorf "ocamlopt not found"
  in
  { ocaml_version; ocamlfind = lazy (detect_ocamlfind ()) }

(* --- Config type and parsing --- *)

type t = {
  home: string;
  build_backend: build_backend;
  mach_executable_path: string;
  toolchain: toolchain;
}

let default_build_backend = Make

let mach_executable_path =
  lazy (
    match Sys.backend_type with
    | Sys.Native -> Unix.realpath Sys.executable_name
    | Sys.Bytecode ->
      let script =
        let path = Sys.argv.(0) in
        if Filename.is_relative path then Filename.(Sys.getcwd () / path) else path
      in
      sprintf "%s -I +unix unix.cma %s"
        (Filename.quote Sys.executable_name) (Filename.quote (Unix.realpath script))
    | Sys.Other _ -> failwith "mach must be run as a native/bytecode executable"
  )

let parse_file path =
  In_channel.with_open_text path (fun ic ->
    let rec loop build_backend line_num =
      match In_channel.input_line ic with
      | None -> Ok build_backend
      | Some line ->
        let line = String.trim line in
        if line = "" || String.starts_with ~prefix:"#" line then
          loop build_backend (line_num + 1)
        else
          match Scanf.sscanf_opt line "%s %S" (fun k v -> k, v) with
          | None ->
            Error (`User_error (sprintf "%s:%d: malformed line" path line_num))
          | Some (key, value) ->
            match key with
            | "build-backend" ->
              (try
                let build_backend = build_backend_of_string value in
                loop build_backend (line_num + 1)
              with Failure msg ->
                Error (`User_error (sprintf "%s:%d: %s" path line_num msg)))
            | _ ->
              Error (`User_error (sprintf "%s:%d: unknown key: %s" path line_num key))
    in
    loop default_build_backend 1)

let find_mach_config () =
  let rec search dir =
    let mach_path = Filename.(dir / "Mach") in
    if Sys.file_exists mach_path then Some (dir, mach_path)
    else
      let parent = Filename.dirname dir in
      if parent = dir then None
      else search parent
  in
  search (Sys.getcwd ())

let make_config ?mach_path home =
  let mach_executable_path = Lazy.force mach_executable_path in
  let toolchain = detect_toolchain () in
  let mach_path = Option.value mach_path ~default:Filename.(home / "Mach") in
  if Sys.file_exists mach_path then
    match parse_file mach_path with
    | Ok build_backend -> Ok { home; build_backend; mach_executable_path; toolchain }
    | Error _ as err -> err
  else
    Ok { home; build_backend = default_build_backend; mach_executable_path; toolchain }

let config =
  lazy (
    match Sys.getenv_opt "MACH_HOME" with
    | Some home -> make_config home
    | None ->
      match find_mach_config () with
      | Some (home, mach_path) -> make_config ~mach_path home
      | None ->
        let home = match Sys.getenv_opt "XDG_STATE_HOME" with
          | Some xdg -> Filename.(xdg / "mach")
          | None -> Filename.(Sys.getenv "HOME" / ".local" / "state" / "mach")
        in
        make_config home)

let get () = Lazy.force config

let build_dir_of config script_path =
  let normalized = String.split_on_char '/' script_path |> String.concat "__" in
  Filename.(config.home / "_mach" / "build" / normalized)
end
module Mach_state : sig
(** Mach state keep stats of a dependency graph of modules. *)

open! Mach_std

type file_stat = { mtime : int; size : int }

type lib = { name : string; version : string }

type entry = {
  ml_path : string;
  mli_path : string option;
  ml_stat : file_stat;
  mli_stat : file_stat option;
  requires : string with_loc list;  (** absolute paths to required modules with source location *)
  libs : lib with_loc list;  (** ocamlfind libraries with version and source location *)
}

(** State metadata for detecting configuration changes *)
type header = {
  build_backend : Mach_config.build_backend;
  mach_executable_path : string;
  ocaml_version : string;
  ocamlfind_version : string option;
}

type t = { header : header; root : entry; entries : entry list }

(** Read state from a file, returns None if file doesn't exist or is invalid *)
val read : string -> t option

(** Write state to a file *)
val write : string -> t -> unit

(** Reason for reconfiguration *)
type reconfigure_reason =
  | Env_changed  (** Build backend, mach path, or toolchain version changed *)
  | Modules_changed of SS.t  (** Set of ml_path that need reconfiguration *)

(** Check if state needs reconfiguration, and if so, what kind *)
val check_reconfigure_exn : Mach_config.t -> t -> reconfigure_reason option

(** Collect dependency state starting from an entry point module *)
val collect_exn : Mach_config.t -> string -> t

(** Collect dependency state starting from an entry point module *)
val collect : Mach_config.t -> string -> (t, Mach_error.t) result

(** Get the executable path for a state *)
val exe_path : Mach_config.t -> t -> string

(** Get all unique source directories from entries *)
val source_dirs : t -> string list

(** Get all unique ocamlfind library names from entries *)
val all_libs : t -> string list
end = struct
open! Mach_std
open Printf

type file_stat = { mtime : int; size : int }

let equal_file_stat x y = x.mtime = y.mtime && x.size = y.size

type lib = { name : string; version : string }

type entry = {
  ml_path : string;
  mli_path : string option;
  ml_stat : file_stat;
  mli_stat : file_stat option;
  requires : string with_loc list;
  libs : lib with_loc list;
}

type header = {
  build_backend : Mach_config.build_backend;
  mach_executable_path : string;
  ocaml_version : string;
  ocamlfind_version : string option;
}

type t = { header : header; root : entry; entries : entry list }

let output_line oc line = output_string oc line; output_char oc '\n'

let mli_path_of_ml_if_exists path =
  let base = Filename.remove_extension path in
  let mli = base ^ ".mli" in
  if Sys.file_exists mli then Some mli else None

let file_stat path =
  let st = Unix.stat path in
  { mtime = Int.of_float st.Unix.st_mtime; size = st.Unix.st_size }

(* --- State functions --- *)

let exe_path config t = Filename.concat (Mach_config.build_dir_of config t.root.ml_path) "a.out"

let source_dirs state =
  let seen = Hashtbl.create 16 in
  let add_dir path = Hashtbl.replace seen (Filename.dirname path) () in
  List.iter (fun entry -> add_dir entry.ml_path) state.entries;
  Hashtbl.fold (fun dir () acc -> dir :: acc) seen []
  |> List.sort String.compare

let all_libs state =
  let seen = Hashtbl.create 16 in
  List.iter (fun e -> List.iter (fun (l : lib with_loc) -> Hashtbl.replace seen l.v.name ()) e.libs) state.entries;
  Hashtbl.fold (fun l () acc -> l :: acc) seen [] |> List.sort String.compare

let read path =
  if not (Sys.file_exists path) then None
  else try
    let lines = In_channel.with_open_text path In_channel.input_lines in
    (* Parse header *)
    let header, entry_lines = match lines with
      | bb_line :: mp_line :: ov_line :: ofv_line :: "" :: rest ->
        let build_backend = Scanf.sscanf bb_line "build_backend %s" Mach_config.build_backend_of_string in
        let mach_executable_path = Scanf.sscanf mp_line "mach_executable_path %s@\n" Fun.id in
        let ocaml_version = Scanf.sscanf ov_line "ocaml_version %s@\n" Fun.id in
        let ocamlfind_version =
          let v = Scanf.sscanf ofv_line "ocamlfind_version %s@\n" Fun.id in
          if v = "none" then None else Some v
        in
        Some { build_backend; mach_executable_path; ocaml_version; ocamlfind_version }, rest
      | _ -> None, []  (* Missing header = needs reconfigure *)
    in
    match header with
    | None -> None
    | Some header ->
      let mli_path_of ml_path =
        let base = Filename.remove_extension ml_path in
        Some (base ^ ".mli")
      in
      let finalize cur = {cur with requires = List.rev cur.requires; libs = List.rev cur.libs} in
      let rec loop acc cur = function
        | [] -> (match cur with Some cur -> finalize cur :: acc | None -> acc)
        | line :: rest when String.length line > 6 && String.sub line 0 6 = "  mli " ->
          let e = Option.get cur in
          let m, s = Scanf.sscanf line "  mli %i %d" (fun m s -> m, s) in
          loop acc (Some { e with mli_path = mli_path_of e.ml_path; mli_stat = Some { mtime = m; size = s } }) rest
        | line :: rest when String.length line > 6 && String.sub line 0 6 = "  lib " ->
          let e = Option.get cur in
          let filename, line_num, name, version = Scanf.sscanf line "  lib %s %d %s %s@\n" (fun f l n v -> f, l, n, v) in
          let lib : _ with_loc = { filename; line = line_num; v = { name; version } } in
          loop acc (Some { e with libs = lib :: e.libs }) rest
        | line :: rest when String.length line > 10 && String.sub line 0 10 = "  requires" ->
          let e = Option.get cur in
          let filename, line_num, v = Scanf.sscanf line "  requires %s %d %s" (fun f l v -> f, l, v) in
          let req : _ with_loc = { filename; line = line_num; v } in
          loop acc (Some { e with requires = req :: e.requires }) rest
        | line :: rest ->
          let acc = match cur with Some cur -> finalize cur :: acc | None -> acc in
          let p, m, s = Scanf.sscanf line "%s %i %d" (fun p m s -> p, m, s) in
          loop acc (Some { ml_path = p; mli_path = None; ml_stat = { mtime = m; size = s }; mli_stat = None; requires = []; libs = [] }) rest
      in
      match loop [] None entry_lines with
      | [] -> None
      | root::_ as entries -> Some { header; root; entries = List.rev entries }
  with _ -> None

let write path state =
  Out_channel.with_open_text path (fun oc ->
    (* Write header *)
    output_line oc (sprintf "build_backend %s" (Mach_config.build_backend_to_string state.header.build_backend));
    output_line oc (sprintf "mach_executable_path %s" state.header.mach_executable_path);
    output_line oc (sprintf "ocaml_version %s" state.header.ocaml_version);
    output_line oc (sprintf "ocamlfind_version %s" (Option.value state.header.ocamlfind_version ~default:"none"));
    output_line oc "";
    (* Write entries *)
    List.iter (fun e ->
      output_line oc (sprintf "%s %i %d" e.ml_path e.ml_stat.mtime e.ml_stat.size);
      Option.iter (fun st -> output_line oc (sprintf "  mli %i %d" st.mtime st.size)) e.mli_stat;
      List.iter (fun (r : _ with_loc) -> output_line oc (sprintf "  requires %s %d %s" r.filename r.line r.v)) e.requires;
      List.iter (fun (l : lib with_loc) -> output_line oc (sprintf "  lib %s %d %s %s" l.filename l.line l.v.name l.v.version)) e.libs
    ) state.entries)

type reconfigure_reason =
  | Env_changed
  | Modules_changed of SS.t

let check_reconfigure_exn config state =
  let build_backend = config.Mach_config.build_backend in
  let mach_path = config.Mach_config.mach_executable_path in
  let toolchain = config.Mach_config.toolchain in
  (* Check environment first - if changed, need full reconfigure *)
  let env_changed =
    state.header.build_backend <> build_backend ||
    state.header.mach_executable_path <> mach_path ||
    state.header.ocaml_version <> toolchain.ocaml_version ||
    (state.header.ocamlfind_version <> None &&
     state.header.ocamlfind_version <> (Lazy.force toolchain.ocamlfind).ocamlfind_version)
  in
  if env_changed then
    (Mach_log.log_very_verbose "mach:state: environment changed, need reconfigure";
     Some Env_changed)
  else
    (* Check each entry for changes *)
    let changed_modules = SS.of_list @@ List.filter_map (fun entry ->
      if not (Sys.file_exists entry.ml_path) then None  (* removed files handled by collect_exn *)
      else if mli_path_of_ml_if_exists entry.ml_path <> entry.mli_path
      then (Mach_log.log_very_verbose "mach:state: .mli added/removed, need reconfigure";
            Some entry.ml_path)
      else if not (equal_file_stat (file_stat entry.ml_path) entry.ml_stat)
      then
        let ~requires, ~libs = Mach_module.extract_requires_exn entry.ml_path in
        let libs_names_equal =
          List.length libs = List.length entry.libs &&
          List.for_all2 (fun a b -> a.v = b.v.name && a.filename = b.filename && a.line = b.line)
            libs entry.libs
        in
        if not (List.equal equal_without_loc requires entry.requires) || not libs_names_equal
        then (Mach_log.log_very_verbose "mach:state: requires/libs changed, need reconfigure";
              Some entry.ml_path)
        else None
      else None
    ) state.entries in
    if SS.is_empty changed_modules then None
    else Some (Modules_changed changed_modules)

let collect_exn config entry_path =
  let build_backend = config.Mach_config.build_backend in
  let mach_executable_path = config.Mach_config.mach_executable_path in
  let toolchain = config.Mach_config.toolchain in
  let entry_path = Unix.realpath entry_path in
  let visited = Hashtbl.create 16 in
  let entries = ref [] in
  let rec dfs ml_path =
    if Hashtbl.mem visited ml_path then ()
    else begin
      Hashtbl.add visited ml_path ();
      let ~requires, ~libs = Mach_module.extract_requires_exn ml_path in
      let libs = List.map (fun lib ->
        let info = Lazy.force toolchain.ocamlfind in
        if info.ocamlfind_version = None then
          Mach_error.user_errorf "%s:%d: library %S requires ocamlfind but ocamlfind is not installed" lib.filename lib.line lib.v
        else match SM.find_opt lib.v info.ocamlfind_libs with
        | None ->
          Mach_error.user_errorf "%s:%d: library %S not found" lib.filename lib.line lib.v
        | Some version ->
          { lib with v = { name = lib.v; version } }
      ) libs in
      List.iter (fun r -> dfs r.v) requires;
      let mli_path = mli_path_of_ml_if_exists ml_path in
      let mli_stat = Option.map file_stat mli_path in
      entries := { ml_path; mli_path; ml_stat = file_stat ml_path; mli_stat; requires; libs } :: !entries
    end
  in
  dfs entry_path;
  (* Lazy.is_val checks if lazy was forced, i.e. if any libs were encountered *)
  let ocamlfind_version =
    if Lazy.is_val toolchain.ocamlfind
    then (Lazy.force toolchain.ocamlfind).ocamlfind_version
    else None
  in
  let header = {
    build_backend;
    mach_executable_path;
    ocaml_version = toolchain.ocaml_version;
    ocamlfind_version;
  } in
  match !entries with
  | [] -> failwith "Internal error: no entries collected"
  | root::_ as entries -> { header; root; entries = List.rev entries }

let collect config entry_path =
  try Ok (collect_exn config entry_path)
  with Mach_error.Mach_user_error msg -> Error (`User_error msg)
end
module Mach_lib : sig
type verbose = Mach_log.verbose = Quiet | Verbose | Very_verbose | Very_very_verbose

val pp : string -> unit

val configure : Mach_config.t -> string -> ((state:Mach_state.t * reconfigured:bool), Mach_error.t) result

val build : Mach_config.t -> string -> ((state:Mach_state.t * reconfigured:bool), Mach_error.t) result
end = struct
(* mach_lib - Shared code for mach and mach-lsp *)

open! Mach_std
open Printf

type verbose = Mach_log.verbose = Quiet | Verbose | Very_verbose | Very_very_verbose

let log_verbose = Mach_log.log_verbose
let log_very_verbose = Mach_log.log_very_verbose

let module_name_of_path path = Filename.(basename path |> remove_extension)

(* --- Build backend types (re-exported from Mach_config) --- *)

type build_backend = Mach_config.build_backend = Make | Ninja

(* --- Module kind (ML or MLX) --- *)

type module_kind = ML | MLX

let module_kind_of_path path =
  if Filename.extension path = ".mlx" then MLX else ML

let src_ext_of_kind = function ML -> ".ml" | MLX -> ".mlx"

(* --- PP (for merlin and build) --- *)

let pp source_path =
  In_channel.with_open_text source_path (fun ic ->
    Mach_module.preprocess_source ~source_path stdout ic);
  flush stdout

(* --- Configure --- *)

type ocaml_module = {
  ml_path: string;
  mli_path: string option;
  cmx: string;
  cmi: string;
  cmt: string;
  module_name: string;
  build_dir: string;
  resolved_requires: string with_loc list;  (* absolute paths *)
  libs: Mach_state.lib with_loc list;  (* ocamlfind libraries with versions *)
  kind: module_kind;
}

let configure_backend config ~state ~prev_state ~changed_modules =
  let build_backend = config.Mach_config.build_backend in
  let build_dir_of = Mach_config.build_dir_of config in
  let (module B : S.BUILD), module_file, root_file =
    match build_backend with
    | Make -> (module Makefile), "mach.mk", "Makefile"
    | Ninja -> (module Ninja), "mach.ninja", "build.ninja"
  in
  let cmd = state.Mach_state.header.mach_executable_path in
  let capture_outf fmt = ksprintf (sprintf "${MACH} run-build-command -- %s") fmt in
  let capture_stderrf fmt = ksprintf (sprintf "${MACH} run-build-command --stderr-only -- %s") fmt in
  let configure_ocaml_module b (m : ocaml_module) =
    let src_ext = src_ext_of_kind m.kind in
    let src = Filename.(m.build_dir / m.module_name ^ src_ext) in
    let mli = Filename.(m.build_dir / m.module_name ^ ".mli") in
    B.rulef b ~target:src ~deps:[m.ml_path] "%s pp %s > %s" cmd m.ml_path src;
    Option.iter (fun mli_path ->
      B.rulef b ~target:mli ~deps:[mli_path] "%s pp %s > %s" cmd mli_path mli
    ) m.mli_path;
    let args = Filename.(m.build_dir / "includes.args") in
    let recipe =
      match m.resolved_requires with
      | [] -> [sprintf "touch %s" args]
      | requires -> List.map (fun (r : _ with_loc) -> sprintf "echo '-I=%s' >> %s" (build_dir_of r.v) args) requires
    in
    B.rule b ~target:args ~deps:[src] (sprintf "rm -f %s" args :: recipe);
    (* Generate lib_includes.args for ocamlfind library include paths (only if libs present) *)
    (match m.libs with
    | [] -> ()
    | libs ->
      let lib_args = Filename.(m.build_dir / "lib_includes.args") in
      let libs = String.concat " " (List.map (fun (l : Mach_state.lib with_loc) -> l.v.name) libs) in
      B.rule b ~target:lib_args ~deps:[] [capture_stderrf "ocamlfind query -format '-I=%%d' -recursive %s > %s" libs lib_args])
  in
  let compile_ocaml_module b (m : ocaml_module) =
    let src_ext = src_ext_of_kind m.kind in
    let src = Filename.(m.build_dir / m.module_name ^ src_ext) in
    let mli = Filename.(m.build_dir / m.module_name ^ ".mli") in
    let args = Filename.(m.build_dir / "includes.args") in
    let pp_flag = match m.kind with ML -> "" | MLX -> " -pp mlx-pp" in
    let cmi_deps = List.map (fun (r : _ with_loc) -> Filename.(build_dir_of r.v / module_name_of_path r.v ^ ".cmi")) m.resolved_requires in
    let lib_args_dep, lib_args_cmd = match m.libs with
      | [] -> [], ""
      | _ -> [Filename.(m.build_dir / "lib_includes.args")], sprintf " -args %s" Filename.(m.build_dir / "lib_includes.args")
    in
    match m.mli_path with
    | Some _ -> (* With .mli: compile .mli to .cmi/.cmti first (using ocamlc for speed), then .ml to .cmx *)
      B.rule b ~target:m.cmi ~deps:(mli :: args :: lib_args_dep @ cmi_deps)
        [capture_outf "ocamlc%s -bin-annot -c -opaque -args %s%s -o %s %s" pp_flag args lib_args_cmd m.cmi mli];
      B.rule b ~target:m.cmx ~deps:([src; m.cmi; args] @ lib_args_dep)
        [capture_outf "ocamlopt%s -bin-annot -c -args %s%s -cmi-file %s -o %s -impl %s" pp_flag args lib_args_cmd m.cmi m.cmx src];
      B.rule b ~target:m.cmt ~deps:[m.cmx] []
    | None -> (* Without .mli: ocamlopt produces both .cmi and .cmx *)
      B.rule b ~target:m.cmx ~deps:(src :: args :: lib_args_dep @ cmi_deps)
        [capture_outf "ocamlopt%s -bin-annot -c -args %s%s -o %s -impl %s" pp_flag args lib_args_cmd m.cmx src];
      B.rule b ~target:m.cmi ~deps:[m.cmx] [];
      B.rule b ~target:m.cmt ~deps:[m.cmx] []
  in
  let link_ocaml_module b (all_objs : string list) (all_libs : string list) ~exe_path =
    let root_build_dir = Filename.dirname exe_path in
    let args = Filename.(root_build_dir / "all_objects.args") in
    let objs_str = String.concat " " all_objs in
    B.rulef b ~target:args ~deps:all_objs "printf '%%s\\n' %s > %s" objs_str args;
    match all_libs with
    | [] ->
      B.rule b ~target:exe_path ~deps:(args :: all_objs)
        [capture_outf "ocamlopt -o %s -args %s" exe_path args]
    | libs ->
      let lib_args = Filename.(root_build_dir / "lib_objects.args") in
      let libs = String.concat " " libs in
      B.rule b ~target:lib_args ~deps:[] [capture_stderrf "ocamlfind query -a-format -recursive -predicates native %s > %s" libs lib_args];
      B.rule b ~target:exe_path ~deps:(args :: lib_args :: all_objs)
        [capture_outf "ocamlopt -o %s -args %s -args %s" exe_path lib_args args]
  in
  let modules = List.map (fun ({ml_path;mli_path;requires=resolved_requires;libs;_} : Mach_state.entry) ->
    let module_name = module_name_of_path ml_path in
    let build_dir = build_dir_of ml_path in
    let kind = module_kind_of_path ml_path in
    let cmx = Filename.(build_dir / module_name ^ ".cmx") in
    let cmi = Filename.(build_dir / module_name ^ ".cmi") in
    let cmt = Filename.(build_dir / module_name ^ ".cmt") in
    { ml_path; mli_path; module_name; build_dir; resolved_requires;cmx;cmi;cmt;libs;kind }
  ) state.Mach_state.entries in
  let old_modules = match prev_state with
    | None -> SS.empty
    | Some old -> SS.of_list (List.map (fun e -> e.Mach_state.ml_path) old.Mach_state.entries)
  in
  (* Generate per-module build files - only for changed/new modules *)
  List.iter (fun (m : ocaml_module) ->
    let needs_configure = match changed_modules with
      | None -> true  (* full reconfigure *)
      | Some changed_modules -> SS.mem m.ml_path changed_modules || not (SS.mem m.ml_path old_modules)
    in
    if needs_configure then begin
      log_verbose "mach: configuring %s" m.ml_path;
      mkdir_p m.build_dir;
      let file_path = Filename.(m.build_dir / module_file) in
      write_file file_path (
        let b = B.create () in
        configure_ocaml_module b m;
        compile_ocaml_module b m;
        B.contents b)
    end
  ) modules;
  (* Generate root build file *)
  let exe_path = Mach_state.exe_path config state in
  let all_objs = List.map (fun m -> m.cmx) modules in
  let all_libs = Mach_state.all_libs state in
  write_file Filename.(build_dir_of state.root.ml_path / root_file) (
    log_verbose "mach: configuring %s (root)" state.root.ml_path;
    let b = B.create () in
    B.var b "MACH" cmd;
    List.iter (fun entry ->
      B.include_ b Filename.(build_dir_of entry.Mach_state.ml_path / module_file)) state.entries;
    B.rule_phony b ~target:"all" ~deps:[exe_path];
    link_ocaml_module b all_objs all_libs ~exe_path;
    B.contents b
  )

let configure_exn config source_path =
  let build_dir_of = Mach_config.build_dir_of config in
  let source_path = Unix.realpath source_path in
  let build_dir = build_dir_of source_path in
  let state_path = Filename.(build_dir / "Mach.state") in
  let ~prev_state, ~state, ~reconfigure_reason =
    match Mach_state.read state_path with
    | None ->
      log_very_verbose "mach:configure: no previous state found, creating one...";
      let state = Mach_state.collect_exn config source_path in
      ~prev_state:None, ~state, ~reconfigure_reason:(Some Mach_state.Env_changed)
    | Some state as prev_state ->
      match Mach_state.check_reconfigure_exn config state with
      | None -> ~prev_state, ~state, ~reconfigure_reason:None
      | Some reason ->
        log_very_verbose "mach:configure: need reconfigure";
        let state = Mach_state.collect_exn config source_path in
        ~prev_state, ~state, ~reconfigure_reason:(Some reason)
  in
  begin match reconfigure_reason with
  | None -> ()
  | Some reconfigure_reason ->
    log_verbose "mach: configuring...";
    let changed_modules = match reconfigure_reason with
      | Mach_state.Env_changed -> None  (* full reconfigure *)
      | Mach_state.Modules_changed set -> Some set
    in
    (* Drop build dirs for changed modules *)
    begin match changed_modules, config.build_backend with
    | None, _ ->
      List.iter (fun entry -> rm_rf (build_dir_of entry.Mach_state.ml_path)) state.entries
    | Some set, Make ->
      List.iter (fun entry -> if SS.mem entry.Mach_state.ml_path set then rm_rf (build_dir_of entry.ml_path)) state.entries
    | Some _, Ninja -> (* will do cleandead instead *) ()
    end;
    mkdir_p build_dir;
    configure_backend config ~state ~prev_state ~changed_modules;
    begin match config.Mach_config.build_backend with
    | Make -> ()
    | Ninja ->
      (* Ninja requires a full clean on reconfigure to avoid stale build files *)
      let cmd = sprintf "ninja -C %s -t cleandead > /dev/null" (Filename.quote (build_dir_of state.root.ml_path)) in
      if !Mach_log.verbose = Very_very_verbose then eprintf "+ %s\n%!" cmd;
      if Sys.command cmd <> 0 then Mach_error.user_errorf "ninja cleandead failed"
    end;
    Mach_state.write state_path state
  end;
  ~state, ~reconfigured:(Option.is_some reconfigure_reason)

let configure config source_path =
  try Ok (configure_exn config source_path)
  with Mach_error.Mach_user_error msg -> Error (`User_error msg)

(* --- Build --- *)

let run_build cmd =
  let open Unix in
  let cmd = sprintf "%s 2>&1" cmd in
  let ic = open_process_in cmd in
  begin try while true do
    let line = input_line ic in
    if String.length line >= 3 && String.sub line 0 3 = ">>>" then
      prerr_endline (String.sub line 3 (String.length line - 3))
  done with End_of_file -> () end;
  match close_process_in ic with
  | WEXITED code -> code
  | WSIGNALED _ | WSTOPPED _ -> 1

let build_exn config script_path =
  let build_dir_of = Mach_config.build_dir_of config in
  let ~state, ~reconfigured = configure_exn config script_path in
  log_verbose "mach: building...";
  let cmd = match config.Mach_config.build_backend with
    | Make -> if !Mach_log.verbose = Very_very_verbose then "make all" else "make -s all"
    | Ninja -> if !Mach_log.verbose = Very_very_verbose then "ninja -v" else "ninja --quiet"
  in
  let cmd = sprintf "%s -C %s" cmd (Filename.quote (build_dir_of state.root.ml_path)) in
  if !Mach_log.verbose = Very_very_verbose then eprintf "+ %s\n%!" cmd;
  if run_build cmd <> 0 then Mach_error.user_errorf "build failed";
  ~state, ~reconfigured

let build config script_path =
  try Ok (build_exn config script_path)
  with Mach_error.Mach_user_error msg -> Error (`User_error msg)
end
include Mach_lib
end
module Cmdliner = struct
(* THIS FILE WAS AUTOMATICALLY GENERATED BY CAT'ING LIBRARY SOURCES *)
[@@@ocaml.warning "-27-32-35"]
module Cmdliner_trie : sig
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

(** Tries.

    This implementation also maps any non ambiguous prefix of a
    key to its value. *)

type 'a t

val empty : 'a t
val is_empty : 'a t -> bool
val add : 'a t -> string -> 'a -> [ `New of 'a t | `Replaced of 'a * 'a t ]
val find :
  legacy_prefixes:bool -> 'a t -> string ->
  ('a, [`Ambiguous | `Not_found ]) result
val ambiguities : 'a t -> string -> string list
val of_list : (string * 'a) list -> 'a t

val legacy_prefixes : env:(string -> string option) -> bool
end = struct
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

module Cmap = Map.Make (Char) (* character maps. *)

type 'a value = (* type for holding a bound value. *)
| Pre of 'a (* value is bound by the prefix of a key. *)
| Key of 'a (* value is bound by an entire key. *)
| Amb (* no value bound because of ambiguous prefix. *)
| Nil (* not bound (only for the empty trie). *)

type 'a t = { v : 'a value; succs : 'a t Cmap.t }
let empty = { v = Nil; succs = Cmap.empty }
let is_empty t = t = empty

(* N.B. If we replace a non-ambiguous key, it becomes ambiguous but it's
   not important for our use. Also the following is not tail recursive but
   the stack is bounded by key length. *)
let add t k d =
  let rec loop t k len i d pre_d = match i = len with
  | true ->
      let t' = { v = Key d; succs = t.succs } in
      begin match t.v with
      | Key old -> `Replaced (old, t')
      | _ -> `New t'
      end
  | false ->
      let v = match t.v with
      | Amb | Pre _ -> Amb | Key _ as v -> v | Nil -> pre_d
      in
      let t' = try Cmap.find k.[i] t.succs with Not_found -> empty in
      match loop t' k len (i + 1) d pre_d with
      | `New n -> `New { v; succs = Cmap.add k.[i] n t.succs }
      | `Replaced (o, n) ->
          `Replaced (o, { v; succs = Cmap.add k.[i] n t.succs })
  in
  loop t k (String.length k) 0 d (Pre d (* allocate less *))

let find_node t k =
  let rec aux t k len i =
    if i = len then t else
    aux (Cmap.find k.[i] t.succs) k len (i + 1)
  in
  aux t k (String.length k) 0

let find ~legacy_prefixes t k = match (find_node t k).v with
| Key v -> Ok v
| Pre v when legacy_prefixes -> Ok v
| Pre v -> Error `Not_found
| Amb when legacy_prefixes -> Error `Ambiguous
| Amb -> Error `Not_found
| Nil -> Error `Not_found
| exception Not_found -> Error `Not_found

let ambiguities t p =                        (* ambiguities of [p] in [t]. *)
  try
    let t = find_node t p in
    match t.v with
    | Key _ | Pre _ | Nil -> []
    | Amb ->
        let add_char s c = s ^ (String.make 1 c) in
        let rem_char s = String.sub s 0 ((String.length s) - 1) in
        let to_list m = Cmap.fold (fun k t acc -> (k,t) :: acc) m [] in
        let rec aux acc p = function
        | ((c, t) :: succs) :: rest ->
            let p' = add_char p c in
            let acc' = match t.v with
            | Pre _ | Amb -> acc
            | Key _ -> (p' :: acc)
            | Nil -> assert false
            in
            aux acc' p' ((to_list t.succs) :: succs :: rest)
        | [] :: [] -> acc
        | [] :: rest -> aux acc (rem_char p) rest
        | [] -> assert false
        in
        aux [] p (to_list t.succs :: [])
  with Not_found -> []

let of_list l =
  let add t (s, v) = match add t s v with `New t -> t | `Replaced (_, t) -> t in
  List.fold_left add empty l

let legacy_prefixes ~env = match env "CMDLINER_LEGACY_PREFIXES" with
| None -> false
| Some s ->
    match String.lowercase_ascii s with
    | "true" | "yes" | "y" | "1" -> true
    | _ -> false
end
module Cmdliner_base : sig
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

(** A few helpful base definitions. *)

val uid : unit -> int
(** [uid ()] is new unique for the program run. *)

val suggest : string -> string list -> string list
(** [suggest near candidates]  suggest values from [candidates]
    not too far from [near]. *)

val is_space : char -> bool
val string_starts_with : prefix:string -> string -> bool
val string_drop_first : int -> string -> string

(* Formatters *)

module Fmt : sig
  type 'a t = Format.formatter -> 'a -> unit
  val str : ('a, Format.formatter, unit, string) format4 -> 'a
  val pf : Format.formatter -> ('a, Format.formatter, unit) format -> 'a
  val nop : 'a t
  val sp : unit t
  val comma : unit t
  val cut : unit t
  val char : char t
  val string : string t
  val indent : int t
  val list : ?sep:unit t -> 'a t -> 'a list t
  val styled_text : string t
  val lines : string t
  val tokens : spaces:bool -> string t
  val text : string t
  val code : string t
  val code_var : string t
  val code_or_quote : string t
  val ereason : string t
  val missing : unit t
  val invalid : unit t
  val deprecated : unit t
  val puterr : unit t

  type styler = Ansi | Plain
  val styler : unit -> styler
end

(* Error message helpers *)

val quote : string -> string
val pp_alts : string list Fmt.t
val alts_str : ?quoted:bool -> string list -> string
val err_empty_list : string
val err_ambiguous : kind:string -> string -> ambs:string list -> string
val err_unknown :
  ?dom:string list -> ?hints:string list -> kind:string -> string -> string
val err_multi_def :
  kind:string -> string -> ('b -> string) -> 'b -> 'b -> string
end = struct
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

let strf = Printf.sprintf

(* Unique ids *)

let uid =
  (* Thread-safe UIDs, Oo.id (object end) was used before.
     Note this won't be thread-safe in multicore, we should use
     Atomic but this is >= 4.12 and we have 4.08 for now. *)
  let c = ref 0 in
  fun () ->
    let id = !c in
    incr c; if id > !c then assert false (* too many ids *) else id

(* Edit distance

   The stdlib has much better in but this will be only >= 5.4, maybe
   in twenty years. *)

let edit_distance s0 s1 =
  let minimum (a : int) (b : int) (c : int) : int = min a (min b c) in
  let s0,s1 = if String.length s0 <= String.length s1 then s0,s1 else s1,s0 in
  let m = String.length s0 and n = String.length s1 in
  let rec rows row0 row i = match i > n with
  | true -> row0.(m)
  | false ->
      row.(0) <- i;
      for j = 1 to m do
        if s0.[j - 1] = s1.[i - 1] then row.(j) <- row0.(j - 1) else
        row.(j) <- minimum (row0.(j - 1) + 1) (row0.(j) + 1) (row.(j - 1) + 1)
      done;
      rows row row0 (i + 1)
  in
  rows (Array.init (m + 1) (fun x -> x)) (Array.make (m + 1) 0) 1

let suggest s candidates =
  let add (min, acc) name =
    let d = edit_distance s name in
    if d = min then min, (name :: acc) else
    if d < min then d, [name] else
    min, acc
  in
  let dist, suggs = List.fold_left add (max_int, []) candidates in
  if dist < 3 (* suggest only if not too far *) then suggs else []

(* Stdlib compatibility *)

let is_space = function ' ' | '\n' | '\r' | '\t' -> true | _ -> false

let string_starts_with ~prefix s = (* available in 4.13 *)
  let prefix_len = String.length prefix in
  let s_len = String.length s in
  if prefix_len > s_len then false else
  let rec loop i =
    if i = prefix_len then true
    else if String.get prefix i = String.get s i then loop (i + 1)
    else false
  in
  loop 0

let string_drop_first n s =
  if n <= 0 then s else
  if n >= String.length s then "" else
  String.sub s n (String.length s - n)

(* Invalid argument strings *)

let err_empty_list = "empty list"

(* Formatting tools *)

module Fmt = struct
  type 'a t = Format.formatter -> 'a -> unit
  let str = Format.asprintf
  let pf = Format.fprintf
  let nop ppf _ = ()
  let sp = Format.pp_print_space
  let cut = Format.pp_print_cut
  let string = Format.pp_print_string
  let char = Format.pp_print_char
  let comma ppf () = char ppf ','; sp ppf ()
  let indent ppf c = for i = 1 to c do char ppf ' ' done
  let list ?sep pp_v ppf l = Format.pp_print_list ?pp_sep:sep pp_v ppf l
  let text = Format.pp_print_text
  let lines ppf s =
    let rec stop_at sat ~start ~max s =
      if start > max then start else
      if sat s.[start] then start else
      stop_at sat ~start:(start + 1) ~max s
    in
    let sub s start stop ~max =
      if start = stop then "" else
      if start = 0 && stop > max then s else
      String.sub s start (stop - start)
    in
    let is_nl c = c = '\n' in
    let max = String.length s - 1 in
    let rec loop start s = match stop_at is_nl ~start ~max s with
    | stop when stop > max -> Format.pp_print_string ppf (sub s start stop ~max)
    | stop ->
        Format.pp_print_string ppf (sub s start stop ~max);
        Format.pp_force_newline ppf ();
        loop (stop + 1) s
    in
    loop 0 s

  let tokens ~spaces ppf s = (* collapse white and hint spaces (maybe) *)
    let i_max = String.length s - 1 in
    let flush start stop = string ppf (String.sub s start (stop - start + 1)) in
    let rec skip_white i =
      if i > i_max then i else
      if is_space s.[i] then skip_white (i + 1) else i
    in
    let rec loop start i =
      if i > i_max then flush start i_max else
      if not (is_space s.[i]) then loop start (i + 1) else
      let next_start = skip_white i in
      (flush start (i - 1); if spaces then sp ppf () else char ppf ' ';
       if next_start > i_max then () else loop next_start next_start)
    in
    loop 0 0

  (* Text styling *)

  type styler = Ansi | Plain
  let styler' =
    ref begin match Sys.getenv_opt "NO_COLOR" with
    | Some s when s <> "" -> Plain
    | _ ->
        match Sys.getenv_opt "TERM" with
        | Some "dumb" -> Plain
        | None when Sys.backend_type <> Other "js_of_ocaml" -> Plain
        | _ -> Ansi
    end

  let set_styler styler = styler' := styler
  let styler () = !styler'

  let sgr_of_style = function
  | `Bold -> "01"
  | `Underline -> "04"
  | `Fg `Red -> string_of_int (30 + 1)
  | `Fg `Yellow -> string_of_int (30 + 3)

  let sgrs_of_styles styles = String.concat ";" (List.map sgr_of_style styles)
  let ansi_esc = "\x1B["
  let sgr_reset = "\x1B[m"

  let ansi styles ppf s =
    let sgrs = String.concat "" [ansi_esc; sgrs_of_styles styles; "m"] in
    Format.pp_print_as ppf 0 sgrs;
    string ppf s;
    Format.pp_print_as ppf 0 sgr_reset

  let st styles ppf s = match !styler' with
  | Plain -> string ppf s
  | Ansi -> ansi styles ppf s

  let code ppf v = st [`Bold] ppf v
  let code_var ppf v = st [`Underline] ppf v
  let code_or_quote ppf v = match !styler' with
  | Plain -> char ppf '\''; string ppf v; char ppf '\''
  | Ansi -> ansi [`Bold] ppf v

  let ereason ppf s = match !styler' with
  | Plain -> string ppf s
  | Ansi -> ansi [`Fg `Red] ppf s

  let wreason ppf s = match !styler' with
  | Plain -> string ppf s
  | Ansi -> ansi [`Fg `Yellow] ppf s

  let missing ppf () = ereason ppf "missing"
  let invalid ppf () = ereason ppf "invalid"
  let unknown ppf () = ereason ppf "unknown"
  let deprecated ppf () = wreason ppf "deprecated"

  let puterr ppf () = st [`Bold; `Fg `Red] ppf "Error"; char ppf ':'

  let styled_text ppf s =
    (* Detects ANSI escapes and prints them as 0 width. Collapses spaces
       and newlines to single space except for blank lines which are
       preserved. *)
    let rec loop ppf s i max =
      if i > max then () else
      let ansi = s.[i] = '\x1B' && i + 1 < max && s.[i+1] = '[' in
      if not ansi then match s.[i] with
      | ' ' when i = max || s.[i+1] = ' ' || s.[i+1] = '\n' ->
          loop ppf s (i + 1) max
      | ' ' -> sp ppf (); loop ppf s (i + 1) max
      | '\n' when i = max || s.[i+1] = ' ' -> loop ppf s (i + 1) max
      | '\n' when s.[i+1] = '\n' ->
          Format.pp_force_newline ppf ();
          if i > 0 && s.[i-1] <> '\n' then Format.pp_force_newline ppf ();
          loop ppf s (i + 1) max
      | '\n' -> sp ppf (); loop ppf s (i + 1) max
      | c -> char ppf s.[i]; loop ppf s (i + 1) max
      else begin
        let k = ref (i + 2) in
        while (!k <= max && s.[!k] <> 'm') do incr k done;
        let esc = String.sub s i (!k - i + 1) in
        Format.pp_print_as ppf 0 esc;
        loop ppf s (!k + 1) max
      end
    in
    loop ppf s 0 (String.length s - 1)
end

(* Converter (end-user) error messages *)

let err_multi_def ~kind name doc v v' = (* programming error *)
  strf "%s %s defined twice (doc strings are '%s' and '%s')"
    kind name (doc v) (doc v')

let quote s = strf "'%s'" s (* Exposed in the API do not change *)
let _alts_str ~styled ?quoted ppf alts =
  let quote = match quoted with
  | None -> fun ppf s -> Fmt.pf ppf "$(b,%s)" s
  | Some quoted ->
      if not quoted then Fmt.string else
      if styled then Fmt.code_or_quote else
      fun ppf s -> Fmt.pf ppf "'%s'" s
  in
  match alts with
  | [] -> invalid_arg err_empty_list
  | [a] -> quote ppf a
  | [a; b] -> Fmt.pf ppf "either@ %a@ or@ %a" quote a quote b
  | alts ->
      let rev_alts = List.rev alts in
      Fmt.pf ppf "one@ of@ %a@ or@ %a"
        Fmt.(list ~sep:comma quote) (List.rev (List.tl rev_alts))
        quote (List.hd rev_alts)

let alts_str ?quoted alts = (* Exposed in the API do not change *)
  Fmt.str "@[%a@]" (_alts_str ~styled:false ?quoted) alts

let pp_alts ppf alts =
  _alts_str ~styled:true ~quoted:true ppf alts

let err_ambiguous ~kind s ~ambs =
  Fmt.str "@[%s %a %a@ and@ could@ be@ %a@]"
    kind Fmt.code_or_quote s Fmt.ereason "ambiguous" pp_alts ambs

let err_unknown ?(dom = []) ?(hints = []) ~kind v =
  let hints ppf () = match hints, dom with
  | [], [] -> ()
  | [], dom -> Fmt.pf ppf ". Must@ be@ %a" pp_alts dom
  | hints, _ -> Fmt.pf ppf ". Did@ you@ mean@ %a?" pp_alts hints
  in
  Fmt.str "@[%a %s@ %a%a@]" Fmt.unknown () kind Fmt.code_or_quote v hints ()
end
module Cmdliner_manpage : sig
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

(** Manpages.

    See {!Cmdliner.Manpage}. *)

type section_name = string

type block =
  [ `S of section_name | `P of string | `Pre of string | `I of string * string
  | `Noblank | `Blocks of block list ]

val escape : string -> string
(** [escape s] escapes [s] from the doc language. *)

type title = string * int * string * string * string

type t = title * block list

type xref =
  [ `Main | `Cmd of string | `Tool of string | `Page of string * int ]

(** {1 Standard section names} *)

val s_name : section_name
val s_synopsis : section_name
val s_description : section_name
val s_commands : section_name
val s_arguments : section_name
val s_options : section_name
val s_common_options : section_name
val s_exit_status : section_name
val s_environment : section_name
val s_files : section_name
val s_bugs : section_name
val s_examples : section_name
val s_authors : section_name
val s_see_also : section_name
val s_none : section_name

(** {1 Section maps}

    Used for handling the merging of metadata doc strings. *)

type smap
val smap_of_blocks : block list -> smap
val smap_to_blocks : smap -> block list
val smap_has_section : smap -> sec:section_name -> bool
val smap_append_block : smap -> sec:section_name -> block -> smap
(** [smap_append_block smap sec b] appends [b] at the end of section
    [sec] creating it at the right place if needed. *)

(** {1 Content boilerplate} *)

val s_exit_status_intro : block
val s_environment_intro : block

(** {1 Output} *)

type subst = string -> string option
(** The type for variable substitution functions. *)

type format = [ `Auto | `Pager | `Plain | `Groff ]
val print :
  ?env:(string -> string option) ->
  ?errs:Format.formatter -> ?subst:subst -> format ->
  Format.formatter -> t -> unit

(** {1 Printers and escapes used by Cmdliner module} *)

val subst_vars :
  errs:Format.formatter -> subst:subst -> Buffer.t -> string -> string
(** [subst b ~subst s], using [b], substitutes in [s] variables of the form
    "$(doc)" by their [subst] definition. This leaves escapes and markup
    directives $(markup,) intact.

    @raise Invalid_argument in case of illegal syntax. *)

val doc_to_plain :
  errs:Format.formatter -> subst:subst -> Buffer.t -> string -> string
(** [doc_to_plain b ~subst s] using [b], substitutes in [s] variables by
    their [subst] definition and renders cmdliner directives to plain
    text.

    Raises Invalid_argument in case of illegal syntax. *)

val doc_to_styled :
  ?buffer:Buffer.t -> errs:Format.formatter -> subst:subst -> string -> string
(** [doc_to_styled] is like {!doc_to_plain} but uses ANSI escapes. *)
end = struct
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

(* Manpages *)

type section_name = string

type block =
  [ `S of section_name | `P of string | `Pre of string | `I of string * string
  | `Noblank | `Blocks of block list ]

type title = string * int * string * string * string

type t = title * block list

type xref =
  [ `Main | `Cmd of string | `Tool of string | `Page of string * int ]

(* Standard sections *)

let s_name = "NAME"
let s_synopsis = "SYNOPSIS"
let s_description = "DESCRIPTION"
let s_commands = "COMMANDS"
let s_arguments = "ARGUMENTS"
let s_options = "OPTIONS"
let s_common_options = "COMMON OPTIONS"
let s_exit_status = "EXIT STATUS"
let s_exit_status_intro = `P "$(cmd) exits with:"

let s_environment = "ENVIRONMENT"
let s_environment_intro =
  `P "These environment variables affect the execution of $(cmd):"

let s_files = "FILES"
let s_examples = "EXAMPLES"
let s_bugs = "BUGS"
let s_authors = "AUTHORS"
let s_see_also = "SEE ALSO"
let s_none = "cmdliner-none"

(* Section order *)

let s_created = ""
let order =
  [| s_name; s_synopsis; s_description; s_created; s_commands;
     s_arguments; s_options; s_common_options; s_exit_status;
     s_environment; s_files; s_examples; s_bugs; s_authors; s_see_also;
     s_none; |]

let order_synopsis = 1
let order_created = 3

let section_of_order i = order.(i)
let section_to_order ~on_unknown s =
  let max = Array.length order - 1 in
  let rec loop i = match i > max with
  | true -> on_unknown
  | false -> if order.(i) = s then i else loop (i + 1)
  in
  loop 0

(* Section maps

   Section maps, maps section names to their section order and reversed
   content blocks (content is not reversed in `Block blocks). The sections
   are listed in reversed order. Unknown sections get the order of the last
   known section. *)

type smap = (string * (int * block list)) list

let smap_of_blocks bs = (* N.B. this flattens `Blocks, not t.r. *)
  let rec loop s s_o rbs smap = function
  | [] -> s, s_o, rbs, smap
  | `S new_sec :: bs ->
      let new_o = section_to_order ~on_unknown:s_o new_sec in
      loop new_sec new_o [] ((s, (s_o, rbs)):: smap) bs
  | `Blocks blist :: bs ->
      let s, s_o, rbs, rmap = loop s s_o rbs smap blist (* not t.r. *) in
      loop s s_o rbs rmap bs
  | (`P _ | `Pre _ | `I _ | `Noblank as c) :: bs ->
      loop s s_o (c :: rbs) smap bs
  in
  let first, (bs : block list) = match bs with
  | `S s :: bs -> s, bs
  | `Blocks (`S s :: blist) :: bs -> s, (`Blocks blist) :: bs
  | _ -> "", bs
  in
  let first_o = section_to_order ~on_unknown:order_synopsis first in
  let s, s_o, rc, smap = loop first first_o [] [] bs in
  (s, (s_o, rc)) :: smap

let smap_to_blocks smap = (* N.B. this leaves `Blocks content untouched. *)
  let rec loop acc smap s = function
  | b :: rbs -> loop (b :: acc) smap s rbs
  | [] ->
      let acc = if s = "" then acc else `S s :: acc in
      match smap with
      | [] -> acc
      | (_, (_, [])) :: smap -> loop acc smap "" [] (* skip empty section *)
      | (s, (_, rbs)) :: smap ->
          if s = s_none
          then loop acc smap "" [] (* skip *)
          else loop acc smap s rbs
  in
  loop [] smap "" []

let smap_has_section smap ~sec = List.exists (fun (s, _) -> sec = s) smap
let smap_append_block smap ~sec b =
  let o = section_to_order ~on_unknown:order_created sec in
  let try_insert =
    let rec loop max_lt_o left = function
    | (s', (o, rbs)) :: right when s' = sec ->
        Ok (List.rev_append ((sec, (o, b :: rbs)) :: left) right)
    | (_, (o', _) as s) :: right ->
        let max_lt_o = if o' < o then max o' max_lt_o else max_lt_o in
        loop max_lt_o (s :: left) right
    | [] ->
        if max_lt_o <> -1 then Error max_lt_o else
        Ok (List.rev ((sec, (o, [b])) :: left))
    in
    loop (-1) [] smap
  in
  match try_insert with
  | Ok smap -> smap
  | Error insert_before ->
      let rec loop left = function
      | (s', (o', _)) :: _ as right when o' = insert_before ->
          List.rev_append ((sec, (o, [b])) :: left) right
      | s :: ss -> loop (s :: left) ss
      | [] -> assert false
      in
      loop [] smap

(* Formatting tools *)

let strf = Printf.sprintf
module Fmt = Cmdliner_base.Fmt

(* Cmdliner markup handling *)

let err e fmt = Fmt.pf e ("cmdliner error: " ^^ fmt ^^ "@.")
let err_unescaped ~errs c s = err errs "unescaped %C in %S" c s
let err_malformed ~errs s = err errs "Malformed $() in %S" s
let err_unclosed ~errs s = err errs "Unclosed $() in %S" s
let err_undef ~errs id s = err errs "Undefined variable $(%s) in %S" id s
let err_illegal_esc ~errs c s = err errs "Illegal escape char %C in %S" c s
let err_markup ~errs dir s =
  err errs "Unknown cmdliner markup $(%c,) in %S" dir s

let is_markup_dir = function 'i' | 'b' -> true | _ -> false
let is_markup_esc = function '$' | '\\' | '(' | ')' -> true | _ -> false
let markup_need_esc = function '\\' | '$' -> true | _ -> false
let markup_text_need_esc = function '\\' | '$' | ')' -> true | _ -> false

let escape s = (* escapes [s] from doc language. *)
  let max_i = String.length s - 1 in
  let rec escaped_len i l =
    if i > max_i then l else
    if markup_text_need_esc s.[i] then escaped_len (i + 1) (l + 2) else
    escaped_len (i + 1) (l + 1)
  in
  let escaped_len = escaped_len 0 0 in
  if escaped_len = String.length s then s else
  let b = Bytes.create escaped_len in
  let rec loop i k =
    if i > max_i then Bytes.unsafe_to_string b else
    let c = String.unsafe_get s i in
    if not (markup_text_need_esc c)
    then (Bytes.unsafe_set b k c; loop (i + 1) (k + 1))
    else (Bytes.unsafe_set b k '\\'; Bytes.unsafe_set b (k + 1) c;
          loop (i + 1) (k + 2))
  in
  loop 0 0

let subst_vars ~errs ~subst b s =
  let max_i = String.length s - 1 in
  let flush start stop = match start > max_i with
  | true -> ()
  | false -> Buffer.add_substring b s start (stop - start + 1)
  in
  let skip_escape k start i =
    if i > max_i then err_unescaped ~errs '\\' s else k start (i + 1)
  in
  let rec skip_markup k start i =
    if i > max_i then (err_unclosed ~errs s; k start i) else
    match s.[i] with
    | '\\' -> skip_escape (skip_markup k) start (i + 1)
    | ')' -> k start (i + 1)
    | c -> skip_markup k start (i + 1)
  in
  let rec add_subst start i =
    if i > max_i then (err_unclosed ~errs s; loop start i) else
    if s.[i] <> ')' then add_subst start (i + 1) else
    let id = String.sub s start (i - start) in
    let next = i + 1 in
    begin match subst id with
    | None -> err_undef ~errs id s; Buffer.add_string b "undefined";
    | Some v -> Buffer.add_string b v
    end;
    loop next next
  and loop start i =
    if i > max_i then flush start max_i else
    let next = i + 1 in
    match s.[i] with
    | '\\' -> skip_escape loop start next
    | '$' ->
        if next > max_i then err_unescaped ~errs '$' s else
        begin match s.[next] with
        | '(' ->
            let min = next + 2 in
            if min > max_i then (err_unclosed ~errs s; loop start next) else
            begin match s.[min] with
            | ',' -> skip_markup loop start (min + 1)
            | _ ->
                let start_id = next + 1 in
                flush start (i - 1); add_subst start_id start_id
            end
        | _ -> err_unescaped ~errs '$' s; loop start next
        end;
    | c -> loop start next
  in
  (Buffer.clear b; loop 0 0; Buffer.contents b)

let add_markup_esc ~errs k b s start next target_need_escape target_escape =
  let max_i = String.length s - 1 in
  if next > max_i then err_unescaped ~errs '\\' s else
  match s.[next] with
  | c when not (is_markup_esc s.[next]) ->
      err_illegal_esc ~errs c s;
      k (next + 1) (next + 1)
  | c ->
      (if target_need_escape c then target_escape b c else Buffer.add_char b c);
      k (next + 1) (next + 1)

let add_markup_text ~errs k b s start target_need_escape target_escape =
  let max_i = String.length s - 1 in
  let flush start stop = match start > max_i with
  | true -> ()
  | false -> Buffer.add_substring b s start (stop - start + 1)
  in
  let rec loop start i =
    if i > max_i then (err_unclosed ~errs s; flush start max_i) else
    let next = i + 1 in
    match s.[i] with
    | '\\' -> (* unescape *)
        flush start (i - 1);
        add_markup_esc ~errs loop b s start next
          target_need_escape target_escape
    | ')' -> flush start (i - 1); k next next
    | c when markup_text_need_esc c ->
        err_unescaped ~errs c s; flush start (i - 1); loop next next
    | c when target_need_escape c ->
        flush start (i - 1); target_escape b c; loop next next
    | c -> loop start next
  in
  loop start start

(* Plain text output *)

let markup_to_plain ~styled ~errs b s =
  let max_i = String.length s - 1 in
  let flush start stop = match start > max_i with
  | true -> ()
  | false -> Buffer.add_substring b s start (stop - start + 1)
  in
  let need_escape _ = false in
  let escape _ _ = assert false in
  let rec end_text start i = Buffer.add_string b "\x1B[m"; loop start i
  and loop start i =
    if i > max_i then flush start max_i else
    let next = i + 1 in
    match s.[i] with
    | '\\' ->
        flush start (i - 1);
        add_markup_esc ~errs loop b s start next need_escape escape
    | '$' ->
        if next > max_i then err_unescaped ~errs '$' s else
        begin match s.[next] with
        | '(' ->
            let min = next + 2 in
            if min > max_i then (err_unclosed ~errs s; loop start next) else
            begin match s.[min] with
            | ',' ->
                let markup = s.[min - 1] in
                let start_data = min + 1 in
                if not (is_markup_dir markup)
                then (err_markup ~errs markup s; loop start next) else begin
                  flush start (i - 1);
                  if not styled then
                    add_markup_text ~errs loop b s start_data need_escape escape
                  else
                  begin
                    begin match markup with
                    | 'i' -> Buffer.add_string b "\x1B[04m";
                    | 'b' -> Buffer.add_string b "\x1B[01m"
                    | _ -> assert false
                    end;
                    add_markup_text ~errs end_text b s start_data
                      need_escape escape
                  end
                end
            | _ ->
                err_malformed ~errs s; loop start next
            end
        | _ -> err_unescaped ~errs '$' s; loop start next
        end
    | c when markup_need_esc c ->
        err_unescaped ~errs c s; flush start (i - 1); loop next next
    | c -> loop start next
  in
  (Buffer.clear b; loop 0 0; Buffer.contents b)

let doc_to_plain ~errs ~subst b s =
  markup_to_plain ~styled:false ~errs b (subst_vars ~errs ~subst b s)

let doc_to_styled ?buffer:(b = Buffer.create 255) ~errs ~subst s =
  let styled = Cmdliner_base.Fmt.styler () = Cmdliner_base.Fmt.Ansi in
  markup_to_plain ~styled ~errs b (subst_vars ~errs ~subst b s)



let p_indent = 7                                  (* paragraph indentation. *)
let l_indent = 4                                      (* label indentation. *)

let pp_plain_blocks ~errs subst ppf ts =
  let b = Buffer.create 1024 in
  let markup t = doc_to_plain ~errs b ~subst t in
  let pp_tokens ppf t = Fmt.tokens ~spaces:true ppf t in
  let rec blank_line = function
  | `Noblank :: ts -> loop ts
  | ts -> Format.pp_print_cut ppf (); loop ts
  and loop = function
  | [] -> ()
  | t :: ts ->
      match t with
      | `Noblank -> loop ts
      | `Blocks bs -> loop (bs @ ts)
      | `P s ->
          Fmt.pf ppf "%a@[%a@]@," Fmt.indent p_indent pp_tokens (markup s);
          blank_line ts
      | `S s -> Fmt.pf ppf "@[%a@]@," pp_tokens (markup s); loop ts
      | `Pre s ->
          Fmt.pf ppf "%a@[%a@]@," Fmt.indent p_indent Fmt.lines (markup s);
          blank_line ts
      | `I (label, s) ->
          let label = markup label and s = markup s in
          Fmt.pf ppf "@[%a@[%a@]" Fmt.indent p_indent pp_tokens label;
          begin match s with
          | "" -> Fmt.pf ppf "@]@,"
          | s ->
              let ll = String.length label in
              if ll < l_indent
              then (Fmt.pf ppf "%a@[%a@]@]@,"
                      Fmt.indent (l_indent - ll) pp_tokens s)
              else (Fmt.pf ppf "@\n%a@[%a@]@]@,"
                      Fmt.indent (p_indent + l_indent) pp_tokens s)
          end;
          blank_line ts
  in
  loop ts

let pp_plain_page ~errs subst ppf (_, text) =
  Fmt.pf ppf "@[<v>%a@]" (pp_plain_blocks ~errs subst) text

(* Groff output *)

let markup_to_groff ~errs b s =
  let max_i = String.length s - 1 in
  let flush start stop = match start > max_i with
  | true -> ()
  | false -> Buffer.add_substring b s start (stop - start + 1)
  in
  let need_escape = function '.' | '\'' | '-' | '\\' -> true | _ -> false in
  let escape b c = Printf.bprintf b "\\N'%d'" (Char.code c) in
  let rec end_text start i = Buffer.add_string b "\\fR"; loop start i
  and loop start i =
    if i > max_i then flush start max_i else
    let next = i + 1 in
    match s.[i] with
    | '\\' ->
        flush start (i - 1);
        add_markup_esc ~errs loop b s start next need_escape escape
    | '$' ->
        if next > max_i then err_unescaped ~errs '$' s else
        begin match s.[next] with
        | '(' ->
            let min = next + 2 in
            if min > max_i then (err_unclosed ~errs s; loop start next) else
            begin match s.[min] with
            | ','  ->
                let start_data = min + 1 in
                flush start (i - 1);
                begin match s.[min - 1] with
                | 'i' -> Buffer.add_string b "\\fI"
                | 'b' -> Buffer.add_string b "\\fB"
                | markup -> err_markup ~errs markup s
                end;
                add_markup_text ~errs end_text b s start_data need_escape escape
            | _ -> err_malformed ~errs s; loop start next
            end
        | _ -> err_unescaped ~errs '$' s; flush start (i - 1); loop next next
        end
    | c when markup_need_esc c ->
        err_unescaped ~errs c s; flush start (i - 1); loop next next
    | c when need_escape c ->
        flush start (i - 1); escape b c; loop next next
    | c -> loop start next
  in
  (Buffer.clear b; loop 0 0; Buffer.contents b)

let doc_to_groff ~errs ~subst b s =
  markup_to_groff ~errs b (subst_vars ~errs ~subst b s)

let pp_groff_blocks ~errs subst ppf text =
  let buf = Buffer.create 1024 in
  let markup t = doc_to_groff ~errs ~subst buf t in
  let pp_tokens ppf t = Fmt.tokens ~spaces:false ppf t in
  let rec pp_block = function
  | `Blocks bs -> List.iter pp_block bs (* not T.R. *)
  | `P s -> Fmt.pf ppf "@\n.P@\n%a" pp_tokens (markup s)
  | `Pre s -> Fmt.pf ppf "@\n.P@\n.nf@\n%a@\n.fi" Fmt.lines (markup s)
  | `S s -> Fmt.pf ppf "@\n.SH %a" pp_tokens (markup s)
  | `Noblank -> Fmt.pf ppf "@\n.sp -1"
  | `I (l, s) ->
      Fmt.pf ppf "@\n.TP 4@\n%a@\n%a" pp_tokens (markup l) pp_tokens (markup s)
  in
  List.iter pp_block text

let pp_groff_page ~errs subst ppf ((n, s, a1, a2, a3), t) =
  Fmt.pf ppf
         ".\\\" Pipe this output to groff -m man -K utf8 -T utf8 | less -R@\n\
          .\\\"@\n\
          .mso an.tmac@\n\
          .TH \"%s\" %d \"%s\" \"%s\" \"%s\"@\n\
          .\\\" Disable hyphenation and ragged-right@\n\
          .nh@\n\
          .ad l\
          %a@?"
    n s a1 a2 a3 (pp_groff_blocks ~errs subst) t

(* Printing to a pager *)

let pp_to_temp_file pp_v v =
  try
    let exec = Filename.basename Sys.argv.(0) in
    let file, oc = Filename.open_temp_file exec "out" in
    let ppf = Format.formatter_of_out_channel oc in
    pp_v ppf v; Format.pp_print_flush ppf (); close_out oc;
    at_exit (fun () -> try Sys.remove file with Sys_error e -> ());
    Some file
  with Sys_error _ -> None

let tmp_file_for_pager () =
  try
    let exec = Filename.basename Sys.argv.(0) in
    let file = Filename.temp_file exec "tty" in
    at_exit (fun () -> try Sys.remove file with Sys_error e -> ());
    Some file
  with Sys_error _ -> None

let find_cmd cmds =
  let find_win32 (cmd, _args) =
    (* `where` does not support full path lookups *)
    if String.equal (Filename.basename cmd) cmd
    then (Sys.command (strf "where %s 1> NUL 2> NUL" cmd) = 0)
    else Sys.file_exists cmd
  in
  let find_posix (cmd, _args) =
    Sys.command (strf "command -v %s 1>/dev/null 2>/dev/null" cmd) = 0
  in
  let find = if Sys.win32 then find_win32 else find_posix in
  try Some (List.find find cmds) with Not_found -> None

let getenv_empty_is_none env var = match env var with
| None | Some "" -> None | Some _ as v -> v

let find_pager env =
  let cmds = ["less", ""; "more", ""] in
  let cmds = match getenv_empty_is_none env "PAGER" with
  | Some pager -> (pager, "") :: cmds | None -> cmds
  in
  let cmds = match getenv_empty_is_none env "MANPAGER" with
  | Some manpager -> (manpager, "") :: cmds | None -> cmds
  in
  find_cmd cmds

let pp_to_pager env print ppf v =
  let run cmd = Sys.command cmd = 0 in
  let plain_pager pager = match pp_to_temp_file (print `Plain) v with
  | None -> false
  | Some f -> run (strf "%s < %s" pager f)
  in
  let groffed_pager pager =
    let groffer =
      let cmds =
        ["mandoc", " -m man -K utf-8 -T utf8";
         "groff", " -m man -K utf8 -T utf8";
         "nroff", ""]
      in
      find_cmd cmds
    in
    match groffer with
    | None -> false
    | Some (groffer, opts) ->
        let groffer = groffer ^ opts in
        match pp_to_temp_file (print `Groff) v with
        | None -> false
        | Some f ->
            (* This used to go through a pipe on non-Windows
               platforms, but this would hide errors with the groffer
               and inhibit the graceful degradation to plain text
               since POSIX shells do not "pipefail" *)
            match tmp_file_for_pager () with
            | None -> false
            | Some tmp ->
                run (strf "%s <%s >%s && %s <%s" groffer f tmp pager tmp)
  in
  match find_pager env with
  | None -> print `Plain ppf v
  | Some (pager, opts) ->
      let pager =
        let set_less_env = match env "LESS" with
        | None -> if Sys.win32 then "set LESS=FRX && " else "LESS=FRX "
        | Some _ -> "" (* Sys.command will pass it *)
        in
        set_less_env ^ pager ^ opts
      in
      if groffed_pager pager then () else
      if plain_pager pager then () else
      print `Plain ppf v

(* Output *)

type subst = string -> string option

type format = [ `Auto | `Pager | `Plain | `Groff ]

let rec print
    ?(env = Sys.getenv_opt)  ?(errs = Format.err_formatter)
    ?(subst = fun x -> None) fmt ppf page
  =
  match fmt with
  | `Pager -> pp_to_pager env (print ~env ~errs ~subst) ppf page
  | `Plain -> pp_plain_page ~errs subst ppf page
  | `Groff -> pp_groff_page ~errs subst ppf page
  | `Auto ->
      let fmt =
        match env "TERM" with
        | None when Sys.win32 -> `Pager
        | None -> `Plain
        | Some "dumb" -> `Plain
        | _ -> `Pager
      in
      print ~env ~errs ~subst fmt ppf page
end
module Cmdliner_def : sig
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

(** Core definitions. *)

(** Exit codes. *)
module Exit : sig
  type code = int
  val ok : code
  val some_error : code
  val cli_error : code
  val internal_error : code

  type info
  val info : ?docs:string -> ?doc:string -> ?max:code -> code -> info
  val info_code : info -> code
  val info_codes : info -> code * code
  val info_doc : info -> string
  val info_docs : info  -> string
  val info_order : info -> info -> int
  val defaults : info list
  val doclang_subst :
    subst:Cmdliner_manpage.subst -> info -> Cmdliner_manpage.subst
  (** [doclang_subst ~subst info] adds the substitution of [info] to
      [subst]. *)
end

(** Environment variables. *)
module Env : sig
  type var = string
  type info
  val info : ?deprecated:string -> ?docs:string -> ?doc:string -> var -> info
  val info_var : info -> string
  val info_doc : info -> string
  val info_docs : info -> string
  val info_deprecated : info -> string option
  val doclang_subst :
    subst:Cmdliner_manpage.subst -> info -> Cmdliner_manpage.subst
  (** [doclang_subst ~subst info] adds the substitution of [info] to
      [subst]. *)

  val styled_deprecated :
    errs:Format.formatter -> subst:Cmdliner_manpage.subst -> info -> string

  val styled_doc :
    errs:Format.formatter -> subst:Cmdliner_manpage.subst -> info -> string

  module Set : Set.S with type elt = info
end

(** Argument information. *)
module Arg_info : sig
  type absence =
  | Err  (** an error is reported. *)
  | Val of string Lazy.t (** if <> "", takes the given default value. *)
  | Doc of string
    (** if <> "", a doc string interpreted in the doc markup language. *)
  (** The type for what happens if the argument is absent from the cli. *)

  type opt_kind =
  | Flag (** without value, just a flag. *)
  | Opt  (** with required value. *)
  | Opt_vopt of string (** with optional value, takes given default. *)
  (** The type for optional argument kinds. *)

  type pos_kind
  val pos : rev:bool -> start:int -> len:int option -> pos_kind
  val pos_rev : pos_kind -> bool
  val pos_start : pos_kind -> int
  val pos_len : pos_kind -> int option

  type t
  val make :
    ?deprecated:string -> ?absent:string -> ?docs:string ->
    ?doc_envs:Env.info list -> ?docv:string -> ?doc:string ->
    ?env:Env.info -> string list -> t

  val id : t -> int
  val deprecated : t -> string option
  val absent : t -> absence
  val env : t -> Env.info option
  val doc : t -> string
  val docv : t -> string
  val doc_envs : t -> Env.info list
  val docs : t -> string
  val opt_names : t -> string list (* has dashes *)
  val opt_name_sample : t -> string (* warning must be an opt arg *)
  val opt_kind : t -> opt_kind
  val pos_kind : t -> pos_kind

  val make_req : t -> t
  val make_all_opts : t -> t
  val make_opt : docv:string -> absent:absence -> kind:opt_kind -> t -> t
  val make_opt_all : docv:string -> absent:absence -> kind:opt_kind -> t -> t
  val make_pos : docv:string -> pos:pos_kind -> t -> t
  val make_pos_abs : docv:string -> absent:absence -> pos:pos_kind -> t -> t

  val is_opt : t -> bool
  val is_pos : t -> bool
  val is_req : t -> bool

  val pos_cli_order : t -> t -> int
  val rev_pos_cli_order : t -> t -> int

  val compare : t -> t -> int

  val doclang_subst :
    subst:Cmdliner_manpage.subst -> t -> Cmdliner_manpage.subst
  (** [doclang_subst ~subst info] adds the substitution of [info] to
      [subst]. Note this includes the substitutions for [env] if present. *)

  val styled_deprecated :
    errs:Format.formatter -> subst:Cmdliner_manpage.subst -> t -> string

  val styled_doc :
    errs:Format.formatter -> subst:Cmdliner_manpage.subst -> t -> string

  type 'a conv
  type e_conv = Conv : 'a conv -> e_conv

  module Set : sig
    type arg := t
    type t
    val is_empty : t -> bool
    val empty : t
    val add : arg -> e_conv -> t -> t
    val choose : t -> arg * e_conv
    val partition : (arg -> e_conv -> bool) -> t -> t * t
    val filter : (arg -> e_conv -> bool) -> t -> t
    val iter : (arg -> e_conv -> unit) -> t -> unit
    val singleton : arg -> e_conv -> t
    val fold : (arg -> e_conv -> 'acc -> 'acc) -> t -> 'acc -> 'acc
    val elements : t -> arg list
    val union : t -> t -> t
    val find_opt : arg -> t -> e_conv option
  end
end

(** Command information. *)
module Cmd_info : sig
  type t
  val make :
    ?deprecated:string -> ?man_xrefs:Cmdliner_manpage.xref list ->
    ?man:Cmdliner_manpage.block list -> ?envs:Env.info list ->
    ?exits:Exit.info list -> ?sdocs:string -> ?docs:string -> ?doc:string ->
    ?version:string -> string -> t

  val name : t -> string
  val version : t -> string option
  val deprecated : t -> string option
  val doc : t -> string
  val docs : t -> string
  val stdopts_docs : t -> string
  val exits : t -> Exit.info list
  val envs : t -> Env.info list
  val man : t -> Cmdliner_manpage.block list
  val man_xrefs : t -> Cmdliner_manpage.xref list
  val args : t -> Arg_info.Set.t
  val has_args : t -> bool
  val children : t -> t list
  val add_args : t -> Arg_info.Set.t -> t
  val with_children : t -> args:Arg_info.Set.t option -> children:t list -> t
  val styled_deprecated :
    errs:Format.formatter -> subst:Cmdliner_manpage.subst -> t -> string

  val styled_doc :
    errs:Format.formatter -> subst:Cmdliner_manpage.subst -> t -> string
end

(** Untyped command line parses. *)
module Cline : sig
  type arg =
  | O of (int * string * (string option)) list (* (pos, name, value) of opt. *)
  | P of string list (** *)
  (** Unconverted argument data as found on the command line. *)

  type t (* command line, maps arg_infos to arg value. *)
  val empty : t
  val add : Arg_info.t -> arg -> t -> t
  val get_arg : t -> Arg_info.t -> arg
  val get_opt_arg : t -> Arg_info.t -> (int * string * (string option)) list
  val get_pos_arg : t -> Arg_info.t -> string list
  val actual_args : t -> Arg_info.t -> string list
  (** Actual command line arguments from the command line *)

  val fold : (Arg_info.t -> arg -> 'b -> 'b) -> t -> 'b -> 'b

  (** {1:deprecations Deprecations} *)

  type deprecated
  (** The type for deprecation invocations. This include both environment
      variable deprecations and argument deprecations. *)

  val deprecated :
    env:(string -> string option) -> t -> deprecated list
  (** [deprecated ~env cli] are the deprecated invocations that occur
      when parsing [cli]. *)

  val pp_deprecated :
    subst:Cmdliner_manpage.subst -> deprecated Cmdliner_base.Fmt.t
    (** [pp_deprecated] formats deprecations. *)
end

(** Evaluation. *)
module Eval : sig
  type t
  val make :
    ancestors:Cmd_info.t list -> cmd:Cmd_info.t -> subcmds:Cmd_info.t list ->
    env:(string -> string option) -> err_ppf:Format.formatter -> t

  val cmd : t -> Cmd_info.t
  val main : t -> Cmd_info.t
  val ancestors : t -> Cmd_info.t list (* root is last *)
  val subcmds : t -> Cmd_info.t list
  val env_var : t -> string -> string option
  val err_ppf : t -> Format.formatter
  val with_cmd : t -> Cmd_info.t -> t
  val doclang_subst : t -> Cmdliner_manpage.subst
end

(** Terms, typed cli fragment definitions. *)
module Term : sig
  type escape =
  [ `Error of bool * string
  | `Help of Cmdliner_manpage.format * string option ]

  type 'a parser =
    Eval.t -> Cline.t -> ('a, [ `Parse of string | escape ]) result

  type 'a t = Arg_info.Set.t * 'a parser
end

(** Completion strategies *)
module Arg_completion : sig
  type 'a directive =
  | Message of string | String of string * string | Value of 'a * string
  | Files | Dirs | Restart | Raw of string

  val value : ?doc:string -> 'a -> 'a directive
  val string : ?doc:string -> string -> 'a directive
  val files : 'a directive
  val dirs : 'a directive
  val restart : 'a directive
  val message : string -> 'a directive
  val raw : string -> 'a directive

  type ('ctx, 'a) func =
    'ctx option -> token:string -> ('a directive list, string) result

  type 'a complete =
  | Complete : 'ctx Term.t option * ('ctx, 'a) func -> 'a complete

  type 'a t

  val make : ?context:'ctx Term.t -> ('ctx, 'a) func -> 'a t
  val complete : 'a t -> 'a complete
  val complete_none : 'a t
  val complete_files : 'a t
  val complete_dirs : 'a t
  val complete_paths : 'a t
  val complete_restart : 'a t
end

(** Textual OCaml value converters *)
module Arg_conv : sig
  type 'a parser = string -> ('a, string) result
  type 'a fmt = 'a Cmdliner_base.Fmt.t
  type 'a t = 'a Arg_info.conv
  val make :
    ?completion:'a Arg_completion.t -> docv:string -> parser:'a parser ->
    pp:'a fmt -> unit -> 'a t

  val of_conv :
    ?completion:'a Arg_completion.t -> ?docv:string ->
    ?parser:'a parser -> ?pp:'a fmt -> 'a t -> 'a t

  val docv : 'a t -> string
  val parser : 'a t -> 'a parser
  val pp : 'a t -> 'a fmt
  val completion : 'a t -> 'a Arg_completion.t

  val some : ?none:string -> 'a t -> 'a option t
  val some' : ?none:'a -> 'a t -> 'a option t

  val none : 'a t
end

(** Complete instruction. *)
module Complete : sig
  type kind =
  | Opt_value of Arg_info.t
  | Opt_name_or_pos_value of Arg_info.t
  | Opt_name

  type t
  val make : ?after_dashdash:bool -> ?subcmds:bool -> token:string -> kind -> t
  val token : t -> string
  val after_dashdash : t -> bool
  val subcmds : t -> bool
  val kind : t -> kind
  val add_subcmds : t -> t
end
end = struct
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

let strf = Printf.sprintf

(* Exit codes *)

module Exit = struct
  type code = int

  let ok = 0
  let some_error = 123
  let cli_error = 124
  let internal_error = 125

  type info =
    { codes : code * code; (* min, max *)
      doc : string; (* help. *)
      docs : string; } (* title of help section where listed. *)

  let info
      ?(docs = Cmdliner_manpage.s_exit_status) ?(doc = "undocumented") ?max min
    =
    let max = match max with None -> min | Some max -> max in
    { codes = (min, max); doc; docs }

  let info_codes i = i.codes
  let info_code i = fst i.codes
  let info_doc i = i.doc
  let info_docs i = i.docs
  let info_order i0 i1 = compare i0.codes i1.codes
  let defaults =
    [ info ok ~doc:"on success.";
      info some_error
        ~doc:"on indiscriminate errors reported on standard error.";
      info cli_error ~doc:"on command line parsing errors.";
      info internal_error ~doc:"on unexpected internal errors (bugs)."; ]

  let doclang_subst ~subst i = function
  | "status" -> Some (string_of_int (info_code i))
  | "status_max" -> Some (string_of_int (snd i.codes))
  | id -> subst id
end

(* Environment variables *)

module Env = struct
  type var = string
  type info = (* information about an environment variable. *)
    { id : int; (* unique id for the env var. *)
      deprecated : string option;
      var : string; (* the variable. *)
      doc : string; (* help. *)
      docs : string; } (* title of help section where listed. *)

  let info
      ?deprecated
      ?(docs = Cmdliner_manpage.s_environment) ?(doc = "See option $(opt).") var
    =
    { id = Cmdliner_base.uid (); deprecated; var; doc; docs }

  let info_deprecated i = i.deprecated
  let info_var i = i.var
  let info_doc i = i.doc
  let info_docs i = i.docs
  let info_compare i0 i1 = Int.compare i0.id i1.id

  let doclang_subst ~subst i = function
  | "env" -> Some (strf "$(b,%s)" (Cmdliner_manpage.escape i.var))
  | id -> subst id

  let styled_deprecated ~errs ~subst i = match i.deprecated with
  | None -> "" | Some msg -> Cmdliner_manpage.doc_to_styled ~errs ~subst msg

  let styled_doc ~errs ~subst i =
    Cmdliner_manpage.doc_to_styled ~errs ~subst i.doc

  module Set = Set.Make (struct type t = info let compare = info_compare end)
end

(* Argument information *)

module Arg_info = struct
  type absence = Err | Val of string Lazy.t | Doc of string
  type opt_kind = Flag | Opt | Opt_vopt of string
  type pos_kind = (* information about a positional argument. *)
    { pos_rev : bool; (* if [true] positions are counted from the end. *)
      pos_start : int; (* start positional argument. *)
      pos_len : int option } (* number of arguments or [None] if unbounded. *)

  let pos ~rev:pos_rev ~start:pos_start ~len:pos_len =
    { pos_rev; pos_start; pos_len}

  let pos_rev p = p.pos_rev
  let pos_start p = p.pos_start
  let pos_len p = p.pos_len
  let dumb_pos = pos ~rev:false ~start:(-1) ~len:None

  type t = (* information about a command line argument. *)
    { id : int; (* unique id for the argument. *)
      deprecated : string option; (* deprecation message *)
      absent : absence; (* behaviour if absent. *)
      env : Env.info option; (* environment variable for default value. *)
      doc : string; (* help. *)
      docv : string; (* variable name for the argument in help. *)
      doc_envs : Env.info list; (* environment that needs to be added to docs *)
      docs : string; (* title of help section where listed. *)
      pos : pos_kind; (* positional arg kind. *)
      opt_kind : opt_kind; (* optional arg kind. *)
      opt_names : string list; (* names (for opt args). *)
      opt_all : bool; } (* repeatable (for opt args). *)

  let make
      ?deprecated ?(absent = "") ?docs ?(doc_envs = []) ?(docv = "")
      ?(doc = "") ?env names
    =
    let dash n = if String.length n = 1 then "-" ^ n else "--" ^ n in
    let opt_names = List.map dash names in
    let docs = match docs with
    | Some s -> s
    | None ->
        match names with
        | [] -> Cmdliner_manpage.s_arguments
        | _ -> Cmdliner_manpage.s_options
    in
    { id = Cmdliner_base.uid (); deprecated; absent = Doc absent;
      env; doc; docv; doc_envs; docs; pos = dumb_pos;
      opt_kind = Flag; opt_names; opt_all = false; }

  let id i = i.id
  let deprecated i = i.deprecated
  let absent i = i.absent
  let env i = i.env
  let doc i = i.doc
  let docv i = i.docv
  let doc_envs i = i.doc_envs
  let docs i = i.docs
  let pos_kind i = i.pos
  let opt_kind i = i.opt_kind
  let opt_names i = i.opt_names
  let opt_all i = i.opt_all
  let opt_name_sample i =
    (* First long or short name (in that order) in the list; this
       allows the client to control which name is shown *)
    let rec find = function
    | [] -> List.hd i.opt_names
    | n :: ns -> if (String.length n) > 2 then n else find ns
    in
    find i.opt_names

  let make_req i = { i with absent = Err }
  let make_all_opts i = { i with opt_all = true }
  let make_opt ~docv ~absent ~kind:opt_kind i =
    { i with absent; opt_kind; docv }

  let make_opt_all ~docv ~absent ~kind:opt_kind i =
    { i with absent; opt_kind; opt_all = true; docv  }

  let make_pos ~docv ~pos i = { i with pos; docv }
  let make_pos_abs ~docv ~absent ~pos i = { i with absent; pos; docv }

  let is_opt i = i.opt_names <> []
  let is_pos i = i.opt_names = []
  let is_req i = i.absent = Err

  let pos_cli_order (a0 : t) (a1 : t) = (* best-effort order on the cli. *)
    let c = Bool.compare (a0.pos.pos_rev) (a1.pos.pos_rev) in
    if c <> 0 then c else
    if a0.pos.pos_rev
    then Int.compare a1.pos.pos_start a0.pos.pos_start
    else Int.compare a0.pos.pos_start a1.pos.pos_start

  let rev_pos_cli_order a0 a1 = pos_cli_order a1 a0

  let doclang_subst ~subst (i : t) = function
  | "docv" ->
      let docv = if i.docv = "" then "VAL" else i.docv in
      Some (strf "$(i,%s)" (Cmdliner_manpage.escape docv))
  | "opt" when is_opt i ->
      Some (strf "$(b,%s)" (Cmdliner_manpage.escape (opt_name_sample i)))
  | id ->
      match env i with
      | Some e -> Env.doclang_subst ~subst e id
      | None -> subst id

  let styled_deprecated ~errs ~subst (i : t) = match i.deprecated with
  | None -> "" | Some msg -> Cmdliner_manpage.doc_to_styled ~errs ~subst msg

  let styled_doc ~errs ~subst (i : t) =
    Cmdliner_manpage.doc_to_styled ~errs ~subst i.doc

  let compare (a0 : t) (a1 : t) = Int.compare a0.id a1.id
  module Map = Map.Make (struct type nonrec t = t let compare = compare end)

  (* Due to terms appearing in the completion API, we have an annoying
     recursive type definition which we resolve here. Most of these
     types do not belong this module. *)

  type term_escape =
  [ `Error of bool * string
  | `Help of Cmdliner_manpage.format * string option ]

  type 'a completion_directive =
  | Message of string | String of string * string | Value of 'a * string
  | Files | Dirs | Restart | Raw of string

  type ('ctx, 'a) completion_func =
    'ctx option -> token:string -> ('a completion_directive list, string) result

  type 'a parser = string -> ('a, string) result
  type 'a complete =
  | Complete : 'ctx term option * ('ctx, 'a) completion_func -> 'a complete

  and 'a completion = { complete : 'a complete }

  and 'a conv =
    { docv : string;
      parser : 'a parser;
      pp : 'a Cmdliner_base.Fmt.t;
      completion : 'a completion; }

  and e_conv = Conv : 'a conv -> e_conv
  and arg_set = e_conv Map.t
  and cmd =
    { name : string; (* name of the cmd. *)
      version : string option; (* version (for --version). *)
      deprecated : string option; (* deprecation message *)
      doc : string; (* one line description of cmd. *)
      docs : string; (* title of man section where listed (commands). *)
      sdocs : string; (* standard options, title of section where listed. *)
      exits : Exit.info list; (* exit codes for the cmd. *)
      envs : Env.info list; (* env vars that influence the cmd. *)
      man : Cmdliner_manpage.block list; (* man page text. *)
      man_xrefs : Cmdliner_manpage.xref list; (* man cross-refs. *)
      args : arg_set; (* Command arguments. *)
      has_args : bool; (* [true] if has own parsing term. *)
      children : cmd list; } (* Children, if any. *)

  and eval = (* information about the evaluation context. *)
    { cmd : cmd; (* cmd being evaluated. *)
      ancestors : cmd list; (* ancestors of cmd, root is last. *)
      subcmds : cmd list; (* subcommands (if any) *)
      env : string -> string option; (* environment variable lookup. *)
      err_ppf : Format.formatter (* error formatter *) }

  and cline = cline_arg Map.t
  and cline_arg = (* unconverted argument data as found on the command line. *)
  | O of (int * string * (string option)) list (* (pos, name, value) of opt. *)
  | P of string list

  and 'a term_parser =
    eval -> cline -> ('a, [ `Parse of string | term_escape ]) result

  and 'a term = arg_set * 'a term_parser

  (* Sets of arguments stored as maps to their completion *)

  module Set = struct
    include Map
    type t = e_conv Map.t
    let find_opt k m = try Some (Map.find k m) with Not_found -> None
    let elements m = List.map fst (bindings m)
    let union a b =
      Map.merge (fun k v v' ->
        match v, v' with
        | Some v, _ | _, Some v -> Some v
        | None, None -> assert false) a b
  end
end

(* Commands *)

module Cmd_info = struct
  type t = Arg_info.cmd
  let make
      ?deprecated ?(man_xrefs = [`Main]) ?(man = []) ?(envs = [])
      ?(exits = Exit.defaults) ?(sdocs = Cmdliner_manpage.s_common_options)
      ?(docs = Cmdliner_manpage.s_commands) ?(doc = "") ?version name : t
    =
    { name; version; deprecated; doc; docs; sdocs; exits;
      envs; man; man_xrefs; args = Arg_info.Set.empty;
      has_args = true; children = [] }

  let name (i : t) = i.name
  let version (i : t) = i.version
  let deprecated (i : t) = i.deprecated
  let doc (i : t) = i.doc
  let docs (i : t) = i.docs
  let stdopts_docs (i : t) = i.sdocs
  let exits (i : t) = i.exits
  let envs (i : t) = i.envs
  let man (i : t) = i.man
  let man_xrefs (i : t) = i.man_xrefs
  let args (i : t) = i.args
  let has_args (i : t) = i.has_args
  let children (i : t) = i.children
  let add_args (i : t) args = { i with args = Arg_info.Set.union args i.args }
  let with_children (i : t) ~args ~children =
    let has_args, args = match args with
    | None -> false, i.args
    | Some args -> true, Arg_info.Set.union args i.args
    in
    { i with has_args; args; children }

  let styled_deprecated ~errs ~subst (i : t) = match i.deprecated with
  | None -> "" | Some msg -> Cmdliner_manpage.doc_to_styled ~errs ~subst msg

  let styled_doc ~errs ~subst (i : t) =
    Cmdliner_manpage.doc_to_styled ~errs ~subst i.doc

  let escaped_name (i : t) = Cmdliner_manpage.escape i.name
end

(* Command lines *)

module Cline = struct
  type arg = Arg_info.cline_arg =
  | O of (int * string * (string option)) list
  | P of string list

  type t = Arg_info.cline

  let empty = Arg_info.Map.empty
  let add = Arg_info.Map.add
  let fold = Arg_info.Map.fold
  let get_arg cline a : arg =
    try Arg_info.Map.find a cline with Not_found -> assert false

  let get_opt_arg cline a =
    match get_arg cline a with O l -> l | _ -> assert false

  let get_pos_arg cline a =
    match get_arg cline a with P l -> l | _ -> assert false

  let actual_args cline a = match get_arg cline a with
  | P args -> args
  | O l ->
      let extract_args (_pos, name, value) =
        name :: (match value with None -> [] | Some v -> [v])
      in
      List.concat (List.map extract_args l)

  (* Deprecations *)

  type deprecated = Arg_info.t * arg

  let deprecated ~env cline =
    let add ~env info arg acc =
      let deprecation_invoked = match (arg : arg) with
      | O [] | P [] -> (* nothing on the cli for the argument *)
          begin match Arg_info.env info with
          | None -> false
          | Some ienv ->
              (* the parse uses the env var if defined which may be
                 deprecated  *)
              Option.is_some (Env.info_deprecated ienv) &&
              Option.is_some (env (Env.info_var ienv))
          end
      | _ -> Option.is_some (Arg_info.deprecated info)
      in
      if deprecation_invoked then (info, arg) :: acc else acc
    in
    List.rev (fold (add ~env) cline [])

  let pp_deprecated ~subst ppf (info, arg) =
    let open Cmdliner_base in
  let plural l = if List.length l > 1 then "s" else "" in
    let subst = Arg_info.doclang_subst ~subst info in
    match (arg : arg) with
    | O [] | P [] ->
        let env = Option.get (Arg_info.env info) in
        let msg = Env.styled_deprecated ~errs:ppf ~subst env in
        Fmt.pf ppf "@[%a @[environment variable %a: %a@]@]"
          Fmt.deprecated () Fmt.code (Env.info_var env)
          Fmt.styled_text msg
    | O os ->
        let plural = plural os in
        let names = List.map (fun (_, n, _) -> n) os in
        let msg = Arg_info.styled_deprecated ~errs:ppf ~subst info in
        Fmt.pf ppf "@[%a @[option%s %a: %a@]@]"
          Fmt.deprecated () plural Fmt.(list ~sep:sp code_or_quote) names
          Fmt.styled_text msg
    | P args ->
        let plural = plural args in
        let msg =
          Arg_info.styled_deprecated ~errs:ppf ~subst info
        in
        Fmt.pf ppf "@[%a @[argument%s %a: %a@]@]"
          Fmt.deprecated () plural Fmt.(list ~sep:sp code_or_quote) args
          Fmt.styled_text msg
end

(* Evaluation *)

module Eval = struct
  type t = Arg_info.eval

  let make ~ancestors ~cmd ~subcmds ~env ~err_ppf : t =
    { ancestors; cmd; subcmds; env; err_ppf }

  let cmd (i : t) = i.cmd
  let ancestors (i : t) = i.ancestors
  let subcmds (i : t) = i.subcmds
  let env_var (i : t) v = i.env v
  let err_ppf (i : t) = i.err_ppf
  let main (i : t) = match List.rev i.ancestors with [] -> i.cmd | m :: _ -> m
  let with_cmd (i : t) cmd = { i with cmd }

  let doclang_name n = strf "$(b,%s)" (Cmd_info.escaped_name n)
  let doclang_names names =
    strf "$(b,%s)" (Cmdliner_manpage.escape (String.concat " " names))

  let doclang_subst (i : t) = function
  | "tname" | "cmd.name" -> Some (doclang_name i.cmd)
  | "mname" | "tool" -> Some (doclang_name (main i))
  | "cmd.parent" ->
      let ancestors = ancestors i in
      if ancestors = [] then Some (doclang_name (main i)) else
      Some (doclang_names (List.rev_map Cmd_info.name ancestors))
  | "iname" | "cmd" ->
      Some (doclang_names (List.rev_map Cmd_info.name (cmd i :: ancestors i)))
  | _ -> None
end

(* Terms *)

module Term = struct
  type escape = Arg_info.term_escape
  type 'a parser = 'a Arg_info.term_parser
  type 'a t = 'a Arg_info.term
  let some (aset, parser) =
    aset, (fun eval cline -> Result.map Option.some (parser eval cline))
end

module Arg_completion = struct
  type 'a directive = 'a Arg_info.completion_directive =
  | Message of string | String of string * string | Value of 'a * string
  | Files | Dirs | Restart | Raw of string

  let value ?(doc = "") v = Value (v, doc)
  let string ?(doc = "") s = String (s, doc)
  let files = Files
  let dirs = Dirs
  let restart = Restart
  let message msg = Message msg
  let raw s = Raw s

  type ('ctx, 'a) func =
    'ctx option -> token:string -> ('a directive list, string) result

  type 'a complete = 'a Arg_info.complete =
  | Complete : 'ctx Term.t option * ('ctx, 'a) func -> 'a complete

  type 'a t = 'a Arg_info.completion

  let make ?context func : 'a t = { complete = Complete (context, func) }
  let complete (c : 'a t) = c.complete

  let complete_files : 'a t =
    { complete = Complete (None, fun _ ~token:_ -> Ok [Files]) }

  let complete_dirs : 'a t =
    { complete = Complete (None, fun _ ~token:_ -> Ok [Dirs]) }

  let complete_paths : 'a t =
    { complete = Complete (None, fun _ ~token:_ -> Ok [Files; Dirs]) }

  let complete_restart : 'a t =
    { complete = Complete (None, fun _ ~token:_ -> Ok [Restart]) }

  let complete_none : 'a t =
    { complete = Complete (None, fun _ ~token:_ -> Ok []) }

  let directive_some : 'a directive -> 'a option directive = function
  | Value (v, doc) -> Value (Some v, doc)
  | (Message _ | String _ | Files | Dirs | Restart | Raw _ as v) -> v

  let complete_some (c : 'a t) : 'a option t = match c.complete with
  | Complete (ctx, func) ->
      let func ctx ~token =
        let some_result directives = List.map directive_some directives in
        Result.map some_result (func ctx ~token)
      in
      { complete = Complete (ctx, func) }
end

(* Converters *)

module Arg_conv = struct
  type 'a parser = 'a Arg_info.parser
  type 'a fmt = 'a Cmdliner_base.Fmt.t
  type 'a t = 'a Arg_info.conv

  let make
      ?(completion = Arg_completion.complete_none) ~docv ~parser ~pp () : 'a t =
    { docv; parser; pp; completion }

  let of_conv ?completion ?docv ?parser ?pp (conv : 'a t) : 'a t
    =
    let completion = Option.value ~default:conv.completion completion in
    let docv = Option.value ~default:conv.docv docv in
    let parser = Option.value ~default:conv.parser parser in
    let pp = Option.value ~default:conv.pp pp in
    { docv; parser; pp; completion }

  let docv (c : 'a t) = c.docv
  let parser (c : 'a t) = c.parser
  let pp (c : 'a t) = c.pp
  let completion (c : 'a t) = c.completion

  let none : 'a t =
    { docv = "";
      parser = (fun _ -> assert false);
      pp = (fun _ _ -> assert false);
      completion = Arg_completion.complete_none }

  let some ?(none = "") conv =
    let parser s = Result.map Option.some (parser conv s) in
    let pp ppf v = match v with
    | None -> Format.pp_print_string ppf none
    | Some v -> pp conv ppf v
    in
    let completion = Arg_completion.complete_some (completion conv) in
    { conv with parser; pp; completion }

  let some' ?none conv =
    let parser s = Result.map Option.some (parser conv s) in
    let pp ppf = function
    | None -> (match none with None -> () | Some v -> (pp conv) ppf v)
    | Some v -> pp conv ppf v
    in
    let completion = Arg_completion.complete_some conv.completion in
    { conv with parser; pp; completion }
end

(* Completion *)

module Complete = struct
  type kind =
  | Opt_value of Arg_info.t
  | Opt_name_or_pos_value of Arg_info.t
  | Opt_name

  type t =
    { token : string;
      after_dashdash : bool;
      subcmds : bool; (* Note this is adjusted in Cmdliner_eval *)
      kind : kind }

  let make ?(after_dashdash = false) ?(subcmds = false) ~token kind =
    { token; after_dashdash; subcmds; kind; }

  let token c = c.token
  let after_dashdash c = c.after_dashdash
  let subcmds c = c.subcmds
  let kind c = c.kind
  let add_subcmds c = { c with subcmds = true }
end
end
module Cmdliner_docgen : sig
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

val pp_man :
  env:(string -> string option) ->
  errs:Format.formatter -> Cmdliner_manpage.format -> Format.formatter ->
  Cmdliner_def.Eval.t -> unit

val styled_usage_synopsis :
  errs:Format.formatter -> Cmdliner_def.Eval.t -> string
end = struct
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

let rev_compare n0 n1 = compare n1 n0
let strf = Printf.sprintf

let order_args a0 a1 =
  match Cmdliner_def.Arg_info.is_opt a0, Cmdliner_def.Arg_info.is_opt a1 with
  | true, true -> (* optional by name *)
      let key names =
        let k = List.hd (List.sort rev_compare names) in
        let k = String.lowercase_ascii k in
        if k.[1] = '-' then String.sub k 1 (String.length k - 1) else k
      in
      compare
        (key @@ Cmdliner_def.Arg_info.opt_names a0)
        (key @@ Cmdliner_def.Arg_info.opt_names a1)
  | false, false -> (* positional by variable *)
      compare
        (String.lowercase_ascii @@ Cmdliner_def.Arg_info.docv a0)
        (String.lowercase_ascii @@ Cmdliner_def.Arg_info.docv a1)
  | true, false -> -1 (* positional first *)
  | false, true -> 1  (* optional after *)

let esc = Cmdliner_manpage.escape

let sorted_items_to_blocks ~boilerplate:b items =
  (* Items are sorted by section and then rev. sorted by appearance.
     We gather them by section in correct order in a `Block and prefix
     them with optional boilerplate *)
  let boilerplate = match b with None -> (fun _ -> None) | Some b -> b in
  let mk_block sec acc = match boilerplate sec with
  | None -> (sec, `Blocks acc)
  | Some b -> (sec, `Blocks (b :: acc))
  in
  let rec loop secs sec acc = function
  | (sec', it) :: its when sec' = sec -> loop secs sec (it :: acc) its
  | (sec', it) :: its -> loop (mk_block sec acc :: secs) sec' [it] its
  | [] -> (mk_block sec acc) :: secs
  in
  match items with
  | [] -> []
  | (sec, it) :: its -> loop [] sec [it] its

(* Command docs *)

let invocation ?(sep = " ") ?(ancestors = []) cmd =
  let names = List.rev_map Cmdliner_def.Cmd_info.name (cmd :: ancestors) in
  esc @@ String.concat sep names

let synopsis_pos_arg a =
  let v = match Cmdliner_def.Arg_info.docv a with "" -> "ARG" | v -> v in
  let v = strf "$(i,%s)" (esc v) in
  let v =
    (if Cmdliner_def.Arg_info.is_req a then strf "%s" else strf "[%s]") v
  in
  match Cmdliner_def.Arg_info.(pos_len @@ pos_kind a) with
  | None -> v ^ ""
  | Some 1 -> v
  | Some n ->
      let rec loop n acc = if n <= 0 then acc else loop (n - 1) (v :: acc) in
      String.concat " " (loop n [])

let synopsis_opt_arg a n =
  let var = match Cmdliner_def.Arg_info.docv a with "" -> "VAL" | v -> v in
  match Cmdliner_def.Arg_info.opt_kind a with
  | Cmdliner_def.Arg_info.Flag -> strf "$(b,%s)" (esc n)
  | Cmdliner_def.Arg_info.Opt ->
        if String.length n > 2
        then strf "$(b,%s)=$(i,%s)" (esc n) (esc var)
        else strf "$(b,%s) $(i,%s)" (esc n) (esc var)
  | Cmdliner_def.Arg_info.Opt_vopt _ ->
      if String.length n > 2
      then strf "$(b,%s)[=$(i,%s)]" (esc n) (esc var)
      else strf "$(b,%s) [$(i,%s)]" (esc n) (esc var)

let deprecated cmd = match Cmdliner_def.Cmd_info.deprecated cmd with
| None -> "" | Some _ -> "(Deprecated) "

let synopsis ?(show_help = false) ?ancestors cmd =
  let show_help = if show_help then " [$(b,--help)]" else "" in
  match Cmdliner_def.Cmd_info.children cmd with
  | [] ->
      let rev_cli_order (a0, _) (a1, _) =
        Cmdliner_def.Arg_info.rev_pos_cli_order a0 a1
      in
      let args = Cmdliner_def.Cmd_info.args cmd in
      let oargs, pargs =
        Cmdliner_def.Arg_info.(Set.partition (fun a _ -> is_opt a) args)
      in
      let oargs =
        (* Keep only those that are listed in the s_options section and
           that are not [--version] or [--help]. * *)
        let keep a _ =
          let drop_names n = n = "--help" || n = "--version" in
          Cmdliner_def.Arg_info.docs a = Cmdliner_manpage.s_options &&
          not (List.exists drop_names (Cmdliner_def.Arg_info.opt_names a))
        in
        let oargs = Cmdliner_def.Arg_info.Set.(elements (filter keep oargs)) in
        let count = List.length oargs in
        let any_option = "[$(i,OPTION)]" in
        if count = 0 || count > 3 then any_option else
        let syn a =
          let syn =
            synopsis_opt_arg a (Cmdliner_def.Arg_info.opt_name_sample a)
          in
          if Cmdliner_def.Arg_info.is_req a
          then syn
          else strf "[%s]" syn
        in
        let oargs = List.sort order_args oargs in
        let oargs = String.concat " " (List.map syn oargs) in
        String.concat " " [oargs; any_option]
      in
      let pargs =
        let pargs = Cmdliner_def.Arg_info.Set.elements pargs in
        if pargs = [] then "" else
        let pargs = List.map (fun a -> a, synopsis_pos_arg a) pargs in
        let pargs = List.sort rev_cli_order pargs in
        String.concat " " ("" (* add a space *) :: List.rev_map snd pargs)
      in
      strf "%s$(b,%s)%s %s%s"
        (deprecated cmd) (invocation ?ancestors cmd) show_help oargs pargs
  | _cmds ->
      let subcmd = match Cmdliner_def.Cmd_info.has_args cmd with
      | false -> "$(i,COMMAND)" | true -> "[$(i,COMMAND)]"
      in
      strf "%s$(b,%s)%s %s " (deprecated cmd) (invocation ?ancestors cmd)
        show_help subcmd

let cmd_doc cmd =
  let depr = match Cmdliner_def.Cmd_info.deprecated cmd with
  | None -> "" | Some msg -> msg ^ " "
  in
  depr ^ Cmdliner_def.Cmd_info.doc cmd

let cmd_docs ei = match Cmdliner_def.(Cmd_info.children (Eval.cmd ei)) with
| [] -> []
| cmds ->
    let add_cmd acc cmd =
      let syn = synopsis cmd in
      (Cmdliner_def.Cmd_info.docs cmd, `I (syn, cmd_doc cmd)) :: acc
    in
    let by_sec_by_rev_name (s0, `I (c0, _)) (s1, `I (c1, _)) =
      let c = compare s0 s1 in
      if c <> 0 then c else compare c1 c0 (* N.B. reverse *)
    in
    let cmds = List.fold_left add_cmd [] cmds in
    let cmds = List.sort by_sec_by_rev_name cmds in
    let cmds = (cmds :> (string * Cmdliner_manpage.block) list) in
    sorted_items_to_blocks ~boilerplate:None cmds

(* Argument docs *)

let arg_man_item_label a =
  let s = match Cmdliner_def.Arg_info.is_pos a with
  | true -> strf "$(i,%s)" (esc @@ Cmdliner_def.Arg_info.docv a)
  | false ->
      let names = List.sort compare (Cmdliner_def.Arg_info.opt_names a) in
      String.concat ", " (List.rev_map (synopsis_opt_arg a) names)
  in
  match Cmdliner_def.Arg_info.deprecated a with
  | None -> s | Some _ -> "(Deprecated) " ^ s

let arg_to_man_item ~errs ~subst ~buf a =
  let subst = Cmdliner_def.Arg_info.doclang_subst ~subst a in
  let or_env ~value a = match Cmdliner_def.Arg_info.env a with
  | None -> ""
  | Some e ->
      let value = if value then " or" else "absent " in
      strf "%s $(b,%s) env" value (esc @@ Cmdliner_def.Env.info_var e)
  in
  let absent = match Cmdliner_def.Arg_info.absent a with
  | Cmdliner_def.Arg_info.Err -> "required"
  | Cmdliner_def.Arg_info.Doc "" -> strf "%s" (or_env ~value:false a)
  | Cmdliner_def.Arg_info.Doc s ->
      let s = Cmdliner_manpage.subst_vars ~errs ~subst buf s in
      strf "absent=%s%s" s (or_env ~value:true a)
  | Cmdliner_def.Arg_info.Val v ->
      match Lazy.force v with
      | "" -> strf "%s" (or_env ~value:false a)
      | v -> strf "absent=$(b,%s)%s" (esc v) (or_env ~value:true a)
  in
  let optvopt = match Cmdliner_def.Arg_info.opt_kind a with
  | Cmdliner_def.Arg_info.Opt_vopt v -> strf "default=$(b,%s)" (esc v)
  | _ -> ""
  in
  let argvdoc = match optvopt, absent with
  | "", "" -> ""
  | s, "" | "", s -> strf " (%s)" s
  | s, s' -> strf " (%s) (%s)" s s'
  in
  let deprecated = match Cmdliner_def.Arg_info.deprecated a with
  | None -> "" | Some msg -> msg ^ " "
  in
  let doc = deprecated ^ Cmdliner_def.Arg_info.doc a in
  let doc = Cmdliner_manpage.subst_vars ~errs ~subst buf doc in
  (Cmdliner_def.Arg_info.docs a, `I (arg_man_item_label a ^ argvdoc, doc))

let arg_docs ~errs ~subst ~buf ei =
  let by_sec_by_arg a0 a1 =
    let c = compare
        (Cmdliner_def.Arg_info.docs a0)
        (Cmdliner_def.Arg_info.docs a1)
    in
    if c <> 0 then c else
    let c =
      match
        Cmdliner_def.Arg_info.deprecated a0,
        Cmdliner_def.Arg_info.deprecated a1
      with
      | None, None | Some _, Some _ -> 0
      | None, Some _ -> -1 | Some _, None -> 1
    in
    if c <> 0 then c else order_args a0 a1
  in
  let keep_arg a _ acc =
    if not Cmdliner_def.Arg_info.(is_pos a && (docv a = "" || doc a = ""))
    then (a :: acc) else acc
  in
  let args = Cmdliner_def.Cmd_info.args @@ Cmdliner_def.Eval.cmd ei in
  let args = Cmdliner_def.Arg_info.Set.fold keep_arg args [] in
  let args = List.sort by_sec_by_arg args in
  let args = List.rev_map (arg_to_man_item ~errs ~subst ~buf) args in
  sorted_items_to_blocks ~boilerplate:None args

(* Exit statuses doc *)

let exit_boilerplate sec = match sec = Cmdliner_manpage.s_exit_status with
| false -> None
| true -> Some (Cmdliner_manpage.s_exit_status_intro)

let exit_docs ~errs ~subst ~buf ~has_sexit ei =
  let by_sec (s0, _) (s1, _) = compare s0 s1 in
  let add_exit_item acc einfo =
    let subst = Cmdliner_def.Exit.doclang_subst ~subst einfo in
    let min, max = Cmdliner_def.Exit.info_codes einfo in
    let doc = Cmdliner_def.Exit.info_doc einfo in
    let label = if min = max then strf "%d" min else strf "%d-%d" min max in
    let item = `I (label, Cmdliner_manpage.subst_vars ~errs ~subst buf doc) in
    (Cmdliner_def.Exit.info_docs einfo, item) :: acc
  in
  let exits = Cmdliner_def.Cmd_info.exits @@ Cmdliner_def.Eval.cmd ei in
  let exits = List.sort Cmdliner_def.Exit.info_order exits in
  let exits = List.fold_left add_exit_item [] exits in
  let exits = List.stable_sort by_sec (* sort by section *) exits in
  let boilerplate = if has_sexit then None else Some exit_boilerplate in
  sorted_items_to_blocks ~boilerplate exits

(* Environment doc *)

let env_boilerplate sec = match sec = Cmdliner_manpage.s_environment with
| false -> None
| true -> Some (Cmdliner_manpage.s_environment_intro)

let env_docs ~errs ~subst ~buf ~has_senv ei =
  let add_env_item ~subst (seen, envs as acc) e =
    if Cmdliner_def.Env.Set.mem e seen then acc else
    let seen = Cmdliner_def.Env.Set.add e seen in
    let var = strf "$(b,%s)" @@ esc (Cmdliner_def.Env.info_var e) in
    let var, deprecated = match Cmdliner_def.Env.info_deprecated e with
    | None -> var, "" | Some msg -> "(Deprecated) " ^ var, msg ^ " " in
    let doc = deprecated ^ Cmdliner_def.Env.info_doc e in
    let doc = Cmdliner_manpage.subst_vars ~errs ~subst buf doc in
    let envs = (Cmdliner_def.Env.info_docs e, `I (var, doc)) :: envs in
    seen, envs
  in
  let add_arg_envs a _ acc =
    let envs = Cmdliner_def.Arg_info.doc_envs a in
    let envs = match Cmdliner_def.Arg_info.env a with
    | None -> envs | Some e -> e :: envs
    in
    let subst = Cmdliner_def.Arg_info.doclang_subst ~subst a in
    List.fold_left (add_env_item ~subst) acc envs
  in
  let add_env acc e =
    let subst = Cmdliner_def.Env.doclang_subst ~subst e in
    add_env_item ~subst acc e
  in
  let by_sec_by_rev_name (s0, `I (v0, _)) (s1, `I (v1, _)) =
    let c = compare s0 s1 in
    if c <> 0 then c else compare v1 v0 (* N.B. reverse *)
  in
  (* Arg envs before term envs is important here: if the same is mentioned
     both in an arg and in a term the substs of the arg are allowed. *)
  let args = Cmdliner_def.Cmd_info.args @@ Cmdliner_def.Eval.cmd ei in
  let tenvs = Cmdliner_def.Cmd_info.envs @@ Cmdliner_def.Eval.cmd ei in
  let init = Cmdliner_def.Env.Set.empty, [] in
  let acc = Cmdliner_def.Arg_info.Set.fold add_arg_envs args init in
  let _, envs = List.fold_left add_env acc tenvs in
  let envs = List.sort by_sec_by_rev_name envs in
  let envs = (envs :> (string * Cmdliner_manpage.block) list) in
  let boilerplate = if has_senv then None else Some env_boilerplate in
  sorted_items_to_blocks ~boilerplate envs

(* xref doc *)

let xref_docs ~errs ei =
  let main = Cmdliner_def.Eval.main ei in
  let to_xref = function
  | `Main -> Cmdliner_def.Cmd_info.name main, 1
  | `Tool tool -> tool, 1
  | `Page (name, sec) -> name, sec
  | `Cmd c ->
      (* N.B. we are handling only the first subcommand level here *)
      let cmds = Cmdliner_def.Cmd_info.children main in
      let mname = Cmdliner_def.Cmd_info.name main in
      let is_cmd cmd = Cmdliner_def.Cmd_info.name cmd = c in
      if List.exists is_cmd cmds then strf "%s-%s" mname c, 1 else
      (Format.fprintf errs "xref %s: no such command name@." c; "doc-err", 0)
  in
  let xref_str (name, sec) = strf "%s(%d)" (esc name) sec in
  let xrefs = Cmdliner_def.Cmd_info.man_xrefs @@ Cmdliner_def.Eval.cmd ei in
  let xrefs = match main == Cmdliner_def.Eval.cmd ei with
  | true -> List.filter (fun x -> x <> `Main) xrefs  (* filter out default *)
  | false -> xrefs
  in
  let xrefs = List.fold_left (fun acc x -> to_xref x :: acc) [] xrefs in
  let xrefs = List.(rev_map xref_str (sort rev_compare xrefs)) in
  if xrefs = [] then [] else
  [Cmdliner_manpage.s_see_also, `P (String.concat ", " xrefs)]

(* Man page construction *)

let ensure_s_name ei sm =
  if Cmdliner_manpage.(smap_has_section sm ~sec:s_name) then sm else
  let cmd = Cmdliner_def.Eval.cmd ei in
  let ancestors = Cmdliner_def.Eval.ancestors ei in
  let tname = (deprecated cmd) ^ invocation ~sep:"-" ~ancestors cmd in
  let tdoc = cmd_doc cmd in
  let tagline = if tdoc = "" then "" else strf " - %s" tdoc in
  let tagline = `P (strf "%s%s" tname tagline) in
  Cmdliner_manpage.(smap_append_block sm ~sec:s_name tagline)

let ensure_s_synopsis ei sm =
  if Cmdliner_manpage.(smap_has_section sm ~sec:s_synopsis) then sm else
  let cmd = Cmdliner_def.Eval.cmd ei in
  let ancestors = Cmdliner_def.Eval.ancestors ei in
  let synopsis = `P (synopsis ~ancestors cmd) in
  Cmdliner_manpage.(smap_append_block sm ~sec:s_synopsis synopsis)

let insert_cmd_man_docs ~errs ei sm =
  let buf = Buffer.create 200 in
  let subst = Cmdliner_def.Eval.doclang_subst ei in
  let ins sm (sec, b) = Cmdliner_manpage.smap_append_block sm ~sec b in
  let has_senv = Cmdliner_manpage.(smap_has_section sm ~sec:s_environment) in
  let has_sexit = Cmdliner_manpage.(smap_has_section sm ~sec:s_exit_status) in
  let sm = List.fold_left ins sm (cmd_docs ei) in
  let sm = List.fold_left ins sm (arg_docs ~errs ~subst ~buf ei) in
  let sm = List.fold_left ins sm (exit_docs ~errs ~subst ~buf ~has_sexit ei)in
  let sm = List.fold_left ins sm (env_docs ~errs ~subst ~buf ~has_senv ei) in
  let sm = List.fold_left ins sm (xref_docs ~errs ei) in
  sm

let text ~errs ei =
  let man = Cmdliner_def.Cmd_info.man @@ Cmdliner_def.Eval.cmd ei in
  let sm = Cmdliner_manpage.smap_of_blocks man in
  let sm = ensure_s_name ei sm in
  let sm = ensure_s_synopsis ei sm in
  let sm = insert_cmd_man_docs ei ~errs sm in
  Cmdliner_manpage.smap_to_blocks sm

let title ei =
  let main = Cmdliner_def.Eval.main ei in
  let exec = String.capitalize_ascii (Cmdliner_def.Cmd_info.name main) in
  let cmd = Cmdliner_def.Eval.cmd ei in
  let ancestors = Cmdliner_def.Eval.ancestors ei in
  let name = String.uppercase_ascii (invocation ~sep:"-" ~ancestors cmd) in
  let center_header = esc @@ strf "%s Manual" exec in
  let left_footer =
    let version = match Cmdliner_def.Cmd_info.version main with
    | None -> "" | Some v -> " " ^ v
    in
    esc @@ strf "%s%s" exec version
  in
  name, 1, "", left_footer, center_header

let man ~errs ei = title ei, text ~errs ei

let pp_man ~env ~errs fmt ppf ei =
  let subst = Cmdliner_def.Eval.doclang_subst ei in
  Cmdliner_manpage.print ~env ~errs ~subst fmt ppf (man ~errs ei)

(* Plain synopsis for usage *)

let styled_usage_synopsis ~errs ei =
  let subst = Cmdliner_def.Eval.doclang_subst ei in
  let cmd = Cmdliner_def.Eval.cmd ei in
  let ancestors = Cmdliner_def.Eval.ancestors ei in
  let synopsis = synopsis ~show_help:true ~ancestors cmd in
  Cmdliner_manpage.doc_to_styled ~errs ~subst synopsis
end
module Cmdliner_msg : sig
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

(** Messages for the end-user. *)

(** {1:env_err Environment variable errors} *)

val err_env_parse : Cmdliner_def.Env.info -> err:string -> string

(** {1:pos_err Positional argument errors} *)

val err_pos_excess : string list -> string
val err_pos_misses : Cmdliner_def.Arg_info.t list -> string
val err_pos_parse : Cmdliner_def.Arg_info.t -> err:string -> string

(** {1:opt_err Optional argument errors} *)

val err_flag_value : string -> string -> string
val err_opt_value_missing : string -> string
val err_opt_parse : string -> err:string -> string
val err_opt_repeated : string -> string -> string

(** {1:arg_err Argument errors} *)

val err_arg_missing : Cmdliner_def.Arg_info.t -> string
val err_cmd_missing : dom:string list -> string

(** {1:msgs Other messages} *)

val pp_version : Cmdliner_def.Eval.t Cmdliner_base.Fmt.t


val pp_exec_msg : Cmdliner_def.Eval.t Cmdliner_base.Fmt.t

val pp_err :
  Format.formatter -> Cmdliner_def.Eval.t -> err:string -> unit

val pp_usage_and_err :
  Format.formatter -> Cmdliner_def.Eval.t -> err:string -> unit

val pp_backtrace :
  Format.formatter -> Cmdliner_def.Eval.t -> exn -> Printexc.raw_backtrace ->
  unit
end = struct
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

module Fmt = Cmdliner_base.Fmt

(* Environment variable errors *)

let err_env_parse env ~err =
  let var = Cmdliner_def.Env.info_var env in
  Fmt.str "@[environment variable %a: %s@]" Fmt.code_or_quote var err

(* Positional argument errors *)

let err_pos_excess excess =
  Fmt.str "@[%a, don't know what to do with %a@]"
    Fmt.ereason "too many arguments"
    Fmt.(list ~sep:comma code_or_quote) excess

let err_pos_miss a = match Cmdliner_def.Arg_info.docv a with
| "" -> Fmt.str "@[a required argument is %a@]" Fmt.missing ()
| v -> Fmt.str "@[required argument %a is %a@]" Fmt.code_var v Fmt.missing ()

let err_pos_misses = function
| [] -> assert false
| [a] -> err_pos_miss a
| args ->
    let add_arg acc a = match Cmdliner_def.Arg_info.docv a with
    | "" -> "ARG" :: acc
    | argv -> argv :: acc
    in
    let rev_args = List.sort Cmdliner_def.Arg_info.rev_pos_cli_order args in
    let args = List.fold_left add_arg [] rev_args in
    Fmt.str "@[required arguments %a@ are@ %a@]"
      Fmt.(list ~sep:comma code_var) args Fmt.missing ()

let err_pos_parse a ~err = match Cmdliner_def.Arg_info.docv a with
| "" -> err
| argv ->
    match Cmdliner_def.Arg_info.(pos_len @@ pos_kind a) with
    | Some 1 -> Fmt.str "@[%a argument: %s@]" Fmt.code_var argv err
    | None | Some _ -> Fmt.str "@[%a arguments: %s@]" Fmt.code_var argv err

(* Optional argument errors *)

let err_flag_value flag v =
  Fmt.str "@[option %a is a flag, it@ %a@ %a@]"
    Fmt.code_or_quote flag Fmt.ereason "cannot take the argument"
    Fmt.code_or_quote v

let err_opt_value_missing f =
  Fmt.str "@[option %a %a@]" Fmt.code_or_quote f Fmt.ereason "needs an argument"

let err_opt_parse f ~err =
  Fmt.str "@[option %a: %a@]" Fmt.code_or_quote f Fmt.styled_text err

let err_opt_repeated f f' =
  if f = f' then
    Fmt.str "@[option %a %a@]"
      Fmt.code_or_quote f Fmt.ereason "cannot be repeated"
  else
  Fmt.str "@[options %a and %a@ %a@]"
    Fmt.code_or_quote f Fmt.code_or_quote f'
    Fmt.ereason "cannot be present at the same time"

(* Argument errors *)

let err_arg_missing a =
  if Cmdliner_def.Arg_info.is_pos a then err_pos_miss a else
  Fmt.str "@[required option %a is %a@]"
    Fmt.code (Cmdliner_def.Arg_info.opt_name_sample a) Fmt.missing ()

let err_cmd_missing ~dom =
  Fmt.str "@[required %a name is %a,@ must@ be@ %a@]"
    Fmt.code_var "COMMAND" Fmt.missing () Cmdliner_base.pp_alts dom

(* Other messages *)

let pp_version ppf ei =
  match Cmdliner_def.Cmd_info.version (Cmdliner_def.Eval.main ei) with
  | None -> assert false
  | Some v -> Fmt.pf ppf "@[%s@]@." v

let exec_name ei = Cmdliner_def.Cmd_info.name (Cmdliner_def.Eval.main ei)

let pp_exec_msg ppf ei = Fmt.pf ppf "%s:" (exec_name ei)

let pp_err ppf ei ~err =
  Fmt.pf ppf "@[%a @[%a@]@]@." pp_exec_msg ei Fmt.styled_text err

let pp_usage_and_err ppf ei ~err =
  Fmt.pf ppf "@[Usage: @[%a@]@]@."
    Fmt.styled_text (Cmdliner_docgen.styled_usage_synopsis ~errs:ppf ei);
  pp_err ppf ei ~err

let pp_backtrace ppf ei e bt =
  let bt = Printexc.raw_backtrace_to_string bt in
  let bt =
    let len = String.length bt in
    if len > 0 then String.sub bt 0 (len - 1) (* remove final '\n' *) else bt
  in
  Fmt.pf ppf "@[%a @[internal error, %a:@\n%a@]@]@."
    pp_exec_msg ei
    Fmt.ereason "uncaught exception"
    Fmt.lines (String.concat "\n" [Printexc.to_string e; bt])
end
module Cmdliner_term : sig
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

(** Terms *)

type term_escape =
  [ `Error of bool * string
  | `Help of Cmdliner_manpage.format * string option ]

type 'a parser =
  Cmdliner_def.Eval.t -> Cmdliner_def.Cline.t ->
  ('a, [ `Parse of string | term_escape ]) result
(** Type type for command line parser. given static information about
    the command line and a command line to parse returns an OCaml value. *)

type +'a t = 'a Cmdliner_def.Term.t
(** The type for terms. The list of arguments it can parse and the parsing
    function that does so. *)

val make : Cmdliner_def.Arg_info.Set.t -> 'a parser -> 'a t
val argset : 'a t -> Cmdliner_def.Arg_info.Set.t
val parser : 'a t -> 'a parser

val const : 'a -> 'a t
val app : ('a -> 'b) t -> 'a t -> 'b t
val map : ('a -> 'b) -> 'a t -> 'b t
val product : 'a t -> 'b t  -> ('a * 'b) t

module Syntax : sig
  val ( let+ ) : 'a t -> ('a -> 'b) -> 'b t
  val ( and+ ) : 'a t -> 'b t -> ('a * 'b) t
end

val ( $ ) : ('a -> 'b) t -> 'a t -> 'b t

type 'a ret = [ `Ok of 'a | term_escape ]

val ret : 'a ret t -> 'a t
val term_result : ?usage:bool -> ('a, [`Msg of string]) result t -> 'a t
val term_result' : ?usage:bool -> ('a, string) result t -> 'a t
val cli_parse_result : ('a, [`Msg of string]) result t -> 'a t
val cli_parse_result' : ('a, string) result t -> 'a t
val main_name : string t
val choice_names : string list t
val with_used_args : 'a t -> ('a * string list) t
val env : (string -> string option) t
end = struct
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

type term_escape = Cmdliner_def.Term.escape
type 'a parser = 'a Cmdliner_def.Term.parser
type +'a t = 'a Cmdliner_def.Term.t

let make args p = (args, p)
let argset (args, _) = args
let parser (_, parser) = parser

let const v = Cmdliner_def.Arg_info.Set.empty, (fun _ _ -> Ok v)
let app (args_f, f) (args_v, v) =
  Cmdliner_def.Arg_info.Set.union args_f args_v,
  fun ei cl -> match (f ei cl) with
  | Error _ as e -> e
  | Ok f ->
      match v ei cl with
      | Error _ as e -> e
      | Ok v -> Ok (f v)

let map f v = app (const f) v
let product v0 v1 = app (app (const (fun x y -> (x, y))) v0) v1

module Syntax = struct
  let ( let+ ) v f = map f v
  let ( and+ ) = product
end

(* Terms *)

let ( $ ) = app

type 'a ret = [ `Ok of 'a | term_escape ]

let ret (al, v) =
  al, fun ei cl -> match v ei cl with
  | Ok (`Ok v) -> Ok v
  | Ok (`Error _ as err) -> Error err
  | Ok (`Help _ as help) -> Error help
  | Error _ as e -> e

let term_result ?(usage = false) (al, v) =
  al, fun ei cl -> match v ei cl with
  | Ok (Ok _ as ok) -> ok
  | Ok (Error (`Msg e)) -> Error (`Error (usage, e))
  | Error _ as e -> e

let term_result' ?usage t =
  let wrap = app (const (Result.map_error (fun e -> `Msg e))) t in
  term_result ?usage wrap

let cli_parse_result (al, v) =
  al, fun ei cl -> match v ei cl with
  | Ok (Ok _ as ok) -> ok
  | Ok (Error (`Msg e)) -> Error (`Parse e)
  | Error _ as e -> e

let cli_parse_result' t =
  let wrap = app (const (Result.map_error (fun e -> `Msg e))) t in
  cli_parse_result wrap

let main_name =
  Cmdliner_def.Arg_info.Set.empty,
  (fun ei _ -> Ok (Cmdliner_def.Cmd_info.name @@ Cmdliner_def.Eval.main ei))

let choice_names =
  Cmdliner_def.Arg_info.Set.empty,
  (fun ei _ ->
     (* N.B. this keeps everything backward compatible. We return the command
        names of main's children *)
     let name t = Cmdliner_def.Cmd_info.name t in
     let choices =
       Cmdliner_def.Cmd_info.children (Cmdliner_def.Eval.main ei)
     in
     Ok (List.rev_map name choices))

let with_used_args (al, v) : (_ * string list) t =
  al, fun ei cl ->
    match v ei cl with
    | Ok x ->
        let actual_args arg_info _ acc =
          let args = Cmdliner_def.Cline.actual_args cl arg_info in
          List.rev_append args acc
        in
        let used =
          List.rev (Cmdliner_def.Arg_info.Set.fold actual_args al [])
        in
        Ok (x, used)
    | Error _ as e -> e


let env =
  Cmdliner_def.Arg_info.Set.empty,
  (fun ei _ -> Ok (Cmdliner_def.Eval.env_var ei))
end
module Cmdliner_completion : sig
(*---------------------------------------------------------------------------
   Copyright (c) 2025 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

val output :
  out_ppf:Format.formatter -> err_ppf:Format.formatter ->
  Cmdliner_def.Eval.t -> Cmdliner_def.Complete.t -> Cmdliner_def.Cline.t ->
  unit
end = struct
(*---------------------------------------------------------------------------
   Copyright (c) 2025 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

(* Output protocol  *)

let cons_if b v l = if b then v :: l else l

type directive =
| Dirs | Files | Group of string * (string * string) list
| Restart | Message of string

let pp_protocol ppf dirs =
  let pp_line ppf s = Cmdliner_base.Fmt.(string ppf s; cut ppf ()) in
  let pp_text ppf s = Cmdliner_base.Fmt.(pf ppf "@[%a@]@," styled_text s) in
  let vnum = 1 (* Protocol version number *) in
  let pp_item ppf (name, doc) =
    pp_line ppf "item";
    pp_line ppf name; pp_text ppf doc;
    pp_line ppf "item-end";
  in
  let pp_dir ppf = function
  | Dirs -> pp_line ppf "dirs"
  | Files -> pp_line ppf "files"
  | Restart -> pp_line ppf "restart"
  | Group (name, items) ->
      pp_line ppf "group";
      pp_line ppf name;
      Cmdliner_base.Fmt.(list ~sep:nop pp_item) ppf items;
  | Message msg ->
      pp_line ppf "message"; pp_text ppf msg; pp_line ppf "message-end"
  in
  Cmdliner_base.Fmt.pf ppf "@[<v>%d@,%a@]" vnum
    Cmdliner_base.Fmt.(list ~sep:nop pp_dir) dirs

let add_subcommands_group ~err_ppf ~subst eval comp directives =
  if not (Cmdliner_def.Complete.subcmds comp) then directives else
  let prefix = Cmdliner_def.Complete.token comp in
  let maybe_item cmd =
    let name = Cmdliner_def.Cmd_info.name cmd in
    if not (Cmdliner_base.string_starts_with ~prefix name) then None else
    (* FIXME subst is wrong here. *)
    let doc = Cmdliner_def.Cmd_info.styled_doc ~errs:err_ppf ~subst cmd in
    Some (name, doc)
  in
  let subcmds = Cmdliner_def.Eval.subcmds eval in
  Group ("Subcommands", List.filter_map maybe_item subcmds) :: directives

let add_options_group ~err_ppf ~subst eval comp directives =
  let prefix = Cmdliner_def.Complete.token comp in
  let maybe_items arg_info =
    let names = Cmdliner_def.Arg_info.opt_names arg_info in
    let subst = Cmdliner_def.Arg_info.doclang_subst ~subst arg_info in
    let doc = Cmdliner_def.Arg_info.styled_doc ~errs:err_ppf ~subst arg_info in
    let add_name n =
      if not (Cmdliner_base.string_starts_with ~prefix n) then None else
      Some (n, doc)
    in
    List.filter_map add_name names
  in
  let maybe_opt = prefix = "" || prefix.[0] = '-' in
  if Cmdliner_def.Complete.after_dashdash comp || not maybe_opt
  then directives else
  let cmd_info = Cmdliner_def.Eval.cmd eval in
  let set = Cmdliner_def.Cmd_info.args cmd_info in
  if Cmdliner_def.Arg_info.Set.is_empty set then directives else
  let options = Cmdliner_def.Arg_info.Set.elements set in
  Group ("Options", List.concat (List.map maybe_items options)) :: directives

let add_argument_value_directives directives eval arg_info comp cline =
  let (Conv conv) =
    let arg_infos = Cmdliner_def.Cmd_info.args (Cmdliner_def.Eval.cmd eval) in
    Option.get (Cmdliner_def.Arg_info.Set.find_opt arg_info arg_infos)
  in
  let value_dirs =
    let completion = Cmdliner_def.Arg_conv.completion conv in
    match Cmdliner_def.Arg_completion.complete completion with
    | Complete (ctx, func) ->
        let ctx = match ctx with
        | None -> None
        | Some ctx ->
            match (Cmdliner_term.parser ctx) eval cline with
            | Ok ctx -> Some ctx
            | Error _ -> None
            | exception exn -> None
        in
        func ctx ~token:(Cmdliner_def.Complete.token comp)
  in
  match value_dirs with
  | Error msg -> `Directives [Message msg]
  | Ok ds ->
      let pp = Cmdliner_def.Arg_conv.pp conv in
      let rec loop values msgs ~files ~dirs ~restart ~raw = function
      | [] ->
          begin match raw with
          | Some r -> `Raw r
          | None ->
              if Cmdliner_def.Complete.after_dashdash comp && restart
              then `Directives [Restart] else
              let dd =
                cons_if dirs Dirs @@
                cons_if files Files @@
                cons_if (values <> []) (Group ("Values", List.rev values)) []
              in
              `Directives (List.rev_append msgs (List.rev_append dd directives))
          end
      | d :: ds ->
          match d with
          | Cmdliner_def.Arg_completion.String (s, doc) ->
              loop ((s, doc) :: values) msgs ~files ~dirs ~restart ~raw ds
          | Value (v, doc) ->
              let s = Cmdliner_base.Fmt.str "@[<h>%a@]" pp v in
              loop ((s, doc) :: values) msgs ~files ~dirs ~restart ~raw ds
          | Files -> loop values msgs ~files:true ~dirs ~restart ~raw ds
          | Dirs -> loop values msgs ~files ~dirs:true ~restart ~raw ds
          | Restart -> loop values msgs ~files ~dirs ~restart:true ~raw ds
          | Message msg ->
              loop values (Message msg :: msgs) ~files ~dirs ~restart ~raw ds
          | Raw r -> loop values msgs ~files ~dirs ~restart ~raw:(Some r) ds
      in
      loop [] [] ~files:false ~dirs:false ~restart:false ~raw:None ds

let output ~out_ppf ~err_ppf eval comp cline =
  let subst = Cmdliner_def.Eval.doclang_subst eval in
  let dirs = add_subcommands_group ~err_ppf ~subst eval comp [] in
  let res = match Cmdliner_def.Complete.kind comp with
  | Opt_value arg_info ->
      add_argument_value_directives dirs eval arg_info comp cline
  | Opt_name_or_pos_value arg_info ->
      let dirs = add_options_group ~err_ppf ~subst eval comp dirs in
      add_argument_value_directives dirs eval arg_info comp cline
  | Opt_name ->
      `Directives (add_options_group ~err_ppf ~subst eval comp dirs)
  in
  if out_ppf == Format.std_formatter
  then set_binary_mode_out stdout true;
  match res with
  | `Raw raw -> Cmdliner_base.Fmt.pf out_ppf "%s@?" raw
  | `Directives dirs -> Cmdliner_base.Fmt.pf out_ppf "%a@?" pp_protocol dirs
end
module Cmdliner_cmd : sig
(*---------------------------------------------------------------------------
   Copyright (c) 2022 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

(** Commands and their information. *)

type info = Cmdliner_def.Cmd_info.t

val info :
  ?deprecated:string -> ?man_xrefs:Cmdliner_manpage.xref list ->
  ?man:Cmdliner_manpage.block list -> ?envs:Cmdliner_def.Env.info list ->
  ?exits:Cmdliner_def.Exit.info list -> ?sdocs:string -> ?docs:string ->
  ?doc:string -> ?version:string -> string -> info

type 'a t =
| Cmd of info * 'a Cmdliner_term.parser
| Group of info * ('a Cmdliner_term.parser option * 'a t list)

val make : info -> 'a Cmdliner_term.t -> 'a t
val v : info -> 'a Cmdliner_term.t -> 'a t
val group : ?default:'a Cmdliner_term.t -> info -> 'a t list -> 'a t
val name : 'a t -> string
val name_trie : 'a t list -> 'a t Cmdliner_trie.t
val list_names : 'a t list -> string list
val get_info : 'a t -> info
val get_children_infos : 'a t -> info list
end = struct
(*---------------------------------------------------------------------------
   Copyright (c) 2022 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

(* Commands *)

type info = Cmdliner_def.Cmd_info.t
let info = Cmdliner_def.Cmd_info.make

type 'a t =
| Cmd of info * 'a Cmdliner_term.parser
| Group of info * ('a Cmdliner_term.parser option * 'a t list)

let make info t =
  let info = Cmdliner_def.Cmd_info.add_args info (Cmdliner_term.argset t) in
  Cmd (info, Cmdliner_term.parser t)

let v = make

let get_info = function Cmd (info, _) | Group (info, _) -> info
let get_children_infos = function
| Cmd _ -> [] | Group (_, (_, cs)) -> List.map get_info cs

let group ?default info cmds =
  let args, parser = match default with
  | None -> None, None
  | Some t -> Some (Cmdliner_term.argset t), Some (Cmdliner_term.parser t)
  in
  let children = List.map get_info cmds in
  let info = Cmdliner_def.Cmd_info.with_children info ~args ~children in
  Group (info, (parser, cmds))

let name c = Cmdliner_def.Cmd_info.name (get_info c)

let name_trie cmds =
  let add acc cmd =
    let info = get_info cmd in
    let name = Cmdliner_def.Cmd_info.name info in
    match Cmdliner_trie.add acc name cmd with
    | `New t -> t
    | `Replaced (cmd', _) ->
        let info' = get_info cmd' and kind = "command" in
        invalid_arg @@
        Cmdliner_base.err_multi_def ~kind name
          Cmdliner_def.Cmd_info.doc info info'
  in
  List.fold_left add Cmdliner_trie.empty cmds

let list_names cmds =
  let cmd_name c = Cmdliner_def.Cmd_info.name (get_info c) in
  List.sort String.compare (List.rev_map cmd_name cmds)
end
module Cmdliner_cline : sig
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

(** Command lines. *)

val is_opt : string -> bool
val has_complete_prefix : string -> bool
val get_token_to_complete : string -> string

(** {1:cli Command lines} *)

val create :
  ?peek_opts:bool -> legacy_prefixes:bool -> for_completion:bool ->
  Cmdliner_def.Arg_info.Set.t -> string list ->
  [ `Ok of Cmdliner_def.Cline.t
  | `Complete of Cmdliner_def.Complete.t * Cmdliner_def.Cline.t
  | `Error of string * Cmdliner_def.Cline.t ]
end = struct
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

(* A command line stores pre-parsed information about the command
   line's arguments in a more structured way. Given the
   Cmdliner_def.Arg_info.t values mentioned in a term and Sys.argv
   (without exec name) we parse the command line into
   [Cmdliner_def.Cline.t] which is map of [Cmdliner_def.Arg_info.t]
   values to [Cmdliner_def.Cline.arg] values. This map is used by the
   term's closures to retrieve and convert command line arguments (see
   the [Cmdliner_arg] module). *)

(* Completion *)

let complete_prefix = "--__complete="
let has_complete_prefix s =
  Cmdliner_base.string_starts_with ~prefix:complete_prefix s

let get_token_to_complete s =
  Cmdliner_base.string_drop_first (String.length complete_prefix) s

let is_opt_to_complete s = (* assert (has_complete_prefix s) *)
  String.length s > String.length complete_prefix &&
  s.[String.length complete_prefix] = '-'

let maybe_token_to_complete ~for_completion s =
  if not for_completion || not (has_complete_prefix s) then None else
  Some (get_token_to_complete s)

(* Command lines *)

let err_multi_opt_name_def name arg_info arg_info' =
  Cmdliner_base.err_multi_def ~kind:"option name" name
    Cmdliner_def.Arg_info.doc arg_info arg_info'

let arg_info_indexes arg_infos =
  (* from [args] returns a trie mapping the names of optional arguments to
     their arg_info, a list with all arg_info for positional arguments and
     a Cmdliner_def.Cline.t mapping each arg_info to an empty [arg]. *)
  let rec loop optidx posidx cline = function
  | [] -> optidx, posidx, cline
  | arg_info :: l ->
      match Cmdliner_def.Arg_info.is_pos arg_info with
      | true ->
          let cline = Cmdliner_def.Cline.add arg_info (P []) cline in
          loop optidx (arg_info :: posidx) cline l
      | false ->
          let add t name = match Cmdliner_trie.add t name arg_info with
          | `New t -> t
          | `Replaced (a', _) ->
              invalid_arg (err_multi_opt_name_def name arg_info a')
          in
          let names = Cmdliner_def.Arg_info.opt_names arg_info in
          let optidx = List.fold_left add optidx names in
          let cline = Cmdliner_def.Cline.add arg_info (O []) cline in
          loop optidx posidx cline l
  in
  let cline = Cmdliner_def.Cline.empty in
  let arg_infos = Cmdliner_def.Arg_info.Set.elements arg_infos in
  loop Cmdliner_trie.empty [] cline arg_infos

(* Optional argument parsing *)

(* Note on option completion. Technically when trying to complete an
   option we could try to avoid mentioning names that have already be
   mentioned and that are not repeatable. Sometimes not being able to
   complete what we know exists ends up being more confusing than
   enlightening so we don't do that for now.

   Also the code is quite messy, perhaps we should cleanly separate
   parsing for completion and parsing for evaluation. *)

let is_opt s = String.length s > 1 && s.[0] = '-'
let is_short_opt s = String.length s = 2 && s.[0] = '-'

let parse_opt_arg s =
  (* (name, value) of opt arg, assert len > 1. except if complete *)
  let is_completion = has_complete_prefix s in
  let s = if is_completion then get_token_to_complete s else s in
  let l = String.length s in
  if l <= 1 then "-", None, is_completion else
  if s.[1] <> '-' then (* short opt *)
    if l = 2 then s, None, is_completion else
    String.sub s 0 2, Some (String.sub s 2 (l - 2)) (* with glued opt arg *),
    is_completion
  else try (* long opt *)
    let i = String.index s '=' in
    String.sub s 0 i, Some (String.sub s (i + 1) (l - i - 1)), is_completion
  with Not_found -> s, None, is_completion

let hint_matching_opt optidx s =
  (* hint option names that could match [s] in [optidx]. *)
  if String.length s <= 2 then [] else
  let short_opt, long_opt =
    if s.[1] <> '-'
    then s, Printf.sprintf "-%s" s
    else String.sub s 1 (String.length s - 1), s
  in
  let short_opt, _, _ = parse_opt_arg short_opt in
  let long_opt, _, _ = parse_opt_arg long_opt in
  let all = Cmdliner_trie.ambiguities optidx "-" in
  match List.mem short_opt all, Cmdliner_base.suggest long_opt all with
  | false, [] -> []
  | false, l -> l
  | true, [] -> [short_opt]
  | true, l -> if List.mem short_opt l then l else short_opt :: l

let parse_opt_value ~for_completion cline arg_info name value args =
  (* Either we got a value glued in [value] or we need to get one in [args]
     in this case we need to take care of a possible completion token *)
  match Cmdliner_def.Arg_info.opt_kind arg_info with
  | Flag -> (* Flags have no values but we may get dash sharing in [value] *)
      begin match value with
      | None -> None, None, args
      | Some v when is_short_opt name -> (* short flag dash sharing *)
          None, None, ("-" ^ v) :: args
      | Some _ -> (* an error but this is reported during typed parsing *)
          None, value, args
      end
  | _ ->
      match value with
      | Some _ -> None, value, args
      | None -> (* Get it from the next argument. *)
          match args with
          | [] -> None, None, args
          | v :: rest when for_completion && has_complete_prefix v ->
              let v = get_token_to_complete v in
              if is_opt v then (* not an option value *) None, None, args else
              let comp =
                Cmdliner_def.Complete.make ~token:v (Opt_value arg_info)
              in
              Some comp, None, rest
          | v :: rest ->
              if is_opt v then None, None, args else None, Some v, rest

let try_complete_opt_value cline arg_info name value args =
  (* At that point we found a matching option name so this should be mostly
     about completing a glued option value, but there are twists. *)
  match Cmdliner_def.Arg_info.opt_kind arg_info with
  | Cmdliner_def.Arg_info.Flag ->
      begin match value with
      | Some v when is_short_opt name ->
          (* short flag dash sharing, push the completion *)
          let args = (complete_prefix ^ "-" ^ v) :: args in
          None, None, args
      | Some v ->
          (* This is actually a parse error, flags have no value.  We
             make it an option completion but the completions will
             eventually be empty (the prefix won't match) *)
          Some (Cmdliner_def.Complete.make ~token:(name ^ v) Opt_name),
          None, args
      | None ->
          (* We have in fact a fully completed flag turn it into an
             option completion. *)
          Some (Cmdliner_def.Complete.make ~token:name Opt_name), None, args
      end
  | _ ->
      begin match value with
      | Some token ->
          Some (Cmdliner_def.Complete.make ~token (Opt_value arg_info)), None,
          args
      | None ->
          (* We have a fully completed option name, we don't try to
             lookup what happens in the next argument which should
             hold the value if any, we just turn it into an option
             completion. *)
          Some (Cmdliner_def.Complete.make ~token:name Opt_name), None, args
      end

let parse_opt_args
    ~peek_opts ~legacy_prefixes ~for_completion optidx cline args
  =
  (* returns an updated [cline] cmdline according to the options found in [args]
     with the trie index [optidx]. Positional arguments are returned in order
     in a list. *)
  let rec loop errs k comp cline pargs = function
  | [] -> List.rev errs, comp, cline, false, List.rev pargs
  | "--" :: args ->
      List.rev errs, comp, cline, true, (List.rev_append pargs args)
  | s :: args ->
      let do_parse =
        is_opt s &&
        (if not for_completion then true else
         if not (has_complete_prefix s) then true else
         is_opt_to_complete s)
      in
      if not do_parse then loop errs (k + 1) comp cline (s :: pargs) args else
      let name, value, is_completion = parse_opt_arg s in
      match Cmdliner_trie.find ~legacy_prefixes optidx name with
      | Ok arg_info ->
          let acomp, value, args =
            if is_completion
            then try_complete_opt_value cline arg_info name value args
            else parse_opt_value ~for_completion cline arg_info name value args
          in
          let comp = match acomp with Some _ -> acomp | None -> comp in
          let arg : Cmdliner_def.Cline.arg =
            O ((k, name, value) ::
               Cmdliner_def.Cline.get_opt_arg cline arg_info)
          in
          let cline = Cmdliner_def.Cline.add arg_info arg cline in
          loop errs (k + 1) comp cline pargs args
      | Error `Not_found when for_completion ->
          if not is_completion then
            (* Drop the data, if the user thought this was an opt with
               an argument this may confuse positional args but there's
               not much we can do. *)
            loop errs (k + 1) comp cline pargs args
          else
          let token = name ^ Option.value ~default:"" value in
          let comp = Some (Cmdliner_def.Complete.make ~token Opt_name) in
          loop errs (k + 1) comp cline pargs args
      | Error `Not_found when peek_opts ->
          loop errs (k + 1) comp cline pargs args
      | Error `Not_found ->
          let hints = hint_matching_opt optidx s in
          let err = Cmdliner_base.err_unknown ~kind:"option" ~hints name in
          loop (err :: errs) (k + 1) comp cline pargs args
      | Error `Ambiguous (* Only on legacy prefixes *) ->
          let ambs = Cmdliner_trie.ambiguities optidx name in
          let ambs = List.sort compare ambs in
          let err = Cmdliner_base.err_ambiguous ~kind:"option" name ~ambs in
          loop (err :: errs) (k + 1) comp cline pargs args
  in
  let errs, comp, cline, has_dashdash, pargs = loop [] 0 None cline [] args in
  if errs = [] then Ok (comp, cline, has_dashdash, pargs) else
  match comp with
  | Some _ -> Ok (comp, cline, has_dashdash, pargs)
  | None ->
      let err = String.concat "\n" errs in
      Error (err, cline, has_dashdash, pargs)

(* Positional argument parsing *)

let take_range ~for_completion start stop l =
  let rec loop i comp acc = function
  | [] -> comp, (List.rev acc)
  | v :: vs ->
      if i < start then loop (i + 1) comp acc vs else
      if i <= stop then match maybe_token_to_complete ~for_completion v with
      | Some _ as comp -> loop (i + 1) comp (v :: acc) vs
      | None -> loop (i + 1) comp (v :: acc) vs
      else comp, List.rev acc
  in
  loop 0 None [] l

let parse_pos_args ~for_completion posidx comp cline ~has_dashdash pargs =
  (* returns an updated [cline] cmdline in which each positional arg mentioned
     in the list index [posidx], is given a value according the list
     of positional arguments values [pargs]. *)
  if pargs = [] then
    let misses = List.filter Cmdliner_def.Arg_info.is_req posidx in
    if misses = [] then Ok (comp, cline) else
    match comp with
    | Some _ -> Ok (comp, cline)
    | None -> Error (Cmdliner_msg.err_pos_misses misses, cline)
  else
  let last = List.length pargs - 1 in
  let pos rev k = if rev then last - k else k in
  let rec loop misses comp cline max_spec = function
  | [] -> misses, comp, cline, max_spec
  | arg_info :: al ->
      let apos = Cmdliner_def.Arg_info.pos_kind arg_info in
      let rev = Cmdliner_def.Arg_info.pos_rev apos in
      let start = pos rev (Cmdliner_def.Arg_info.pos_start apos) in
      let stop = match Cmdliner_def.Arg_info.pos_len apos with
      | None -> pos rev last
      | Some n -> pos rev (Cmdliner_def.Arg_info.pos_start apos + n - 1)
      in
      let start, stop = if rev then stop, start else start, stop in
      let comp, args = match take_range ~for_completion start stop pargs with
      | None, args -> comp, args
      | Some token, args ->
          let comp =
            Cmdliner_def.Complete.make ~after_dashdash:has_dashdash ~token
              (Opt_name_or_pos_value arg_info)
          in
          Some comp, args
      in
      let max_spec = max stop max_spec in
      let cline = Cmdliner_def.Cline.add arg_info (P args) cline in
      let misses = match Cmdliner_def.Arg_info.is_req arg_info && args = [] with
      | true -> arg_info :: misses
      | false -> misses
      in
      loop misses comp cline max_spec al
  in
  let misses, comp, cline, max_spec = loop [] comp cline (-1) posidx in
  if misses <> [] then begin
    if Option.is_some comp then Ok (comp, cline) else
    Error (Cmdliner_msg.err_pos_misses misses, cline)
  end else
  if last <= max_spec then Ok (comp, cline) else
  if Option.is_some comp then Ok (comp, cline) else
  let comp, excess = take_range ~for_completion (max_spec + 1) last pargs in
  match comp with
  | None -> Error (Cmdliner_msg.err_pos_excess excess, cline)
  | Some token ->
      let comp =
        Cmdliner_def.Complete.make ~after_dashdash:has_dashdash ~token Opt_name
      in
      Ok (Some comp, cline)

let create ?(peek_opts = false) ~legacy_prefixes ~for_completion al args =
  let optidx, posidx, cline = arg_info_indexes al in
  match
    parse_opt_args ~for_completion ~peek_opts ~legacy_prefixes optidx cline args
  with
  | Ok (comp, cline, _has_dashdash, _pargs) when peek_opts ->
      begin match comp with
      | None -> `Ok cline
      | Some comp -> `Complete (comp, cline)
      end
  | Ok (comp, cline, has_dashdash, pargs) ->
      begin match
        parse_pos_args ~for_completion posidx comp cline ~has_dashdash pargs
      with
      | Ok (None, _) | Error _ when for_completion ->
          (* Normally we should have found a completion token This
             may fail to happen if pos args are ill defined: we may miss the
             completion token. Just make sure we do a completion. *)
          begin match List.find_opt has_complete_prefix pargs with
          | None -> assert false
          | Some arg ->
              match maybe_token_to_complete ~for_completion:true arg with
              | None -> assert false
              | Some token ->
                  let comp =
                    Cmdliner_def.Complete.make
                      ~after_dashdash:has_dashdash ~token Opt_name
                  in
                  `Complete (comp, cline)
          end
      | Ok (None, cline) -> `Ok cline
      | Ok (Some comp, cline) -> `Complete (comp, cline)
      | Error v -> `Error v
      end
  | Error (errs, cline, has_dashdash, pargs) ->
      match
        parse_pos_args ~for_completion posidx None cline ~has_dashdash pargs
      with
      | Ok (Some comp, cline) -> `Complete (comp, cline)
      | _ -> `Error (errs, cline)
end
module Cmdliner_arg : sig
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

(** Command line arguments as terms. *)

(* Converters *)

type 'a conv

module Completion : sig
  type 'a directive

  val value : ?doc:string -> 'a -> 'a directive
  val string : ?doc:string -> string -> 'a directive
  val files : 'a directive
  val dirs : 'a directive
  val restart : 'a directive
  val message : string -> 'a directive
  val raw : string -> 'a directive

  type ('ctx, 'a) func =
    'ctx option -> token:string -> ('a directive list, string) result

  type 'a complete =
  | Complete : 'ctx Cmdliner_term.t option * ('ctx, 'a) func -> 'a complete

  type 'a t

  val make : ?context:'ctx Cmdliner_term.t -> ('ctx, 'a) func -> 'a t

  val complete : 'a t -> 'a complete
  val complete_none : 'a t
  val complete_files : 'a t
  val complete_dirs : 'a t
  val complete_paths : 'a t
  val complete_restart : 'a t
end

module Conv : sig
  type 'a parser = string -> ('a, string) result
  type 'a fmt = Format.formatter -> 'a -> unit
  type 'a t = 'a conv
  val make :
    ?completion:'a Completion.t -> docv:string -> parser:'a parser ->
    pp:'a fmt -> unit -> 'a t

  val of_conv :
    ?completion:'a Completion.t -> ?docv:string -> ?parser:'a parser ->
    ?pp:'a fmt -> 'a t -> 'a t

  val docv : 'a conv -> string
  val parser : 'a conv -> 'a parser
  val pp : 'a conv -> 'a fmt
  val completion : 'a t -> 'a Completion.t
end

val some : ?none:string -> 'a conv -> 'a option conv
val some' : ?none:'a -> 'a conv -> 'a option conv

(* Arguments *)

type 'a t = 'a Cmdliner_term.t

type info
val info :
  ?deprecated:string -> ?absent:string -> ?docs:string ->
  ?doc_envs:Cmdliner_def.Env.info list -> ?docv:string -> ?doc:string ->
  ?env:Cmdliner_def.Env.info -> string list -> info

val ( & ) : ('a -> 'b) -> 'a -> 'b

val flag : info -> bool t
val flag_all : info -> bool list t
val vflag : 'a -> ('a * info) list -> 'a t
val vflag_all : 'a list -> ('a * info) list -> 'a list t
val opt : ?vopt:'a -> 'a conv -> 'a -> info -> 'a t
val opt_all : ?vopt:'a -> 'a conv -> 'a list -> info -> 'a list t

val pos : ?rev:bool -> int -> 'a conv -> 'a -> info -> 'a t
val pos_all : 'a conv -> 'a list -> info -> 'a list t
val pos_left : ?rev:bool -> int -> 'a conv -> 'a list -> info -> 'a list t
val pos_right : ?rev:bool -> int -> 'a conv -> 'a list -> info -> 'a list t

(* As terms *)

val value : 'a t -> 'a Cmdliner_term.t
val required : 'a option t -> 'a Cmdliner_term.t
val non_empty : 'a list t -> 'a list Cmdliner_term.t
val last : 'a list t -> 'a Cmdliner_term.t

(* Predefined arguments *)

val man_format : Cmdliner_manpage.format Cmdliner_term.t
val stdopt_version : docs:string -> bool Cmdliner_term.t
val stdopt_help : docs:string -> Cmdliner_manpage.format option Cmdliner_term.t

(* Predifined converters *)

val bool : bool conv
val char : char conv
val int : int conv
val nativeint : nativeint conv
val int32 : int32 conv
val int64 : int64 conv
val float : float conv
val string : string conv
val enum : ?docv:string -> (string * 'a) list -> 'a conv
val path : string conv
val filepath : string conv
val dirpath : string conv
val file : string conv
val dir : string conv
val non_dir_file : string conv
val list : ?sep:char -> 'a conv -> 'a list conv
val array : ?sep:char -> 'a conv -> 'a array conv
val pair : ?sep:char -> 'a conv -> 'b conv -> ('a * 'b) conv
val t2 : ?sep:char -> 'a conv -> 'b conv -> ('a * 'b) conv
val t3 : ?sep:char -> 'a conv ->'b conv -> 'c conv -> ('a * 'b * 'c) conv
val t4 :
  ?sep:char -> 'a conv ->'b conv -> 'c conv -> 'd conv ->
  ('a * 'b * 'c * 'd) conv

val doc_quote : string -> string
val doc_alts : ?quoted:bool -> string list -> string
val doc_alts_enum : ?quoted:bool -> (string * 'a) list -> string

(* Deprecated *)

type 'a printer = Format.formatter -> 'a -> unit
val conv' : ?docv:string -> 'a Conv.parser * 'a Conv.fmt -> 'a conv
val conv :
  ?docv:string -> (string -> ('a, [`Msg of string]) result) * 'a Conv.fmt ->
  'a conv

val conv_parser : 'a conv -> (string -> ('a, [`Msg of string]) result)
val conv_printer : 'a conv -> 'a printer
val conv_docv : 'a conv -> string
val parser_of_kind_of_string :
  kind:string -> (string -> 'a option) ->
  (string -> ('a, [`Msg of string]) result)
end = struct
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

let rev_compare n0 n1 = compare n1 n0

(* Documentation formatting helpers *)

module Fmt = Cmdliner_base.Fmt

let doc_quote = Cmdliner_base.quote
let doc_alts = Cmdliner_base.alts_str
let doc_alts_enum ?quoted enum = doc_alts ?quoted (List.map fst enum)
let str_of_pp pp v = pp Format.str_formatter v; Format.flush_str_formatter ()

(* Invalid_argument strings *)

let err_not_opt = "Option argument without name"
let err_not_pos = "Positional argument with a name"
let err_incomplete_enum ss =
  Printf.sprintf
    "Arg.enum: missing printable string for a value, other strings are: %s"
    (String.concat ", " ss)

(* Parse error strings *)

let err_no kind s = Fmt.str "no %a %s" Fmt.code_or_quote s kind
let err_not_dir s =
  Fmt.str "%a %a" Fmt.code_or_quote s Fmt.ereason "is not a directory"

let err_is_dir s =
  Fmt.str "%a %a" Fmt.code_or_quote s Fmt.ereason "is a directory"

let err_element kind s exp =
  Fmt.str "%a element in %s (%a): %s"
    Fmt.invalid () kind Fmt.code_or_quote s exp

let err_invalid kind s exp =
  Fmt.str "@[%a %s %a, %s@]" Fmt.invalid () kind Fmt.code_or_quote s exp

let err_invalid_val = err_invalid "value"
let err_sep_miss sep s =
  err_invalid_val s (Fmt.str "%a a '%c' separator" Fmt.missing () sep)

let err_invalid_enum var s enums =
  let pp_docv ppf var =
    if not (var = "ENUM" || var = "") then Fmt.pf ppf "%a " Fmt.code_var var
  in
  Fmt.str "@[%a@ %avalue %a, expected@ %a@]" Fmt.invalid () pp_docv var
    Fmt.code_or_quote s Cmdliner_base.pp_alts enums

(* Argument converters *)

module Completion = Cmdliner_def.Arg_completion
module Conv = Cmdliner_def.Arg_conv
type 'a conv = 'a Conv.t
let some = Cmdliner_def.Arg_conv.some
let some' = Cmdliner_def.Arg_conv.some'
let none = Cmdliner_def.Arg_conv.none

(* Argument information *)

type 'a t = 'a Cmdliner_term.t
type info = Cmdliner_def.Arg_info.t
let info = Cmdliner_def.Arg_info.make

(* Arguments *)

let ( & ) f x = f x
let parse_error e = Error (`Parse e)

let env_bool_parse s = match String.lowercase_ascii s with
| "" | "false" | "no" | "n" | "0" -> Ok false
| "true" | "yes" | "y" | "1" -> Ok true
| s ->
    let alts = doc_alts ~quoted:true ["true"; "yes"; "false"; "no" ] in
    Error (err_invalid_val s alts)

let parse_to_list parser s = match parser s with
| Ok v -> Ok [v] | Error _ as e -> e

let try_env ei a parse ~absent = match Cmdliner_def.Arg_info.env a with
| None -> Ok absent
| Some env ->
    let var = Cmdliner_def.Env.info_var env in
    match Cmdliner_def.Eval.env_var ei var with
    | None -> Ok absent
    | Some v ->
        match parse v with
        | Error e -> parse_error (Cmdliner_msg.err_env_parse env ~err:e)
        | Ok _ as v -> v

let arg_to_args a complete = Cmdliner_def.Arg_info.Set.singleton a complete
let list_to_args f l complete =
  let add acc v = Cmdliner_def.Arg_info.Set.add (f v) complete acc in
  List.fold_left add Cmdliner_def.Arg_info.Set.empty l

let flag a =
  if Cmdliner_def.Arg_info.is_pos a then invalid_arg err_not_opt else
  let convert ei cl = match Cmdliner_def.Cline.get_opt_arg cl a with
  | [] -> try_env ei a env_bool_parse ~absent:false
  | [_, _, None] -> Ok true
  | [_, f, Some v] -> parse_error (Cmdliner_msg.err_flag_value f v)
  | (_, f, _) :: (_ ,g, _) :: _  ->
      parse_error (Cmdliner_msg.err_opt_repeated f g)
  in
  Cmdliner_term.make (arg_to_args a (Conv none)) convert

let flag_all a =
  if Cmdliner_def.Arg_info.is_pos a then invalid_arg err_not_opt else
  let a = Cmdliner_def.Arg_info.make_all_opts a in
  let convert ei cl = match Cmdliner_def.Cline.get_opt_arg cl a with
  | [] -> try_env ei a (parse_to_list env_bool_parse) ~absent:[]
  | l ->
      try
        let truth (_, f, v) = match v with
        | None -> true
        | Some v -> failwith (Cmdliner_msg.err_flag_value f v)
        in
        Ok (List.rev_map truth l)
      with Failure e -> parse_error e
  in
  Cmdliner_term.make (arg_to_args a (Conv none)) convert

let vflag v l =
  let convert _ cl =
    let rec aux fv = function
    | (v, a) :: rest ->
        begin match Cmdliner_def.Cline.get_opt_arg cl a with
        | [] -> aux fv rest
        | [_, f, None] ->
            begin match fv with
            | None -> aux (Some (f, v)) rest
            | Some (g, _) -> failwith (Cmdliner_msg.err_opt_repeated g f)
            end
        | [_, f, Some v] -> failwith (Cmdliner_msg.err_flag_value f v)
        | (_, f, _) :: (_, g, _) :: _ ->
            failwith (Cmdliner_msg.err_opt_repeated g f)
        end
    | [] -> match fv with None -> v | Some (_, v) -> v
    in
    try Ok (aux None l) with Failure e -> parse_error e
  in
  let flag (_, a) =
    if Cmdliner_def.Arg_info.is_pos a then invalid_arg err_not_opt else a
  in
  Cmdliner_term.make (list_to_args flag l (Conv none)) convert

let vflag_all v l =
  let convert _ cl =
    let rec aux acc = function
    | (fv, a) :: rest ->
        begin match Cmdliner_def.Cline.get_opt_arg cl a with
        | [] -> aux acc rest
        | l ->
            let fval (k, f, v) = match v with
            | None -> (k, fv)
            | Some v -> failwith (Cmdliner_msg.err_flag_value f v)
            in
            aux (List.rev_append (List.rev_map fval l) acc) rest
        end
    | [] ->
        if acc = [] then v else List.rev_map snd (List.sort rev_compare acc)
    in
    try Ok (aux [] l) with Failure e -> parse_error e
  in
  let flag (_, a) =
    if Cmdliner_def.Arg_info.is_pos a then invalid_arg err_not_opt else
    Cmdliner_def.Arg_info.make_all_opts a
  in
  Cmdliner_term.make (list_to_args flag l (Conv none)) convert

let parse_opt_value parse f v = match parse v with
| Ok v -> v | Error err -> failwith (Cmdliner_msg.err_opt_parse f ~err)

let opt ?vopt conv v a =
  if Cmdliner_def.Arg_info.is_pos a then invalid_arg err_not_opt else
  let absent = match Cmdliner_def.Arg_info.absent a with
  | Cmdliner_def.Arg_info.Doc d as a when d <> "" -> a
  | _ -> Cmdliner_def.Arg_info.Val (lazy (str_of_pp (Conv.pp conv) v))
  in
  let kind = match vopt with
  | None -> Cmdliner_def.Arg_info.Opt
  | Some dv -> Cmdliner_def.Arg_info.Opt_vopt (str_of_pp (Conv.pp conv) dv)
  in
  let docv = match Cmdliner_def.Arg_info.docv a with
  | "" -> Conv.docv conv | docv -> docv
  in
  let a = Cmdliner_def.Arg_info.make_opt ~docv ~absent ~kind a in
  let convert ei cl = match Cmdliner_def.Cline.get_opt_arg cl a with
  | [] -> try_env ei a (Conv.parser conv) ~absent:v
  | [_, f, Some v] ->
      (try Ok (parse_opt_value (Conv.parser conv) f v) with
      | Failure e -> parse_error e)
  | [_, f, None] ->
      begin match vopt with
      | None -> parse_error (Cmdliner_msg.err_opt_value_missing f)
      | Some optv -> Ok optv
      end
  | (_, f, _) :: (_, g, _) :: _ ->
      parse_error (Cmdliner_msg.err_opt_repeated g f)
  in
  Cmdliner_term.make (arg_to_args a (Conv conv)) convert

let opt_all ?vopt conv v a =
  if Cmdliner_def.Arg_info.is_pos a then invalid_arg err_not_opt else
  let absent = match Cmdliner_def.Arg_info.absent a with
  | Cmdliner_def.Arg_info.Doc d as a when d <> "" -> a
  | _ -> Cmdliner_def.Arg_info.Val (lazy "")
  in
  let kind = match vopt with
  | None -> Cmdliner_def.Arg_info.Opt
  | Some dv -> Cmdliner_def.Arg_info.Opt_vopt (str_of_pp (Conv.pp conv) dv)
  in
  let docv = match Cmdliner_def.Arg_info.docv a with
  | "" -> Conv.docv conv | docv -> docv
  in
  let a = Cmdliner_def.Arg_info.make_opt_all ~docv ~absent ~kind a in
  let convert ei cl = match Cmdliner_def.Cline.get_opt_arg cl a with
  | [] -> try_env ei a (parse_to_list (Conv.parser conv)) ~absent:v
  | l ->
      let parse (k, f, v) = match v with
      | Some v -> (k, parse_opt_value (Conv.parser conv) f v)
      | None -> match vopt with
      | None -> failwith (Cmdliner_msg.err_opt_value_missing f)
      | Some dv -> (k, dv)
      in
      try Ok (List.rev_map snd
                (List.sort rev_compare (List.rev_map parse l))) with
      | Failure e -> parse_error e
  in
  Cmdliner_term.make (arg_to_args a (Conv conv)) convert

(* Positional arguments *)

let parse_pos_value parse a v = match parse v with
| Ok v -> v
| Error err -> failwith (Cmdliner_msg.err_pos_parse a ~err)

let pos ?(rev = false) k conv v a =
  if Cmdliner_def.Arg_info.is_opt a then invalid_arg err_not_pos else
  let absent = match Cmdliner_def.Arg_info.absent a with
  | Cmdliner_def.Arg_info.Doc d as a when d <> "" -> a
  | _ -> Cmdliner_def.Arg_info.Val (lazy (str_of_pp (Conv.pp conv) v))
  in
  let pos = Cmdliner_def.Arg_info.pos ~rev ~start:k ~len:(Some 1) in
  let docv = match Cmdliner_def.Arg_info.docv a with
  | "" -> Conv.docv conv | docv -> docv
  in
  let a = Cmdliner_def.Arg_info.make_pos_abs ~docv ~absent ~pos a in
  let convert ei cl = match Cmdliner_def.Cline.get_pos_arg cl a with
  | [] -> try_env ei a (Conv.parser conv) ~absent:v
  | [v] ->
      (try Ok (parse_pos_value (Conv.parser conv) a v) with
      | Failure e -> parse_error e)
  | _ -> assert false
  in
  Cmdliner_term.make (arg_to_args a (Conv conv)) convert

let pos_list pos conv v a =
  if Cmdliner_def.Arg_info.is_opt a then invalid_arg err_not_pos else
  let docv = match Cmdliner_def.Arg_info.docv a with
  | "" -> Conv.docv conv | docv -> docv
  in
  let a = Cmdliner_def.Arg_info.make_pos ~docv ~pos a in
  let convert ei cl = match Cmdliner_def.Cline.get_pos_arg cl a with
  | [] -> try_env ei a (parse_to_list (Conv.parser conv)) ~absent:v
  | l ->
      try Ok (List.rev (List.rev_map (parse_pos_value (Conv.parser conv) a) l))
      with
      | Failure e -> parse_error e
  in
  Cmdliner_term.make (arg_to_args a (Conv conv)) convert

let all = Cmdliner_def.Arg_info.pos ~rev:false ~start:0 ~len:None
let pos_all c v a = pos_list all c v a

let pos_left ?(rev = false) k =
  let start = if rev then k + 1 else 0 in
  let len = if rev then None else Some k in
  pos_list (Cmdliner_def.Arg_info.pos ~rev ~start ~len)

let pos_right ?(rev = false) k =
  let start = if rev then 0 else k + 1 in
  let len = if rev then Some k else None in
  pos_list (Cmdliner_def.Arg_info.pos ~rev ~start ~len)

(* Arguments as terms *)

let absent_error args =
  let make_req a v acc =
    let req_a = Cmdliner_def.Arg_info.make_req a in
    Cmdliner_def.Arg_info.Set.add req_a v acc
  in
  Cmdliner_def.Arg_info.Set.fold make_req args Cmdliner_def.Arg_info.Set.empty

let value a = a

let err_arg_missing args =
  parse_error @@
  Cmdliner_msg.err_arg_missing (fst (Cmdliner_def.Arg_info.Set.choose args))

let required t =
  let args = absent_error (Cmdliner_term.argset t) in
  let convert ei cl = match (Cmdliner_term.parser t) ei cl with
  | Ok (Some v) -> Ok v
  | Ok None -> err_arg_missing args
  | Error _ as e -> e
  in
  Cmdliner_term.make args convert

let non_empty t =
  let args = absent_error (Cmdliner_term.argset t) in
  let convert ei cl = match (Cmdliner_term.parser t) ei cl with
  | Ok [] -> err_arg_missing args
  | Ok l -> Ok l
  | Error _ as e -> e
  in
  Cmdliner_term.make args convert

let last t =
  let convert ei cl = match (Cmdliner_term.parser t) ei cl with
  | Ok [] -> err_arg_missing (Cmdliner_term.argset t)
  | Ok l -> Ok (List.hd (List.rev l))
  | Error _ as e -> e
  in
  Cmdliner_term.make (Cmdliner_term.argset t) convert

(* Predefined converters. *)

let add_prefix_completion ~token name =
  if Cmdliner_base.string_starts_with ~prefix:token name
  then Some (Completion.string name) else None

let bool =
  let alts = ["true"; "false"] in
  let parser s = try Ok (bool_of_string s) with
  | Invalid_argument _ -> Error (err_invalid_enum "" s alts)
  in
  let completion =
    let func _ctx ~token =
      Ok (List.filter_map (add_prefix_completion ~token) alts)
    in
    Completion.make func
  in
  Conv.make ~docv:"BOOL" ~parser ~pp:Format.pp_print_bool ~completion ()

let char =
  let parser s = match String.length s = 1 with
  | true -> Ok s.[0]
  | false -> Error (err_invalid_val s "expected a character")
  in
  Conv.make ~docv:"CHAR" ~parser ~pp:Fmt.char ()

let parse_with t_of_str exp s =
  try Ok (t_of_str s) with Failure _ -> Error (err_invalid_val s exp)

let int =
  let parser = parse_with int_of_string "expected an integer" in
  Conv.make ~docv:"INT" ~parser ~pp:Format.pp_print_int ()

let int32 =
  let parser = parse_with Int32.of_string "expected a 32-bit integer" in
  let pp ppf = Fmt.pf ppf "%ld" in
  Conv.make ~docv:"INT32" ~parser ~pp ()

let int64 =
  let parser = parse_with Int64.of_string "expected a 64-bit integer" in
  let pp ppf = Fmt.pf ppf "%Ld" in
  Conv.make ~docv:"INT64" ~parser ~pp ()

let nativeint =
  let err = "expected a processor-native integer" in
  let parser = parse_with Nativeint.of_string err in
  let pp ppf = Fmt.pf ppf "%nd" in
  Conv.make ~docv:"NATIVEINT" ~parser ~pp ()

let float =
  let parser = parse_with float_of_string "expected a floating point number" in
  Conv.make ~docv:"DOUBLE" ~parser ~pp:Format.pp_print_float ()

let string = Conv.make ~docv:"" ~parser:Result.ok ~pp:Fmt.string ()

let enum ?(docv = "ENUM") sl =
  if sl = [] then invalid_arg Cmdliner_base.err_empty_list else
  let t = Cmdliner_trie.of_list sl in
  let parser s =
    let legacy_prefixes = Cmdliner_trie.legacy_prefixes ~env:Sys.getenv_opt in
    match Cmdliner_trie.find ~legacy_prefixes t s with
    | Ok _ as v -> v
    | Error `Ambiguous (* Only on legacy prefixes *) ->
        let ambs = List.sort compare (Cmdliner_trie.ambiguities t s) in
        Error (Cmdliner_base.err_ambiguous ~kind:"enum value" s ~ambs)
    | Error `Not_found ->
        let alts = List.rev (List.rev_map (fun (s, _) -> s) sl) in
        Error (err_invalid_enum docv s alts)
  in
  let pp ppf v =
    let sl_inv = List.rev_map (fun (s,v) -> (v,s)) sl in
    try Fmt.string ppf (List.assoc v sl_inv)
    with Not_found -> invalid_arg (err_incomplete_enum (List.map fst sl))
  in
  let completion =
    let func _ctx ~token =
      Ok (List.filter_map (fun (n, _) -> add_prefix_completion ~token n) sl)
    in
    Completion.make func
  in
  Conv.make ~docv ~parser ~pp ~completion ()

let path =
  let parser s = Ok s in
  let pp ppf s = Fmt.string ppf (Filename.quote s) in
  let completion = Completion.complete_paths in
  Conv.make ~docv:"PATH" ~parser ~pp ~completion ()

let filepath =
  let parser s = Ok s in
  let pp ppf s = Fmt.string ppf (Filename.quote s) in
  let completion = Completion.complete_files in
  Conv.make ~docv:"FILE" ~parser ~pp ~completion ()

let dirpath =
  let parser s = Ok s in
  let pp ppf s = Fmt.string ppf (Filename.quote s) in
  let completion = Completion.complete_dirs in
  Conv.make ~docv:"DIR" ~parser ~pp ~completion ()

let file =
  let parser s =
    if s = "-" then Ok s else
    if Sys.file_exists s then Ok s else
    Error (err_no "file or directory" s)
  in
  let completion = Completion.complete_files in
  Conv.make ~docv:"PATH" ~parser ~pp:Fmt.string ~completion ()

let dir =
  let parser s =
    if Sys.file_exists s
    then (if Sys.is_directory s then Ok s else Error (err_not_dir s))
    else Error (err_no "directory" s)
  in
  let completion = Completion.complete_dirs in
  Conv.make ~docv:"DIR" ~parser ~pp:Fmt.string ~completion ()

let non_dir_file =
  let parser s =
    if s = "-" then Ok s else
    if Sys.file_exists s
    then (if not (Sys.is_directory s) then Ok s else Error (err_is_dir s))
    else Error (err_no "file" s)
  in
  let completion = Completion.complete_files in
  Conv.make ~docv:"FILE" ~parser ~pp:Fmt.string ~completion ()

let split_and_parse sep parse s = (* raises [Failure] *)
  let parse sub = match parse sub with
  | Error e -> failwith e | Ok v -> v
  in
  let rec split accum j =
    let i = try String.rindex_from s j sep with Not_found -> -1 in
    if (i = -1) then
      let p = String.sub s 0 (j + 1) in
      if p <> "" then parse p :: accum else accum
    else
    let p = String.sub s (i + 1) (j - i) in
    let accum' = if p <> "" then parse p :: accum else accum in
    split accum' (i - 1)
  in
  split [] (String.length s - 1)

let list ?(sep = ',') conv =
  let parser s = try Ok (split_and_parse sep (Conv.parser conv) s) with
  | Failure e -> Error (err_element "list" s e)
  in
  let rec pp ppf = function
  | [] -> ()
  | v :: l ->
      (Conv.pp conv) ppf v; if (l <> []) then (Fmt.char ppf sep; pp ppf l)
  in
  let docv = Printf.sprintf "%s[%c]" (Conv.docv conv) sep in
  Conv.make ~docv ~parser ~pp ()

let array ?(sep = ',') conv =
  let parser s =
    try Ok (Array.of_list (split_and_parse sep (Conv.parser conv) s)) with
    | Failure e -> Error (err_element "array" s e)
  in
  let pp ppf v =
    let max = Array.length v - 1 in
    for i = 0 to max do
      Conv.pp conv ppf v.(i); if i <> max then Fmt.char ppf sep
    done
  in
  let docv = Printf.sprintf "%s[%c]" (Conv.docv conv) sep in
  Conv.make ~docv ~parser ~pp ()

let split_left sep s =
  try
    let i = String.index s sep in
    let len = String.length s in
    Some ((String.sub s 0 i), (String.sub s (i + 1) (len - i - 1)))
  with Not_found -> None

let pair ?(sep = ',') conv0 conv1 =
  let parser s = match split_left sep s with
  | None -> Error (err_sep_miss sep s)
  | Some (v0, v1) ->
      match (Conv.parser conv0) v0, (Conv.parser conv1) v1 with
      | Ok v0, Ok v1 -> Ok (v0, v1)
      | Error e, _ | _, Error e -> Error (err_element "pair" s e)
  in
  let pp ppf (v0, v1) =
    Fmt.pf ppf "%a%c%a" (Conv.pp conv0) v0 sep (Conv.pp conv1) v1
  in
  let docv = Printf.sprintf "%s%c%s" (Conv.docv conv0) sep (Conv.docv conv1) in
  Conv.make ~docv ~parser ~pp ()

let t2 = pair
let t3 ?(sep = ',') conv0 conv1 conv2 =
  let parser s = match split_left sep s with
  | None -> Error (err_sep_miss sep s)
  | Some (v0, s) ->
      match split_left sep s with
      | None -> Error (err_sep_miss sep s)
      | Some (v1, v2) ->
          match (Conv.parser conv0) v0, (Conv.parser conv1) v1,
                (Conv.parser conv2) v2 with
          | Ok v0, Ok v1, Ok v2 -> Ok (v0, v1, v2)
          | Error e, _, _ | _, Error e, _ | _, _, Error e ->
              Error (err_element "triple" s e)
  in
  let pp ppf (v0, v1, v2) =
    let pp = Conv.pp in
    Fmt.pf ppf "%a%c%a%c%a" (pp conv0) v0 sep (pp conv1) v1 sep (pp conv2) v2
  in
  let docv =
    let docv = Conv.docv in
    Printf.sprintf "%s%c%s%c%s" (docv conv0) sep (docv conv1) sep (docv conv2)
  in
  Conv.make ~docv ~parser ~pp ()

let t4 ?(sep = ',') conv0 conv1 conv2 conv3 =
  let parser s = match split_left sep s with
  | None -> Error (err_sep_miss sep s)
  | Some(v0, s) ->
      match split_left sep s with
      | None -> Error (err_sep_miss sep s)
      | Some (v1, s) ->
          match split_left sep s with
          | None -> Error (err_sep_miss sep s)
          | Some (v2, v3) ->
              match (Conv.parser conv0) v0, (Conv.parser conv1) v1,
                    (Conv.parser conv2) v2, (Conv.parser conv3) v3  with
              | Ok v1, Ok v2, Ok v3, Ok v4 -> Ok (v1, v2, v3, v4)
              | Error e, _, _, _ | _, Error e, _, _ | _, _, Error e, _
              | _, _, _, Error e -> Error (err_element "quadruple" s e)
  in
  let pp ppf (v0, v1, v2, v3) =
    let pp = Conv.pp in
    Fmt.pf ppf "%a%c%a%c%a%c%a" (pp conv0) v0 sep (pp conv1) v1 sep (pp conv2)
      v2 sep (pp conv3) v3
  in
  let docv =
    let docv = Conv.docv in
    Printf.sprintf "%s%c%s%c%s%c%s"
      (docv conv0) sep (docv conv1) sep (docv conv2) sep (docv conv3)
  in
  Conv.make ~docv ~parser ~pp ()

(* Predefined arguments *)

let man_fmts =
  ["auto", `Auto; "pager", `Pager; "groff", `Groff; "plain", `Plain]

let man_fmt_docv = "FMT"
let man_fmts_enum = enum ~docv:man_fmt_docv man_fmts
let man_fmts_alts = doc_alts_enum man_fmts
let man_fmts_doc kind =
  Printf.sprintf
    "Show %s in format $(docv). The value $(docv) must be %s. \
     With $(b,auto), the format is $(b,pager) or $(b,plain) whenever \
     the $(b,TERM) env var is $(b,dumb) or undefined."
    kind man_fmts_alts

let man_format =
  let doc = man_fmts_doc "output" in
  let docv = man_fmt_docv in
  value & opt man_fmts_enum `Pager & info ["man-format"] ~docv ~doc

let stdopt_version ~docs =
  value & flag & info ["version"] ~docs ~doc:"Show version information."

let stdopt_help ~docs =
  let doc = man_fmts_doc "this help" in
  let docv = man_fmt_docv in
  value & opt ~vopt:(Some `Auto) (some man_fmts_enum) None &
  info ["help"] ~docv ~docs ~doc

(* Deprecated *)

type 'a printer = 'a Conv.fmt
let docv_default = "VALUE"
let conv' ?docv (parser, pp) = Conv.make ~docv:docv_default ~parser ~pp ()
let conv ?docv (parser, pp) =
  let parser s = match parser s with
  | Ok _ as v -> v | Error (`Msg e) -> Error e
  in
  Conv.make ~docv:docv_default ~parser ~pp ()

let conv_printer = Conv.pp
let conv_docv = Conv.docv
let conv_parser conv =
  fun s -> match Conv.parser conv s with
  | Ok _ as v -> v | Error e -> Error (`Msg e)

let err_invalid s kind =
  `Msg (Printf.sprintf "invalid value '%s', expected %s" s kind)

let parser_of_kind_of_string ~kind k_of_string =
  fun s -> match k_of_string s with
  | None -> Error (err_invalid s kind)
  | Some v -> Ok v
end
module Cmdliner_eval : sig
(*---------------------------------------------------------------------------
   Copyright (c) 2022 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

(** Command evaluation *)

type 'a eval_ok = [ `Ok of 'a | `Version | `Help ]
type eval_error = [ `Parse | `Term | `Exn ]
type 'a eval_exit = [ `Ok of 'a  | `Exit of Cmdliner_def.Exit.code ]

val eval_value :
  ?help:Format.formatter -> ?err:Format.formatter -> ?catch:bool ->
  ?env:(string -> string option) -> ?argv:string array -> 'a Cmdliner_cmd.t ->
  ('a eval_ok, eval_error) result

val eval_value' :
  ?help:Format.formatter -> ?err:Format.formatter -> ?catch:bool ->
  ?env:(string -> string option) -> ?argv:string array ->
  ?term_err:int -> 'a Cmdliner_cmd.t -> 'a eval_exit

val eval_peek_opts :
  ?version_opt:bool -> ?env:(string -> string option) ->
  ?argv:string array -> 'a Cmdliner_term.t ->
  'a option * ('a eval_ok, eval_error) result

val eval :
  ?help:Format.formatter -> ?err:Format.formatter -> ?catch:bool ->
  ?env:(string -> string option) -> ?argv:string array ->
  ?term_err:int -> unit Cmdliner_cmd.t -> Cmdliner_def.Exit.code

val eval' :
  ?help:Format.formatter -> ?err:Format.formatter -> ?catch:bool ->
  ?env:(string -> string option) -> ?argv:string array ->
  ?term_err:int -> int Cmdliner_cmd.t -> Cmdliner_def.Exit.code

val eval_result :
  ?help:Format.formatter -> ?err:Format.formatter -> ?catch:bool ->
  ?env:(string -> string option) -> ?argv:string array ->
  ?term_err:Cmdliner_def.Exit.code -> (unit, string) result Cmdliner_cmd.t ->
  Cmdliner_def.Exit.code

val eval_result' :
  ?help:Format.formatter -> ?err:Format.formatter -> ?catch:bool ->
  ?env:(string -> string option) -> ?argv:string array ->
  ?term_err:Cmdliner_def.Exit.code ->
  (Cmdliner_def.Exit.code, string) result Cmdliner_cmd.t ->
  Cmdliner_def.Exit.code
end = struct
(*---------------------------------------------------------------------------
   Copyright (c) 2022 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

type 'a eval_ok = [ `Ok of 'a | `Version | `Help ]
type eval_error = [ `Parse | `Term | `Exn ]
type 'a eval_exit = [ `Ok of 'a  | `Exit of Cmdliner_def.Exit.code ]

type eval_result_error =
  [ Cmdliner_term.term_escape
  | `Exn of exn * Printexc.raw_backtrace
  | `Parse of string
  | `Std_help of Cmdliner_manpage.format
  | `Std_version ]

type 'a eval_result =
  ('a, [ eval_result_error
       | `Complete of Cmdliner_def.Complete.t * Cmdliner_def.Cline.t]) result

let err_help s = "Term error, help requested for unknown command " ^ s
let err_argv = "argv array must have at least one element"

let add_stdopts eval =
  let docs = Cmdliner_def.Cmd_info.stdopts_docs (Cmdliner_def.Eval.cmd eval) in
  let vargs, vers =
    match Cmdliner_def.Cmd_info.version (Cmdliner_def.Eval.main eval) with
    | None -> Cmdliner_def.Arg_info.Set.empty, None
    | Some _ ->
        let vers = Cmdliner_arg.stdopt_version ~docs in
        (Cmdliner_term.argset vers), Some vers
  in
  let help = Cmdliner_arg.stdopt_help ~docs in
  let args =
    Cmdliner_def.Arg_info.Set.union vargs (Cmdliner_term.argset help)
  in
  let cmd = Cmdliner_def.Cmd_info.add_args (Cmdliner_def.Eval.cmd eval) args in
  help, vers, Cmdliner_def.Eval.with_cmd eval cmd

let run_parser ~catch eval cl f =
  try (f eval cl :> ('a, eval_result_error) result) with
  | exn when catch ->
      let bt = Printexc.get_raw_backtrace () in
      Error (`Exn (exn, bt))

let try_eval_stdopts ~catch eval cline help version : 'a eval_result option =
  match run_parser ~catch eval cline (Cmdliner_term.parser help) with
  | Ok (Some fmt) -> Some (Error (`Std_help fmt))
  | Error (`Parse _) ->
      (* only [FMT] errored, there was a `--help`, show help anyways *)
      Some (Error (`Std_help `Auto))
  | Error _ as err -> (Some err :> 'a eval_result option)
  | Ok None ->
      match version with
      | None -> None
      | Some version ->
          match (run_parser ~catch eval cline (Cmdliner_term.parser version))
          with
          | Ok false -> None
          | Ok true -> Some (Error (`Std_version))
          | Error _ as err -> (Some err :> 'a eval_result option)

let do_help ~env help_ppf err_ppf eval fmt cmd_name =
  let eval = match cmd_name with
  | None (* help of main command requested *)  ->
      let env _ = assert false in
      let cmd = Cmdliner_def.Eval.main eval in
      let subcmds = Cmdliner_def.Eval.subcmds eval in
      let eval' =
        Cmdliner_def.Eval.make ~ancestors:[] ~cmd ~subcmds ~env ~err_ppf
      in
      begin match Cmdliner_def.Eval.ancestors eval with
      | [] -> (* [ei] is an evaluation of main, [cmd] has stdopts *) eval'
      | _ -> let _, _, eval' = add_stdopts eval' in eval'
      end
  | Some cmd ->
      try
        (* For now we simply keep backward compat. [cmd] should be
           a name from main's children. *)
        let main = Cmdliner_def.Eval.main eval in
        let is_cmd t = Cmdliner_def.Cmd_info.name t = cmd in
        let children = Cmdliner_def.Cmd_info.children main in
        let cmd = List.find is_cmd children in
        let _, _, eval = add_stdopts (Cmdliner_def.Eval.with_cmd eval cmd) in
        eval
      with Not_found -> invalid_arg (err_help cmd)
  in
  Cmdliner_docgen.pp_man ~env ~errs:err_ppf fmt help_ppf eval

let do_result ~env help_ppf err_ppf eval = function
| Ok v -> Ok (`Ok v)
| Error res ->
    match res with
    | `Std_help fmt ->
        Cmdliner_docgen.pp_man ~env ~errs:err_ppf fmt help_ppf eval; Ok `Help
    | `Std_version ->
        Cmdliner_msg.pp_version help_ppf eval; Ok `Version
    | `Parse err ->
        Cmdliner_msg.pp_usage_and_err err_ppf eval ~err; Error `Parse
    | `Complete (comp, cline) ->
        Cmdliner_completion.output ~out_ppf:help_ppf ~err_ppf eval comp cline;
        Ok `Help
    | `Help (fmt, cmd_name) ->
        do_help ~env help_ppf err_ppf eval fmt cmd_name; Ok `Help
    | `Exn (e, bt) ->
        Cmdliner_msg.pp_backtrace err_ppf eval e bt; (Error `Exn)
    | `Error (usage, err) ->
        (if usage
         then Cmdliner_msg.pp_usage_and_err err_ppf eval ~err
         else Cmdliner_msg.pp_err err_ppf eval ~err);
        Error `Term

let do_deprecated_msgs ~env err_ppf cl eval =
  let cmd_info = Cmdliner_def.Eval.cmd eval in
  let deprecated = Cmdliner_def.Cline.deprecated ~env cl in
  match Cmdliner_def.Cmd_info.deprecated cmd_info, deprecated with
  | None, [] -> ()
  | depr_cmd, deprs ->
      let open Cmdliner_base in
      let pp_sep ppf () =
        if Option.is_some depr_cmd && deprs <> [] then Fmt.cut ppf ();
      in
      let subst = Cmdliner_def.Eval.doclang_subst eval in
      let pp_cmd_msg ppf cmd =
        match
          Cmdliner_def.Cmd_info.styled_deprecated ~subst ~errs:err_ppf cmd
        with
        | "" -> ()
        | msg ->
            let name = Cmdliner_def.Cmd_info.name cmd in
            Fmt.pf ppf "@[%a command %a:@[ %a@]@]"
              Fmt.deprecated () Fmt.code_or_quote name Fmt.styled_text msg
      in
      let pp_deprs = Fmt.list (Cmdliner_def.Cline.pp_deprecated ~subst) in
      Fmt.pf err_ppf "@[%a @[<v>%a%a%a@]@]@."
        Cmdliner_msg.pp_exec_msg eval pp_cmd_msg cmd_info
        pp_sep () pp_deprs deprs

let find_cmd_and_parser ~legacy_prefixes ~for_completion args cmd =
  (* This finds the command to use if it's a group and [for_completion]
     is [true] whether we may need to add the subcommand names to the
     completions. *)
  let stop ~ancestors ~cmd args = match (cmd : 'a Cmdliner_cmd.t) with
  | Cmd (_, parser) -> ancestors, cmd, args, Ok parser
  | Group (_, (Some parser, _)) -> ancestors, cmd, args, Ok parser
  | Group (_, (None, children)) ->
      let dom = Cmdliner_cmd.list_names children in
      let err = Cmdliner_msg.err_cmd_missing ~dom in
      let try_stdopts = true in
      ancestors, cmd, args, Error (`Parse (try_stdopts, err))
  in
  let rec loop ~ancestors ~current_cmd = function
  | "--" :: _ | [] as args -> stop ~ancestors ~cmd:current_cmd args
  | arg :: _ as args when for_completion &&
                          Cmdliner_cline.has_complete_prefix arg ->
      begin match current_cmd with
      | Cmd _ -> (* arg completion *) stop ~ancestors ~cmd:current_cmd args
      | Group (_, (parser, _))  ->
          let is_opt = Cmdliner_cline.(is_opt (get_token_to_complete arg)) in
          if not is_opt then ancestors, current_cmd, args, Error `Complete else
          stop ~ancestors ~cmd:current_cmd args
      end
  | arg :: _ as args when Cmdliner_cline.is_opt arg ->
      stop ~ancestors ~cmd:current_cmd args
  | arg :: rest as args ->
      match current_cmd with
      | Cmd (i, parser) -> ancestors, current_cmd, args, Ok parser
      | Group (i, (_, children)) ->
          let cmd_index = Cmdliner_cmd.name_trie children in
          match Cmdliner_trie.find ~legacy_prefixes cmd_index arg with
          | Ok cmd -> loop ~ancestors:(i :: ancestors) ~current_cmd:cmd rest
          | Error `Not_found ->
              let all = Cmdliner_trie.ambiguities cmd_index "" in
              let hints = Cmdliner_base.suggest arg all in
              let dom = Cmdliner_cmd.list_names children in
              let kind = "command" in
              let err = Cmdliner_base.err_unknown ~kind ~dom ~hints arg in
              let try_stdopts =
                (* When one writes [cmd no_such_cmd --help] it's better
                   to show the unknown command error message rather
                   than get into the help of the parent command. Otherwise
                   one gets confused into thinking the command exists and/or
                   annoyed not to be reading the right man page. *)
                false
              in
              ancestors, current_cmd, args, Error (`Parse (try_stdopts, err))
          | Error `Ambiguous (* Only on legacy prefixes *)  ->
              let ambs = Cmdliner_trie.ambiguities cmd_index arg in
              let ambs = List.sort compare ambs in
              let err = Cmdliner_base.err_ambiguous ~kind:"command" arg ~ambs in
              let try_stdopts = false in
              ancestors, current_cmd, args, Error (`Parse (try_stdopts, err))
  in
  loop ~ancestors:[] ~current_cmd:cmd args

let cli_args_of_argv argv = match Array.to_list argv with
| exec :: "--__complete" :: args -> true, args
| exec :: args -> false, args
| [] -> invalid_arg err_argv

let eval_value
    ?help:(help_ppf = Format.std_formatter)
    ?err:(err_ppf = Format.err_formatter)
    ?(catch = true) ?(env = Sys.getenv_opt) ?(argv = Sys.argv) cmd
  =
  let legacy_prefixes = Cmdliner_trie.legacy_prefixes ~env in
  let for_completion, args = cli_args_of_argv argv in
  let ancestors, cmd, args, parser =
    find_cmd_and_parser ~legacy_prefixes ~for_completion args cmd
  in
  let help, version, eval =
    let subcmds = Cmdliner_cmd.get_children_infos cmd in
    let cmd = Cmdliner_cmd.get_info cmd in
    let eval = Cmdliner_def.Eval.make ~ancestors ~cmd ~subcmds ~env ~err_ppf in
    add_stdopts eval
  in
  let cline =
    let args_info = Cmdliner_def.Cmd_info.args (Cmdliner_def.Eval.cmd eval) in
    Cmdliner_cline.create ~legacy_prefixes ~for_completion args_info args
  in
  let res = match parser with
  | Error (`Parse (try_stdopts, msg)) ->
      (* Command lookup error, we may still prioritize stdargs *)
      begin match cline with
      | `Complete c -> Error (`Complete c)
      | `Error (_, cl) | `Ok cl ->
          let stdopts =
            if try_stdopts
            then try_eval_stdopts ~catch eval cl help version else None
          in
          begin match stdopts with
          | None -> Error (`Error (true, msg))
          | Some e -> e
          end
      end
  | Error `Complete ->
      begin match cline with
      | `Complete (comp, cline) ->
          let comp = Cmdliner_def.Complete.add_subcmds comp in
          Error (`Complete (comp, cline))
      | `Ok _ | `Error _ -> assert false
      end
  | Ok parser ->
      begin match cline with
      | `Complete c -> Error (`Complete c)
      | `Error (e, cl) ->
          begin match try_eval_stdopts ~catch eval cl help version with
          | Some e -> e
          | None -> Error (`Error (true, e))
          end
      | `Ok cl ->
          match try_eval_stdopts ~catch eval cl help version with
          | Some e -> e
          | None ->
              do_deprecated_msgs ~env err_ppf cl eval;
              (run_parser ~catch eval cl parser :> 'a eval_result)
      end
  in
  do_result ~env help_ppf err_ppf eval res

let eval_peek_opts
    ?(version_opt = false) ?(env = Sys.getenv_opt) ?(argv = Sys.argv) t
  : 'a option * ('a eval_ok, eval_error) result
  =
  let legacy_prefixes = Cmdliner_trie.legacy_prefixes ~env in
  let for_completion, args = cli_args_of_argv argv in
  let version = if version_opt then Some "dummy" else None in
  let cmd_info, parser =
    let args, parser = Cmdliner_term.argset t, Cmdliner_term.parser t in
    let cmd_info = Cmdliner_def.Cmd_info.make ?version "dummy" in
    Cmdliner_def.Cmd_info.add_args cmd_info args, parser
  in
  let help, version, eval =
    let err_ppf = Format.make_formatter (fun _ _ _ -> ()) (fun () -> ()) in
    let ancestors = [] and cmd = cmd_info and subcmds = [] in
    let eval = Cmdliner_def.Eval.make ~ancestors ~cmd ~subcmds ~env ~err_ppf in
    add_stdopts eval
  in
  let cline =
    let arg_infos = Cmdliner_def.Cmd_info.args (Cmdliner_def.Eval.cmd eval) in
    Cmdliner_cline.create
      ~peek_opts:true ~legacy_prefixes ~for_completion arg_infos args
  in
  let v, ret = match cline with
  | `Complete comp -> None, (Error (`Complete comp))
  | `Error (e, cl) ->
      begin match try_eval_stdopts ~catch:true eval cl help version with
      | Some e -> None, e
      | None -> None, Error (`Error (true, e))
      end
  | `Ok cl ->
      let ret = run_parser ~catch:true eval cl parser in
      let v = match ret with Ok v -> Some v | Error _ -> None in
      begin match try_eval_stdopts ~catch:true eval cl help version with
      | Some e -> v, e
      | None -> v, (ret :> 'a eval_result)
      end
  in
  let ret = match ret with
  | Ok v -> Ok (`Ok v)
  | Error `Std_help _ -> Ok `Help
  | Error `Std_version -> Ok `Version
  | Error `Parse _ -> Error `Parse
  | Error `Help _ -> Ok `Help
  | Error `Complete _ -> Ok `Help
  | Error `Exn _ -> Error `Exn
  | Error `Error _ -> Error `Term
  in
  (v, ret)

let exit_status_of_result ?(term_err = Cmdliner_def.Exit.cli_error) = function
| Ok (`Ok _ | `Help | `Version) -> Cmdliner_def.Exit.ok
| Error `Term -> term_err
| Error `Parse -> Cmdliner_def.Exit.cli_error
| Error `Exn -> Cmdliner_def.Exit.internal_error

let eval_value' ?help ?err ?catch ?env ?argv ?term_err cmd =
  match eval_value ?help ?err ?catch ?env ?argv cmd with
  | Ok (`Ok _ as v) -> v
  | ret -> `Exit (exit_status_of_result ?term_err ret)

let eval ?help ?err ?catch ?env ?argv ?term_err cmd =
  exit_status_of_result ?term_err @@
  eval_value ?help ?err ?catch ?env ?argv cmd

let eval' ?help ?err ?catch ?env ?argv ?term_err cmd =
  match eval_value ?help ?err ?catch ?env ?argv cmd with
  | Ok (`Ok c) -> c
  | r -> exit_status_of_result ?term_err r

let pp_err ppf cmd ~msg =
  (* Here instead of Cmdliner_msgs to avoid circular dep *)
  let name = Cmdliner_cmd.name cmd in
  Cmdliner_base.Fmt.pf ppf "%s: @[%a@]@." name Cmdliner_base.Fmt.lines msg

let eval_result
    ?help ?(err = Format.err_formatter) ?catch ?env ?argv ?term_err cmd
  =
  match eval_value ?help ~err ?catch ?env ?argv cmd with
  | Ok (`Ok (Error msg)) -> pp_err err cmd ~msg; Cmdliner_def.Exit.some_error
  | r -> exit_status_of_result ?term_err r

let eval_result'
    ?help ?(err = Format.err_formatter) ?catch ?env ?argv ?term_err cmd
  =
  match eval_value ?help ~err ?catch ?env ?argv cmd with
  | Ok (`Ok (Ok c)) -> c
  | Ok (`Ok (Error msg)) -> pp_err err cmd ~msg; Cmdliner_def.Exit.some_error
  | r -> exit_status_of_result ?term_err r
end
module Cmdliner : sig
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

(** Declarative definition of command line interfaces.

    Consult the {{!page-tutorial}tutorial}, the
    {{!page-cookbook}cookbook}, program
    {{!page-cookbook.blueprints}blueprints} and
    {{!page-cookbook.tip_src_structure}source structure}, details about the
    supported {{!page-cli}command line syntax} and
    {{!page-examples}examples} of use.

    Open the module to use it, it defines only these modules in your
    scope. *)

(** Man pages.

    Man page generation is automatically handled by [Cmdliner], see
    the {{!page-tool_man.manual}details}. The {!Manpage.block} type is
    used to define a man page's content. It's a good idea to follow
    the {{!Manpage.standard_sections}standard} manual page structure.

   {b References.}
   {ul
   {- [man-pages(7)], {{:http://man7.org/linux/man-pages/man7/man-pages.7.html}
      {e Conventions for writing Linux man pages}}.}} *)
module Manpage : sig

  (** {1:man Man pages} *)

  type section_name = string
  (** The type for section names (titles). See
      {{!standard_sections}standard section names}. *)

  type block =
  [ `S of section_name (** Start a new section with given name. *)
  | `P of string (** Paragraph with given text. *)
  | `Pre of string (** Preformatted paragraph with given text. *)
  | `I of string * string (** Indented paragraph with given label and text. *)
  | `Noblank (** Suppress blank line introduced between two blocks. *)
  | `Blocks of block list (** Splice given blocks. *) ]
  (** The type for a block of man page text.

      Except in [`Pre], whitespace and newlines are not significant
      and are all collapsed to a single space. All block strings
      support the {{!page-tool_man.doclang}documentation markup language}.*)

  val escape : string -> string
  (** [escape s] escapes [s] so that it doesn't get interpreted by the
      {{!page-tool_man.doclang}documentation markup language}. *)

  type title = string * int * string * string * string
  (** The type for man page titles. Describes the man page
      [title], [section], [center_footer], [left_footer], [center_header]. *)

  type t = title * block list
  (** The type for a man page. A title and the page text as a list of blocks. *)

  type xref =
  [ `Main (** Refer to the man page of the program itself. *)
  | `Cmd of string (** Refer to the command [cmd] of the tool, which must
                       exist. *)
  | `Tool of string (** Tool refer to the given command line tool. *)
  | `Page of string * int (** Refer to the manpage [name(sec)]. *) ]
  (** The type for man page cross-references. *)

  (** {1:standard_sections Standard section names and content}

      The following are standard man page section names, roughly ordered
      in the order they conventionally appear. See also
      {{:http://man7.org/linux/man-pages/man7/man-pages.7.html}[man man-pages]}
      for more elaborations about what sections should contain. *)

  val s_name : section_name
  (** The [NAME] section. This section is automatically created by
      [Cmdliner] for your command. *)

  val s_synopsis : section_name
  (** The [SYNOPSIS] section. By default this section is automatically
      created by [Cmdliner] for your command, unless it is the first
      section of your term's man page, in which case it will replace
      it with yours. *)

  val s_description : section_name
  (** The [DESCRIPTION] section. This should be a description of what
      the tool does and provide a little bit of command line usage and
      documentation guidance. *)

  val s_commands : section_name
  (** The [COMMANDS] section. By default subcommands get listed here. *)

  val s_arguments : section_name
  (** The [ARGUMENTS] section. By default positional arguments get
      listed here. *)

  val s_options : section_name
  (** The [OPTIONS] section. By default optional arguments get
      listed here. *)

  val s_common_options : section_name
  (** The [COMMON OPTIONS] section. By default help and version options get
      listed here. For programs with multiple commands, optional arguments
      common to all commands can be added here. *)

  val s_exit_status : section_name
  (** The [EXIT STATUS] section. By default term status exit codes
      get listed here. *)

  val s_environment : section_name
  (** The [ENVIRONMENT] section. By default environment variables get
      listed here. *)

  val s_environment_intro : block
  (** [s_environment_intro] is the introduction content used by cmdliner
      when it creates the {!s_environment} section. *)

  val s_files : section_name
  (** The [FILES] section. *)

  val s_bugs : section_name
  (** The [BUGS] section. *)

  val s_examples : section_name
  (** The [EXAMPLES] section. *)

  val s_authors : section_name
  (** The [AUTHORS] section. *)

  val s_see_also : section_name
  (** The [SEE ALSO] section. *)

  val s_none : section_name
  (** [s_none] is a special section named ["cmdliner-none"] that can be used
      whenever you do not want something to be listed. *)

  (** {1:output Output}

    The {!print} function can be useful if the client wants to define
    other man pages (e.g. to implement a help command). *)

  type format =
  [ `Auto (** Format like [`Pager] or [`Plain] whenever the [TERM]
              environment variable is [dumb] or unset. *)
  | `Pager (** {{!page-cli.help}Tries} to use a pager or falls back
               to [`Plain]. *)
  | `Plain (** Format to plain text. *)
  | `Groff (** Format to groff commands. *) ]
  (** The type for man page output specification. *)

  val print :
    ?env:(string -> string option) -> ?errs:Format.formatter ->
    ?subst:(string -> string option) -> format -> Format.formatter -> t -> unit
  (** [print ~env ~errs ~subst fmt ppf page] prints [page] on [ppf] in the
      format [fmt].
      {ul
      {- [env] is used to lookup environment for driving paging when the
         format is [`Pager]. Defaults to {!Sys.getenv_opt}.}
      {- [subst] can be used to perform variable
         substitution (defaults to the identity).}
      {- [errs] is used to print formatting errors, it defaults to
         {!Format.err_formatter}.}} *)
end

(** Terms.

    A term made of terms referring to {{!Arg.argterms}command line arguments}
    implicitly defines a command line syntax fragment. Terms are associated
    to command values {!Cmd.t} which are
    {{!Cmd.section-eval}evaluated} to eventually produce an
    {{!Cmd.Exit.code}exit code}.

    Nowadays terms are best defined using the {!Cmdliner.Term.Syntax}.
    See examples in the {{!page-cookbook.blueprints}blueprints}. *)
module Term : sig

  (** {1:terms Terms} *)

  type +'a t
  (** The type for terms evaluating to values of type ['a]. *)

  val const : 'a -> 'a t
  (** [const v] is a term that evaluates to [v]. *)

  val app : ('a -> 'b) t -> 'a t -> 'b t
  (** [app f v] is a term that evaluates to the result applying
      the evaluation of [v] to the one of [f]. *)

  val map : ('a -> 'b) -> 'a t -> 'b t
  (** [map f t] is [app (const f) t]. *)

  val product : 'a t -> 'b t  -> ('a * 'b) t
  (** [product t0 t1] is [app (app (map (fun x y -> (x, y)) t0) t1)] *)

  val ( $ ) : ('a -> 'b) t -> 'a t -> 'b t
  (** [f $ v] is {!app}[ f v]. *)

  (** [let] operators.

      See how to use them in the {{!page-cookbook.blueprints}blueprints}. *)
  module Syntax : sig
    val ( let+ ) : 'a t -> ('a -> 'b) -> 'b t
    (** [( let+ )] is {!map}. *)

    val ( and+ ) : 'a t -> 'b t -> ('a * 'b) t
    (** [( and+ )] is {!product}. *)
  end

  (** {1 Interacting with {!Cmd.t} evaluation}

      These special terms allow to interact with the
      {{!Cmd.section-eval_low}low-level evaluation process} performed
      on commands. *)

  val term_result : ?usage:bool -> ('a, [`Msg of string]) result t -> 'a t
  (** [term_result] is such that:
      {ul
      {- [term_result ~usage (Ok v)] {{!Cmd.eval_value}evaluates}
         to [Ok (`Ok v)].}
      {- [term_result ~usage (Error (`Msg e))]
         {{!Cmd.eval_value}evaluates} to [Error `Term] with the error message
         [e] and usage shown according to [usage] (defaults to [false])}}

      See also {!term_result'}. *)

  val term_result' : ?usage:bool -> ('a, string) result t -> 'a t
  (** [term_result'] is like {!term_result} but with a [string]
      error case. *)

  val cli_parse_result : ('a, [`Msg of string]) result t -> 'a t
  (** [cli_parse_result] is such that:
      {ul
      {- [cli_parse_result (Ok v)] {{!Cmd.eval_value}evaluates}
         [Ok (`Ok v)).}
      {- [cli_parse_result (Error (`Msg e))]] {{!Cmd.eval_value}evaluates}
         [Error `Parse].}}
      See also {!cli_parse_result'}. *)

  val cli_parse_result' : ('a, string) result t -> 'a t
  (** [cli_parse_result'] is like {!cli_parse_result} but with a
      [string] error case. *)

  val main_name : string t
  (** [main_name] is a term that evaluates to the main command name;
      that is the name of the tool. *)

  val choice_names : string list t
  (** [choice_names] is a term that evaluates to the names of the commands
      that are children of the main command. *)

  val with_used_args : 'a t -> ('a * string list) t
  (** [with_used_args t] is a term that evaluates to [t] tupled
      with the arguments from the command line that where used to
      evaluate [t]. *)

  type 'a ret =
  [ `Help of Manpage.format * string option
  | `Error of (bool * string)
  | `Ok of 'a ]
  (** The type for command return values. See {!val-ret}. *)

  val ret : 'a ret t -> 'a t
  (** [ret v] is a term whose evaluation depends on the case
      to which [v] evaluates. With :
      {ul
      {- [`Ok v], it evaluates to [v].}
      {- [`Error (usage, e)], the evaluation fails and [Cmdliner] prints
         the error [e] and the term's usage if [usage] is [true].}
      {- [`Help (format, name)], the evaluation fails and [Cmdliner] prints
         a manpage in format [format]. If [name] is [None] this is the
         the main command's manpage. If [name] is [Some c] this is
         the man page of the subcommand [c] of the main command.}} *)

  val env : (string -> string option) t
  (** [env] is the [env] argument given to {{!Cmd.section-eval}command
      evaluation functions}. If you need to refine the environment
      lookup done by Cmdliner's machinery you should use this rather
      than direct calls to {!Sys.getenv_opt}. *)
end

(** Commands.

    Command line syntaxes are implicitely defined by {!Term.t}
    values. A command value binds a term and its documentation to a
    command name.

    A command can group a list of subcommands (and recursively). In this
    case your tool defines a tree of commands, each with its own command
    line syntax. The root of that tree is called the {e main command};
    it represents your tool and its name. *)
module Cmd : sig

  (** {1:info Command information}

      Command information defines the name and documentation of a command. *)

  (** Exit codes and their information. *)
  module Exit : sig

    (** {1:codes Exit codes} *)

    type code = int
    (** The type for exit codes.

        {b Warning.} You should avoid status codes strictly greater than 125
        as those may be used by
        {{:https://www.gnu.org/software/bash/manual/html_node/Exit-Status.html}
        some} shells. *)

    (** {2:predefined Predefined codes}

        These are documented by {!defaults}. *)

    val ok : code
    (** [ok] is [0], the exit status for success. *)

    val some_error : code
    (** [some_error] is [123], an exit status for indiscriminate errors
        reported on [stderr]. *)

    val cli_error : code
    (** [cli_error] is [124], an exit status for command line parsing
        errors. *)

    val internal_error : code
    (** [internal_error] is [125], an exit status for unexpected internal
        errors. *)

    (** {1:info Exit code information} *)

    type info
    (** The type for exit code information. *)

    val info :
      ?docs:Manpage.section_name -> ?doc:string -> ?max:code -> code -> info
    (** [info ~docs ~doc min ~max] describe the range of exit
        statuses from [min] to [max] (defaults to [min]).
        {ul
        {- [doc] is the man page information for the statuses,
           defaults to ["undocumented"]. The
           {{!page-tool_man.doclang}documentation markup language}
           can be used with following variables:
           {ul
           {- [$(status)], the value of [min].}
           {- [$(status_max)], the value of [max].}
           {- The variables mentioned in the documentation of
              {!Cmd.val-info}}}}
        {- [docs] is the title of the man page section in which the statuses
           will be listed, it defaults to {!Manpage.s_exit_status}.}} *)

    val info_code : info -> code
    (** [info_code i] is the minimal code of [i]. *)

    val defaults : info list
    (** [defaults] are exit code information for {!ok}, {!some_error},
        {!cli_error} and {!internal_error}. *)
  end

  (** Environment variable and their information. *)
  module Env : sig

    (** {1:envvars Environment variables} *)

    type var = string
    (** The type for environment variable names. *)

    (** {1:info Environment variable information} *)

    type info
    (** The type for environment variable information. *)

    val info :
      ?deprecated:string -> ?docs:Manpage.section_name -> ?doc:string -> var ->
      info
    (** [info ~docs ~doc var] describes an environment variable
        [var] such that:
        {ul
        {- [doc] is the man page information of the environment
            variable, defaults to ["See option $(opt)."].}
        {- [docs] is the title of the man page section in which the environment
          variable will be listed, it defaults to
          {!Cmdliner.Manpage.s_environment}.}
        {- [deprecated], if specified the environment variable is
           deprecated.  Use of the variable warns on dep[stderr] This
           message which should be a capitalized sentence is
           preprended to [doc] and output on standard error when the
           environment variable ends up being used.}}

        In [doc] and [deprecated] the {{!page-tool_man.doclang}documentation
        markup language} can be used with following variables:

        {ul
        {- [$(opt)], if any the option name of the argument the variable is
           looked up for.}
        {- [$(env)], the value of [var].}
        {- The variables mentioned in the doc string of {!Cmd.val-info}.}} *)

    val info_var : info -> var
    (** [info_var info] is the variable described by [info]. *)
  end

  type info
  (** The type for information about commands. *)

  val info :
    ?deprecated:string -> ?man_xrefs:Manpage.xref list ->
    ?man:Manpage.block list -> ?envs:Env.info list -> ?exits:Exit.info list ->
    ?sdocs:Manpage.section_name -> ?docs:Manpage.section_name -> ?doc:string ->
    ?version:string -> string -> info
  (** [info ?sdocs ?man ?docs ?doc ?version name] is a term information
      such that:
      {ul
      {- [name] is the name of the command.}
      {- [version] is the version string of the command line tool, this
         is only relevant for the main command and ignored otherwise.}
      {- [deprecated], if specified the command is deprecated. Use of the
          variable warns on [stderr]. This
          message which should be a capitalized sentence is
          preprended to [doc] and output on standard error when the
          environment variable ends up being used.}
      {- [doc] is a one line description of the command used
         for the [NAME] section of the command's man page and in command
         group listings.}
      {- [docs], for commands that are part of a group, the title of the
         section of the parent's command man page where it should be listed
         (defaults to {!Manpage.s_commands}).}
      {- [sdocs] defines the title of the section in which the
         standard [--help] and [--version] arguments are listed
         (defaults to {!Manpage.s_common_options}).}
      {- [exits] is a list of exit statuses that the command evaluation
         may produce, defaults to {!Exit.defaults}.}
      {- [envs] is a list of environment variables that influence
         the command's evaluation.}
      {- [man] is the text of the man page for the command.}
      {- [man_xrefs] are cross-references to other manual pages. These
         are used to generate a {!Manpage.s_see_also} section.}}

      [doc], [deprecated], [man], [envs], [exits] support the
      {{!page-tool_man.doclang} documentation markup language} in which the
      following variables are recognized:

      {ul
      {- [$(tool)] the main, topmost, command name.}
      {- [$(cmd)] the command invocation from main command to the
         command name.}
      {- [$(cmd.name)] the command's name.}
      {- [$(cmd.parent)] the command's parent or the main command if none.}}

      Previously some of these names were refered to as [$(tname)],
      [$(mname)] and [$(iname)], they still work but do not use them,
      they are obscure. *)


  (** {1:cmds Commands} *)

  type 'a t
  (** The type for commands whose evaluation result in a value of
      type ['a]. *)

  val make : info -> 'a Term.t -> 'a t
  (** [make i t] is a command with information [i] and command line syntax
      parsed by [t]. *)

  val v : info -> 'a Term.t -> 'a t
  (** [v] is an old name for {!make} which should be preferred. *)

  val group : ?default:'a Term.t -> info -> 'a t list -> 'a t
  (** [group i ?default cmds] is a command with information [i] that
      groups subcommands [cmds]. [default] is the command line syntax
      to parse if no subcommand is specified on the command line. If
      [default] is [None] (default), the tool errors when no subcommand
      is specified. *)

  val name : 'a t -> string
  (** [name c] is the name of [c]. *)

  (** {1:eval Evaluation}

      Read {!page-cookbook.cmds_which_eval} in the cookbook if you
      struggle to choose between this menagerie of evaluation
      functions.

      These functions are meant to be composed with {!Stdlib.exit}.
      The following exit codes may be returned by all these functions:
      {ul
      {- {!Exit.cli_error} if a parse error occurs.}
      {- {!Exit.internal_error} if the [~catch] argument is [true] (default)
         and an uncaught exception is raised.}
      {- The value of [~term_err] (defaults to {!Exit.cli_error}) if
         a term error occurs.}}

      These exit codes are described in {!Exit.defaults} which is the
      default value of the [?exits] argument of the function {!val-info}. *)

  val eval :
    ?help:Format.formatter -> ?err:Format.formatter -> ?catch:bool ->
    ?env:(string -> string option) -> ?argv:string array ->
    ?term_err:Exit.code -> unit t -> Exit.code
  (** [eval cmd] is {!Exit.ok} if [cmd] evaluates to [()].
      See {!eval_value} for other arguments. *)

  val eval' :
    ?help:Format.formatter -> ?err:Format.formatter -> ?catch:bool ->
    ?env:(string -> string option) -> ?argv:string array ->
    ?term_err:Exit.code -> Exit.code t -> Exit.code
  (** [eval' cmd] is [c] if [cmd] evaluates to the exit code [c].
      See {!eval_value} for other arguments. *)

  val eval_result :
    ?help:Format.formatter -> ?err:Format.formatter -> ?catch:bool ->
    ?env:(string -> string option) -> ?argv:string array ->
    ?term_err:Exit.code -> (unit, string) result t -> Exit.code
  (** [eval_result cmd] is:
      {ul
      {- {!Exit.ok} if [cmd] evaluates to [Ok ()].}
      {- {!Exit.some_error} if [cmd] evaluates to [Error msg]. In this
         case [msg] is printed on [err].}}
      See {!eval_value} for other arguments. *)

  val eval_result' :
    ?help:Format.formatter -> ?err:Format.formatter -> ?catch:bool ->
    ?env:(string -> string option) -> ?argv:string array ->
    ?term_err:Exit.code -> (Exit.code, string) result t -> Exit.code
  (** [eval_result' cmd] is:
      {ul
      {- [c] if [cmd] evaluates to [Ok c].}
      {- {!Exit.some_error} if [cmd] evaluates to [Error msg]. In this
         case [msg] is printed on [err].}}
      See {!eval_value} for other arguments. *)

  (** {2:eval_low Low level evaluation}

      This interface gives more information on command evaluation results
      and lets you choose how to map evaluation results to exit codes.
      All evaluation functions are wrappers around {!eval_value}. *)

  type 'a eval_ok =
  [ `Ok of 'a (** The term of the command evaluated to this value. *)
  | `Version (** The version of the main cmd was requested. *)
  | `Help (** Help was requested. *) ]
  (** The type for successful evaluation results. *)

  type eval_error =
  [ `Parse (** A parse error occurred. *)
  | `Term (** A term evaluation error occurred. *)
  | `Exn (** An uncaught exception occurred. *) ]
  (** The type for erroring evaluation results. *)

  val eval_value :
    ?help:Format.formatter -> ?err:Format.formatter -> ?catch:bool ->
    ?env:(string -> string option) -> ?argv:string array -> 'a t ->
    ('a eval_ok, eval_error) result
  (** [eval ~help ~err ~catch ~env ~argv cmd] is the evaluation result
      of [cmd] with:
      {ul
      {- [argv] the command line arguments to parse (defaults to {!Sys.argv})}
      {- [env] the function used for environment variable lookup (defaults
         to {!Sys.getenv}).}
      {- [catch] if [true] (default) uncaught exceptions
         are intercepted and their stack trace is written to the [err]
         formatter}
      {- [help] is the formatter used to print help, version messages
         or completions, (defaults to {!Format.std_formatter}). Note
         that the completion protocol needs to output ['\n'] line ending,
         if you are outputing to a channel make sure it is in binary
         mode to avoid newline translation (this is done automatically
         before completion when [help] is {!Format.std_formatter}).}
      {- [err] is the formatter used to print error messages
         (defaults to {!Format.err_formatter}).}} *)

  type 'a eval_exit =
  [ `Ok of 'a (** The term of the command evaluated to this value. *)
  | `Exit of Exit.code (** The evaluation wants to exit with this code. *) ]
  (** The type for evaluation exits. *)

  val eval_value' :
    ?help:Format.formatter -> ?err:Format.formatter -> ?catch:bool ->
    ?env:(string -> string option) -> ?argv:string array -> ?term_err:int ->
    'a t -> 'a eval_exit
  (** [eval_value'] is like {!eval_value}, but if the command term
      does not evaluate to [Ok (`Ok v)], returns an exit code like the
      higher-level {{!val-eval}evaluation} functions do (which can be
      {!Exit.ok} in case help or version was requested). *)

  val eval_peek_opts :
    ?version_opt:bool -> ?env:(string -> string option) ->
    ?argv:string array -> 'a Term.t ->
    'a option * ('a eval_ok, eval_error) result
  (** {b WARNING.} You are highly encouraged not to use this
      function it may be removed in the future.

      [eval_peek_opts version_opt argv t] evaluates [t], a term made
      of optional arguments only, with the command line [argv]
      (defaults to {!Sys.argv}). In this evaluation, unknown optional
      arguments and positional arguments are ignored.

      The evaluation returns a pair. The first component is
      the result of parsing the command line [argv] stripped from
      any help and version option if [version_opt] is [true] (defaults
      to [false]). It results in:
      {ul
      {- [Some _] if the command line would be parsed correctly given the
         {e partial} knowledge in [t].}
      {- [None] if a parse error would occur on the options of [t]}}

      The second component is the result of parsing the command line
      [argv] without stripping the help and version options. It
      indicates what the evaluation would result in on [argv] given
      the partial knowledge in [t] (for example it would return
      [`Help] if there's a help option in [argv]). However in
      contrasts to {!val-eval_value} no side effects like error
      reporting or help output occurs.

      {b Note.} Positional arguments can't be peeked without the full
      specification of the command line: we can't tell apart a
      positional argument from the value of an unknown optional
      argument. *)
end

(** Terms for command line arguments.

    This module provides functions to define terms that evaluate
    to the arguments provided on the command line.

    Basic constraints, like the argument type or repeatability, are
    specified by defining a value of type {!Arg.t}. Further constraints can
    be specified during the {{!Arg.argterms}conversion} to a term. *)
module Arg : sig

  (** {1:argconv Argument converters} *)

  (** Argument completion.

      This module provides a type to describe how positional and
      optional argument values of {{!Arg.type-conv}argument
      converters} can be completed. It defines which completion
      directives from the {{!page-cli.completion_protocol}protocol}
      get emitted by your tool for the argument.

      {b Note.} Subcommand and option name are completed
      automatically by the library itself and
      {{!Cmdliner.Arg.predef}prefined argument converters} already
      have completions built-in whenever appropriate. *)
  module Completion : sig

    (** {1:directives Completion directives} *)

    type 'a directive
    (** The type for a completion directive for values of type ['a]. *)

    val value : ?doc:string -> 'a -> 'a directive
    (** [value v ~doc] indicates that the token to complete could be
        replaced by the value [v] as serialized by the argument's
        formatter {!Conv.pp}. [doc] is ANSI styled UTF-8 text
        documenting the value, defaults to [""]. *)

    val string : ?doc:string -> string -> 'a directive
    (** [string s ~doc] indicates that the token to complete could be
        replaced by the string [s]. [doc] is ANSI styled UTF-8 text
        documenting the value, defaults to [""]. *)

    val files : 'a directive
    (** [files] indicates that the token to complete could be replaced
        with files that the shell deems suitable. *)

    val dirs : 'a directive
    (** [dirs] indicates that the token to complete could be replaced with
        directories that the shell deems suitable. *)

    val restart : 'a directive
    (** [restart] indicates that the shell should restart the completion
        after the positional disambiguation token [--].

        This is typically used for tools that end-up invoking other
        tools like [sudo -- TOOL [ARG]]. For the latter a restart
        completion should be added on all positional arguments.  If
        you allow [TOOL] to be only a restricted set of tools known to
        your program you'd eschew [restart] on the first postional
        argument but add it to the remaining ones.

        {b Warning.} A [restart] directive is eventually emited only
        if the completion is requested after a [--] token. In this
        case other completions returned alongside by {!func} are
        ignored. Educate your users to use the [--], for example
        mention them in {{!page-cookbook.manpage_synopsis}user defined
        synopses}, it is good cli specification hygiene as it properly
        delineates argument scopes. *)

    val message : string -> 'a directive
    (** [message s] is a multi-line, ANSI styled, UTF-8 message reported
        to end users. *)

    val raw : string -> 'a directive
    (** [raw s] takes over the whole {{!page-cli.completion_protocol}protocol}
        output (including subcommand and option name completion) with [s],
        you are in charge. Any other directive in the result of {!func}
        is ignored.

        {b Warning.} The protocol is unstable, it is not advised to
        output it yourself. However this can be useful to invoke
        another tool according to the protocol in the completion
        function and treat its result as the requested completion. *)

    (** {1:completion Completion} *)

    type ('ctx, 'a) func =
      'ctx option -> token:string -> ('a directive list, string) result
    (** The type for completion functions.

        Given an optional context determined from a partial command
        line parse and a token to complete it returns a list of
        completion directives or an error which is reported to
        end-users by using a protocol {!message}.

        The context is [None] if no context was given to {!make} or if
        the context failed to parse on the current command line. *)

    type 'a complete =
    | Complete : 'ctx Term.t option * ('ctx, 'a) func -> 'a complete (** *)
    (** The type for completing.

        A completion context specification which captures a partial
        command line parse (for example the path to a configuration
        file) and a completion function. *)

    type 'a t
    (** The type for completing values parsed into values of type ['a]. *)

    val make : ?context:'ctx Term.t -> ('ctx, 'a) func -> 'a t
    (** [make ~context func] uses [func] to complete.

        [context] defines a commmand line fragment that is evaluated
        before performing the completion. It the evaluation is
        successful the result is given to the completion
        function. Otherwise [None] is given.

        {b Warning.} [context] must be part of the term of the command
        in which you use the completion otherwise the context will
        always be [None] in the function. *)

    val complete : 'a t -> 'a complete
    (** [complete c] completes with [c]. *)

    val complete_files : 'a t
    (** [complete_files] holds a context insensitive function that
        always returns [Ok \[]{!files}[\]]. *)

    val complete_dirs : 'a t
    (** [complete_dirs] holds a context insensitive function that
        always returns [Ok \[]{!dirs}[\]]. *)

    val complete_paths : 'a t
    (** [complete_paths] holds a context insensitive function that
        always returns [Ok \[]{!files}[;]{!dirs}[\]]. *)

    val complete_restart : 'a t
    (** [complete_dirs] holds a context insensitive function that
        always returns [Ok \[]{!restart}[\]]. *)
  end

  (** Argument converters.

      An argument converter transforms a string argument of the command
      line to an OCaml value. {{!converters}Predefined converters}
      are provided for many types of the standard library. *)
  module Conv : sig

    (** {1:converters Converters} *)

    type 'a parser = string -> ('a, string) result
    (** The type for parsing arguments to values of type ['a]. *)

    type 'a fmt = Format.formatter -> 'a -> unit
    (** The type for formatting values of type ['a]. *)

    type 'a t
    (** The type for converting arguments to values of type ['a]. *)

    val make :
      ?completion:'a Completion.t -> docv:string -> parser:'a parser ->
      pp:'a fmt -> unit -> 'a t
    (** [make ~docv ~parser ~pp ()] is an argument converter with
        given properties. See corresponding accessors for semantics. *)

    val of_conv :
      ?completion:'a Completion.t -> ?docv:string ->
      ?parser:'a parser -> ?pp:'a fmt -> 'a t -> 'a t
    (** [of_conv conv ()] is a new converter with given unspecified
        properties defaulting to those of [conv]. *)

    (** {1:properties Properties} *)

    val docv : 'a t -> string
    (** [docv c] is [c]'s documentation meta-variable. This value can
        be refered to as [$(docv)] in the documentation strings of
        arguments.  It can be overriden by the {!val-info} value of an
        argument. *)

    val parser : 'a t -> 'a parser
    (** [parser c] is [c]'s argument parser. *)

    val pp : 'a t -> 'a fmt
    (** [pp c] is [c]'s argument formatter. *)

    val completion : 'a t -> 'a Completion.t
    (** [completion c] is [c]'s completion. *)
  end

  type 'a conv = 'a Conv.t
  (** The type for argument converters. See the
      {{!predef}predefined converters}. *)

  val some' : ?none:'a -> 'a conv -> 'a option conv
  (** [some' ?none c] is like the converter [c] except it returns
      [Some] value. It is used for command line arguments that default
      to [None] when absent. If provided, [none] is used with [c]'s
      formatter to document the value taken on absence; to document
      a more complex behaviour use the [absent] argument of {!val-info}.
      If you cannot construct an ['a] value use {!some}. *)

  val some : ?none:string -> 'a conv -> 'a option conv
  (** [some ?none c] is like [some'] but [none] is described as a
      string that will be rendered in bold. Use the [absent] argument
      of {!val-info} to document more complex behaviours. *)

  (** {1:arginfo Arguments} *)

  type 'a t
  (** The type for arguments holding data of type ['a]. *)

  type info
  (** The type for information about command line arguments.

      Argument information defines the man page information of an
      argument and, for optional arguments, its names. An environment
      variable can also be specified to read get the argument value from
      if the argument is absent from the command line and the variable
      is defined. *)

  val info :
    ?deprecated:string -> ?absent:string -> ?docs:Manpage.section_name ->
    ?doc_envs:Cmd.Env.info list -> ?docv:string -> ?doc:string ->
    ?env:Cmd.Env.info -> string list -> info
  (** [info docs docv doc env names] defines information for
      an argument.
      {ul
      {- [names] defines the names under which an optional argument
         can be referred to. Strings of length [1] like ["c"]) define
         short option names ["-c"], longer strings like ["count"])
         define long option names ["--count"]. [names] must be empty
         for positional arguments.}
      {- [env] defines the name of an environment variable which is
         looked up for defining the argument if it is absent from the
         command line. See {{!page-cli.envlookup}environment variables} for
         details.}
      {- [doc] is the man page information of the argument.
         {{!doc_helpers}These functions} can help with formatting argument
         values.}
      {- [docv] is for positional and non-flag optional arguments.
         It is a variable name used in the man page to stand for their value.
         If unspecified is taken from the argument converter's, see
         {!Conv.docv}.}
      {- [doc_envs] is a list of environment variable that are
         added to the manual of the command when the argument is used.}
      {- [docs] is the title of the man page section in which the argument
         will be listed. For optional arguments this defaults
         to {!Manpage.s_options}. For positional arguments this defaults
         to {!Manpage.s_arguments}. However a positional argument is only
         listed if it has both a [doc] and [docv] specified.}
      {- [deprecated], if specified the argument is deprecated. Use of the
          variable warns on [stderr]. This
          message which should be a capitalized sentence is
          preprended to [doc] and output on standard error when the
          environment variable ends up being used.}
      {- [absent], if specified a documentation string that indicates
         what happens when the argument is absent. The document language
         can be used like in [doc]. This overrides the automatic default
         value rendering that is performed by the combinators.}}

      In [doc], [deprecated], [absent] the
      {{!page-tool_man.doclang}documentation markup language} can be
      used with following variables:

      {ul
      {- ["$(docv)"] the value of [docv] (see below).}
      {- ["$(opt)"], one of the options of [names], preference
        is given to a long one.}
      {- ["$(env)"], the environment var specified by [env] (if any).}} *)

  val ( & ) : ('a -> 'b) -> 'a -> 'b
  (** [f & v] is [f v], a right associative composition operator for
      specifying argument terms. *)

(** {2:optargs Optional arguments}

    The {{!type-info}information} of an optional argument must have at least
    one name or [Invalid_argument] is raised. *)

  val flag : info -> bool t
  (** [flag i] is a [bool] argument defined by an optional flag
      that may appear {e at most} once on the command line under one of
      the names specified by [i]. The argument holds [true] if the
      flag is present on the command line and [false] otherwise. *)

  val flag_all : info -> bool list t
  (** [flag_all] is like {!flag} except the flag may appear more than
      once. The argument holds a list that contains one [true] value per
      occurrence of the flag. It holds the empty list if the flag
      is absent from the command line. *)

  val vflag : 'a -> ('a * info) list -> 'a t
  (** [vflag v \[v]{_0}[,i]{_0}[;\]] is an ['a] argument defined
      by an optional flag that may appear {e at most} once on
      the command line under one of the names specified in the [i]{_k}
      values. The argument holds [v] if the flag is absent from the
      command line and the value [v]{_k} if the name under which it appears
      is in [i]{_k}.

      {b Note.} Automatic environment variable lookup is unsupported for
      for these arguments but an [env] in an info will be documented.
      Use an option and {!Term.env} for manually looking something up. *)

  val vflag_all : 'a list -> ('a * info) list -> 'a list t
  (** [vflag_all v l] is like {!vflag} except the flag may appear more
      than once. The argument holds the list [v] if the flag is absent
      from the command line. Otherwise it holds a list that contains one
      corresponding value per occurrence of the flag, in the order found on
      the command line.

      {b Note.} Automatic environment variable lookup is unsupported for
      for these arguments but an [env] in an info will be documented.
      Use an option and {!Term.env} for manually looking something up. *)

  val opt : ?vopt:'a -> 'a conv -> 'a -> info -> 'a t
  (** [opt vopt c v i] is an ['a] argument defined by the value of
      an optional argument that may appear {e at most} once on the command
      line under one of the names specified by [i]. The argument holds
      [v] if the option is absent from the command line. Otherwise
      it has the value of the option as converted by [c].

      If [vopt] is provided the value of the optional argument is
      itself optional, taking the value [vopt] if unspecified on the
      command line.  {b Warning} using [vopt] is
      {{!page-cookbook.tip_avoid_default_option_values}not
      recommended}. *)

  val opt_all : ?vopt:'a -> 'a conv -> 'a list -> info -> 'a list t
  (** [opt_all vopt c v i] is like {!opt} except the optional argument may
      appear more than once. The argument holds a list that contains one value
      per occurrence of the flag in the order found on the command line.
      It holds the list [v] if the flag is absent from the command line. *)

  (** {2:posargs Positional arguments}

      The {{!type-info}information} of a positional argument must have no name
      or [Invalid_argument] is raised. Positional arguments indexing
      is zero-based.

      {b Warning.} The following combinators allow to specify and
      extract a given positional argument with more than one term.
      This should not be done as it will likely confuse end users and
      documentation generation. These over-specifications may be
      prevented by raising [Invalid_argument] in the future. But for now
      it is the client's duty to make sure this doesn't happen. *)

  val pos : ?rev:bool -> int -> 'a conv -> 'a -> info -> 'a t
  (** [pos rev n c v i] is an ['a] argument defined by the [n]th
      positional argument of the command line as converted by [c].
      If the positional argument is absent from the command line
      the argument is [v].

      If [rev] is [true] (defaults to [false]), the computed
      position is [max-n] where [max] is the position of
      the last positional argument present on the command line. *)

  val pos_all : 'a conv -> 'a list -> info -> 'a list t
  (** [pos_all c v i] is an ['a list] argument that holds
      all the positional arguments of the command line as converted
      by [c] or [v] if there are none. *)

  val pos_left :
    ?rev:bool -> int -> 'a conv -> 'a list -> info -> 'a list t
  (** [pos_left rev n c v i] is an ['a list] argument that holds
      all the positional arguments as converted by [c] found on the left
      of the [n]th positional argument or [v] if there are none.

      If [rev] is [true] (defaults to [false]), the computed
      position is [max-n] where [max] is the position of
      the last positional argument present on the command line. *)

  val pos_right :
    ?rev:bool -> int -> 'a conv -> 'a list -> info -> 'a list t
  (** [pos_right] is like {!pos_left} except it holds all the positional
      arguments found on the right of the specified positional argument. *)

  (** {2:argterms Converting to terms} *)

  val value : 'a t -> 'a Term.t
  (** [value a] is a term that evaluates to [a]'s value. *)

  val required : 'a option t -> 'a Term.t
  (** [required a] is a term that fails if [a]'s value is [None] and
      evaluates to the value of [Some] otherwise. Use this in combination
      with {!Arg.some'} for required
      positional arguments. {b Warning} using this on optional arguments
      is {{!page-cookbook.tip_avoid_required_opt}not recommended}. *)

  val non_empty : 'a list t -> 'a list Term.t
  (** [non_empty a] is term that fails if [a]'s list is empty and
      evaluates to [a]'s list otherwise. Use this for non empty lists
      of positional arguments. *)

  val last : 'a list t -> 'a Term.t
  (** [last a] is a term that fails if [a]'s list is empty and evaluates
      to the value of the last element of the list otherwise. Use this
      for lists of flags or options where the last occurrence takes precedence
      over the others. *)

  (** {2:predef Predefined arguments} *)

  val man_format : Manpage.format Term.t
  (** [man_format] is a term that defines a [--man-format] option and
      evaluates to a value that can be used with {!Manpage.print}. *)

  (** {1:converters Predefined converters} *)

  val bool : bool conv
  (** [bool] converts values with {!bool_of_string}. *)

  val char : char conv
  (** [char] converts values by ensuring the argument has a single char. *)

  val int : int conv
  (** [int] converts values with {!int_of_string}. *)

  val nativeint : nativeint conv
  (** [nativeint] converts values with {!Nativeint.of_string}. *)

  val int32 : int32 conv
  (** [int32] converts values with {!Int32.of_string}. *)

  val int64 : int64 conv
  (** [int64] converts values with {!Int64.of_string}. *)

  val float : float conv
  (** [float] converts values with {!float_of_string}. *)

  val string : string conv
  (** [string] converts values with the identity function. *)

  val enum : ?docv:string -> (string * 'a) list -> 'a conv
  (** [enum l p] converts values such that string names in [l] map to
      the corresponding value of type ['a]. [docv] is the converter's
      documentation meta-variable, it defaults to [ENUM].  A
      {{!Completion.make}completion} is added for the names.

      {b Warning.} The type ['a] must be comparable with {!Stdlib.compare}.

      @raise Invalid_argument if [l] is empty. *)

  val list : ?sep:char -> 'a conv -> 'a list conv
  (** [list sep c] splits the argument at each [sep] (defaults to [','])
      character and converts each substrings with [c]. *)

  val array : ?sep:char -> 'a conv -> 'a array conv
  (** [array sep c] splits the argument at each [sep] (defaults to [','])
      character and converts each substring with [c]. *)

  val pair : ?sep:char -> 'a conv -> 'b conv -> ('a * 'b) conv
  (** [pair sep c0 c1] splits the argument at the {e first} [sep] character
      (defaults to [',']) and respectively converts the substrings with
      [c0] and [c1]. *)

  val t2 : ?sep:char -> 'a conv -> 'b conv -> ('a * 'b) conv
  (** {!t2} is {!pair}. *)

  val t3 : ?sep:char -> 'a conv ->'b conv -> 'c conv -> ('a * 'b * 'c) conv
  (** [t3 sep c0 c1 c2] splits the argument at the {e first} two [sep]
      characters (defaults to [',']) and respectively converts the
      substrings with [c0], [c1] and [c2]. *)

  val t4 :
    ?sep:char -> 'a conv -> 'b conv -> 'c conv -> 'd conv ->
    ('a * 'b * 'c * 'd) conv
  (** [t4 sep c0 c1 c2 c3] splits the argument at the {e first} three [sep]
      characters (defaults to [',']) respectively converts the substrings
      with [c0], [c1], [c2] and [c3]. *)

  (** {2:files Files and directories} *)

  val path : string conv
  (** [path] is like {!string} but prints using {!Filename.quote}
      and completes both files and directories. *)

  val filepath : string conv
  (** [filepath] is like {!string} but prints using {!Filename.quote}
      and completes files. *)

  val dirpath : string conv
  (** [dirpath] is like {!string} but prints using {!Filename.quote}
      and completes directories. *)

  (** {b Note.} The following converters report errors whenever the
      requested file system object does not exist. This is only mildly
      useful since nothing guarantees they will still exist at the
      time you act upon them. So you will have to treat these error
      cases anyways in your tool function. It is also unhelpful if the file
      system object may be created by your tool. Rather use
      {!filepath} and {!dirpath}. *)

  val file : string conv
  (** [file] converts a value with the identity function and checks
      with {!Sys.file_exists} that a file with that name exists.  The
      string ["-"] is parsed without checking: it represents [stdio].
      It completes both files directories. *)

  val dir : string conv
  (** [dir] converts a value with the identity function and checks
      with {!Sys.file_exists} and {!Sys.is_directory} that a directory
      with that name exists. It completes directories. *)

  val non_dir_file : string conv
  (** [non_dir_file] converts a value with the identity function and
      checks with {!Sys.file_exists} and {!Sys.is_directory} that a
      non directory file with that name exists. The string ["-"] is
      parsed without checking it represents [stdio].  It completes
      files. *)

  (** {1:doc_helpers Documentation formatting helpers} *)

  val doc_quote : string -> string
  (** [doc_quote s] quotes the string [s]. *)

  val doc_alts : ?quoted:bool -> string list -> string
  (** [doc_alts alts] documents the alternative tokens [alts]
      according the number of alternatives. If [quoted] is:
      {ul
      {- [None], the tokens are enclosed in manpage markup directives
         to render them in bold (manpage convention).}
      {- [Some true], the tokens are quoted with {!doc_quote}.}
      {- [Some false], the tokens are written as is}}
      The resulting string can be used in sentences of
      the form ["$(docv) must be %s"].

      @raise Invalid_argument if [alts] is the empty list.  *)

  val doc_alts_enum : ?quoted:bool -> (string * 'a) list -> string
  (** [doc_alts_enum quoted alts] is [doc_alts quoted (List.map fst alts)]. *)

  (** {1:deprecated Deprecated}

      These identifiers are silently deprecated. For now there is no
      plan to remove them. But you should prefer to use the {!Conv}
      interface in new code. *)

  type 'a printer = 'a Conv.fmt
  (** Deprecated. Use {!Conv.fmt}. *)

  val conv' : ?docv:string -> 'a Conv.parser * 'a Conv.fmt -> 'a conv
  (** Deprecated. Use {!Conv.make} instead. *)

  val conv :
    ?docv:string -> (string -> ('a, [`Msg of string]) result) * 'a Conv.fmt ->
    'a conv
  (** Deprecated. Use {!Conv.make} instead. *)

  val conv_parser : 'a conv -> (string -> ('a, [`Msg of string]) result)
  (** Deprecated. Use {!Conv.val-parser}. *)

  val conv_printer : 'a conv -> 'a Conv.fmt
  (** Deprecated. Use {!Conv.val-pp}. *)

  val conv_docv : 'a conv -> string
  (** Deprecated. Use {!Conv.val-docv}. *)

  val parser_of_kind_of_string :
    kind:string -> (string -> 'a option) ->
    (string -> ('a, [`Msg of string]) result)
  (** Deprecated. [parser_of_kind_of_string ~kind kind_of_string] is an argument
      parser using the [kind_of_string] function for parsing and [kind]
      to report errors (e.g. could be ["an integer"] for an [int] parser.). *)
end
end = struct
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

module Manpage = Cmdliner_manpage
module Term = Cmdliner_term
module Cmd = struct
  module Exit = Cmdliner_def.Exit
  module Env = Cmdliner_def.Env
  include Cmdliner_cmd
  include Cmdliner_eval
end
module Arg = Cmdliner_arg
end
include Cmdliner
end
module Mach : sig
(* Auto-generated by Dune *)
end = struct
(* mach - OCaml scripting runtime *)

open Mach_lib

let or_exit = function
  | Ok v -> v
  | Error (`User_error msg) ->
    Printf.eprintf "mach: %s\n%!" msg;
    exit 1

(* --- Watch mode --- *)

let parse_event line =
  match String.index_opt line ':' with
  | None -> None
  | Some i ->
    let event_type = String.sub line 0 i in
    let path = String.sub line (i + 1) (String.length line - i - 1) in
    Some (event_type, path)

(* Read a batch of events until empty line, deduplicating paths *)
let read_events ic =
  let paths = Hashtbl.create 16 in
  let rec loop () =
    match input_line ic with
    | "" -> Hashtbl.to_seq_keys paths |> List.of_seq |> List.sort String.compare
    | line -> begin
      Mach_log.log_very_verbose "mach:watch: event: %s" line;
      (match parse_event line with
      | None -> ()
      | Some (_event_type, path) -> Hashtbl.replace paths path ());
      loop ()
    end
  in
  loop ()

let watch config script_path ?run_args () =
  let build_dir_of = Mach_config.build_dir_of config in
  let exception Restart_watcher in
  let code = Sys.command "command -v watchexec > /dev/null 2>&1" in
  if code <> 0 then begin
    Printf.eprintf "mach: watchexec not found. Install it: https://github.com/watchexec/watchexec\n%!";
    exit 1
  end;
  let script_path = Unix.realpath script_path in

  (* Track current state for signal handling and cleanup *)
  let current_process = ref None in
  let current_watchlist = ref None in
  let child_pid : int option ref = ref None in

  let kill_child () =
    match !child_pid with
    | None -> ()
    | Some pid ->
      (match Unix.waitpid [Unix.WNOHANG] pid with
      | 0, _ ->
        Mach_log.log_verbose "mach: stopping previous instance (pid %d)..." pid;
        Unix.kill pid Sys.sigterm;
        ignore (Unix.waitpid [] pid)
      | _ -> ());
      child_pid := None
  in

  let start_child state =
    match run_args with
    | None -> ()
    | Some args ->
      kill_child ();
      let exe_path = Mach_state.exe_path config state in
      let argv = Array.of_list (exe_path :: args) in
      Mach_log.log_verbose "mach: starting %s" script_path;
      let pid = Unix.create_process exe_path argv Unix.stdin Unix.stdout Unix.stderr in
      child_pid := Some pid
  in

  let cleanup () =
    kill_child ();
    !current_process |> Option.iter (fun (pid, ic) ->
      begin try close_in ic with _ -> () end;
      (match Unix.waitpid [Unix.WNOHANG] pid with
      | 0, _ -> Unix.kill pid Sys.sigterm; ignore (Unix.waitpid [] pid)
      | _ -> ());
      current_process := None);
    !current_watchlist |> Option.iter (fun path ->
      begin try Sys.remove path with _ -> () end;
      current_watchlist := None)
  in

  Sys.(set_signal sigint (Signal_handle (fun _ -> cleanup (); exit 0)));

  Mach_log.log_verbose "mach: initial build...";
  (* Don't exit on initial build failure - continue watching for changes *)
  (match build config script_path with
  | Ok (~state, ~reconfigured:_) -> start_child state
  | Error (`User_error msg) -> Mach_log.log_verbose "mach: %s" msg);

  let keep_watching = ref true in
  while !keep_watching do
    let state = Option.get (Mach_state.read (Filename.concat (build_dir_of script_path) "Mach.state")) in
    let source_dirs = Mach_state.source_dirs state in
    let source_files =
      let files = Hashtbl.create 16 in
      List.iter (fun (entry : Mach_state.entry) ->
        Hashtbl.replace files entry.ml_path ();
        Option.iter (fun mli -> Hashtbl.replace files mli ()) entry.mli_path
      ) state.entries;
      files
    in
    Mach_log.log_verbose "mach: watching %d directories (Ctrl+C to stop):" (List.length source_dirs);
    List.iter (fun d -> Mach_log.log_verbose "  %s" d) source_dirs;
    let watchlist_path =
      let path = Filename.temp_file "mach-watch" ".txt" in
      Out_channel.with_open_text path (fun oc ->
        List.iter (fun dir ->
          output_string oc "-W\n";
          output_string oc dir;
          output_char oc '\n'
        ) source_dirs);
      path
    in
    current_watchlist := Some watchlist_path;
    let args = [|
      "watchexec";
      "--debounce"; "200ms";
      "--only-emit-events";
      "--emit-events-to=stdio";
      "--exts"; "ml,mli,mlx";
      "@" ^ watchlist_path 
    |] in
    Mach_log.log_very_verbose "mach:watch: running: %s" (String.concat " " (Array.to_list args));
    let pipe_read, pipe_write = Unix.pipe () in
    let pid = Unix.create_process "watchexec" args Unix.stdin pipe_write Unix.stderr in
    Unix.close pipe_write;
    let ic = Unix.in_channel_of_descr pipe_read in
    current_process := Some (pid, ic);

    begin try
      while true do
        let changed_paths = read_events ic in
        let relevant_paths =
          List.fold_left (fun acc path -> if Hashtbl.mem source_files path then path :: acc else acc)
          [] changed_paths
        in
        if relevant_paths <> [] then begin
          List.iter (fun p -> Mach_log.log_verbose "mach: file changed: %s" (Filename.basename p)) relevant_paths;
          match build config script_path with
          | Error (`User_error msg) -> Mach_log.log_verbose "mach: %s" msg
          | Ok (~state, ~reconfigured) ->
            Printf.eprintf "mach: build succeeded\n%!";
            start_child state;
            if reconfigured then begin
              Mach_log.log_verbose "mach:watch: reconfigured, restarting watcher...";
              raise Restart_watcher
            end
        end
      done
    with
    | Restart_watcher -> cleanup ()
    | End_of_file -> cleanup (); keep_watching := false
    end
  done

(* --- Command Line --- *)

open Cmdliner

let verbose_arg =
  let f verbose =
    let verbose =
      match verbose with [] -> Quiet | [_] -> Verbose | _::_::[] -> Very_verbose | _ -> Very_very_verbose
    in
    Mach_log.verbose := verbose
  in
  Term.(
    const f
    $ Arg.(value & flag_all & info ["v"; "verbose"] ~doc:"Log external command invocations to stderr."))

let script_arg =
  Arg.(required & pos 0 (some non_dir_file) None & info [] ~docv:"SCRIPT" ~doc:"OCaml script to run")

let args_arg =
  Arg.(value & pos_right 0 string [] & info [] ~docv:"ARGS" ~doc:"Arguments to pass to the script")

let watch_arg =
  Arg.(value & flag & info ["w"; "watch"]
    ~doc:"Watch for changes and rebuild automatically. Requires watchexec to be installed.")

let run_cmd =
  let doc = "Run an OCaml script" in
  let info = Cmd.info "run" ~doc in
  let f () watch_mode script_path args =
    let config = Mach_config.get () |> or_exit in
    if watch_mode then watch config script_path ~run_args:args ()
    else begin
      let ~state, ~reconfigured:_ = build config script_path |> or_exit in
      let exe_path = Mach_state.exe_path config state in
      let argv = Array.of_list (exe_path :: args) in
      Unix.execv exe_path argv
    end
  in
  Cmd.v info Term.(const f $ verbose_arg $ watch_arg $ script_arg $ args_arg)

let build_cmd =
  let doc = "Build an OCaml script without executing it" in
  let info = Cmd.info "build" ~doc in
  let f () watch_mode script_path =
    let config = Mach_config.get () |> or_exit in
    if watch_mode then watch config script_path ()
    else build config script_path |> or_exit |> ignore
  in
  Cmd.v info Term.(const f $ verbose_arg $ watch_arg $ script_arg)

let source_arg =
  Arg.(required & pos 0 (some non_dir_file) None & info [] ~docv:"SOURCE" ~doc:"OCaml source file to configure")

let configure_cmd =
  let doc = "Generate build files for all modules in dependency graph" in
  let info = Cmd.info "configure" ~doc ~docs:Manpage.s_none in
  let f path =
    let config = Mach_config.get () |> or_exit in
    configure config path |> or_exit |> ignore
  in
  Cmd.v info Term.(const f $ source_arg)

let pp_cmd =
  let doc = "Preprocess source file to stdout (for use with merlin -pp)" in
  let info = Cmd.info "pp" ~doc ~docs:Manpage.s_none in
  Cmd.v info Term.(const pp $ source_arg)

let run_build_command_cmd =
  let doc = "Run a build command, prefixing output with >>>" in
  let info = Cmd.info "run-build-command" ~doc ~docs:Manpage.s_none in
  let cmd_arg = Arg.(non_empty & pos_all string [] & info [] ~docv:"COMMAND") in
  let stderr_only_arg = Arg.(value & flag & info ["stderr-only"] ~doc:"Only capture stderr, let stdout pass through") in
  let f stderr_only args =
    let open Unix in
    let prog, argv = match args with
      | [] -> prerr_endline "mach run-build-command: no command"; exit 1
      | prog :: _ -> prog, Array.of_list args
    in
    let (pipe_read, pipe_write) = pipe () in
    let pid = match fork () with
      | 0 ->
        close pipe_read;
        if not stderr_only then dup2 pipe_write stdout;
        dup2 pipe_write stderr;
        close pipe_write;
        execvp prog argv
      | pid -> pid
    in
    close pipe_write;
    let ic = in_channel_of_descr pipe_read in
    (try while true do
      let line = input_line ic in
      Printf.eprintf ">>>%s\n%!" line
    done with End_of_file -> ());
    close_in ic;
    let _, status = waitpid [] pid in
    match status with
    | WEXITED code -> exit code
    | WSIGNALED n -> exit (128 + n)
    | WSTOPPED _ -> exit 1
  in
  Cmd.v info Term.(const f $ stderr_only_arg $ cmd_arg)

let cmd =
  let doc = "Run OCaml scripts with automatic dependency resolution" in
  let info = Cmd.info "mach" ~doc ~man:[`S Manpage.s_synopsis] in
  let default = Term.(ret (const (`Help (`Pager, None)))) in
  Cmd.group ~default info [run_cmd; build_cmd; configure_cmd; pp_cmd; run_build_command_cmd]

let () = exit (Cmdliner.Cmd.eval cmd)
end
