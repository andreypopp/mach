(* THIS FILE WAS AUTOMATICALLY GENERATED BY CAT'ING LIBRARY SOURCES *)
[@@@ocaml.warning "-27-32-35"]
module Sexp : sig
(** Type of S-expressions *)

type t =
  | Atom of string
  | List of t list

(*_ We don't use [@@deriving sexp] as this would generated references to [Sexplib],
  creating a circular dependency *)
val t_of_sexp : t -> t
val sexp_of_t : t -> t
val equal : t -> t -> bool
val compare : t -> t -> int

(** [Not_found_s] is used by functions that historically raised [Not_found], to allow them
    to raise an exception that contains an informative error message (as a sexp), while
    still having an exception that can be distinguished from other exceptions. *)
exception Not_found_s of t

(** [Of_sexp_error (exn, sexp)] the exception raised when an S-expression could not be
    successfully converted to an OCaml-value. *)
exception Of_sexp_error of exn * t

(** {1 Helpers} *)

(** Helper to build nice s-expressions for error messages.  It imitates the behavior of
    [[%message ...]] from the ppx_sexp_message rewriter.

    [message name key_values] produces a s-expression list starting with atom [name] and
    followed by list of size 2 of the form [(key value)].  When the key is the empty
    string, [value] is used directly instead as for [[%message]].

    For instance the following code:

    {[
      Sexp.message "error"
        [ "x", sexp_of_int 42
        ; "" , sexp_of_exn Exit
        ]
    ]}

    produces the s-expression:

    {[
      (error (x 42) Exit)
    ]} *)
val message : string -> (string * t) list -> t

(** {1 Defaults} *)

(** [default_indent] reference to default indentation level for human-readable
    conversions.

    Initialisation value: 2. *)
val default_indent : int ref

(** {1 Pretty printing of S-expressions} *)

(** [pp_hum ppf sexp] outputs S-expression [sexp] to formatter [ppf] in human readable
    form. *)
val pp_hum : Format.formatter -> t -> unit

(** [pp_hum_indent n ppf sexp] outputs S-expression [sexp] to formatter [ppf] in human
    readable form and indentation level [n]. *)
val pp_hum_indent : int -> Format.formatter -> t -> unit

(** [pp_mach ppf sexp] outputs S-expression [sexp] to formatter [ppf] in machine readable
    (i.e. most compact) form. *)
val pp_mach : Format.formatter -> t -> unit

(** Same as [pp_mach]. *)
val pp : Format.formatter -> t -> unit

(** {1 Conversion to strings} *)

(** [to_string_hum ?indent sexp] converts S-expression [sexp] to a
    string in human readable form with indentation level [indent].

    @param indent default = [!default_indent] *)
val to_string_hum : ?indent:int -> t -> string

(** [to_string_mach sexp] converts S-expression [sexp] to a string in
    machine readable (i.e. most compact) form. *)
val to_string_mach : t -> string

(** Same as [to_string_mach]. *)
val to_string : t -> string

(** {1 Styles} *)

val of_float_style : [ `Underscores | `No_underscores ] ref
val of_int_style : [ `Underscores | `No_underscores ] ref

(*_ See the Jane Street Style Guide for an explanation of [Private] submodules:

  https://opensource.janestreet.com/standards/#private-submodules *)
module Private : sig
  (*_ Exported for sexplib *)

  val size : t -> int * int
  val buffer : unit -> Buffer.t
  val to_buffer : buf:Buffer.t -> t -> unit
  val to_buffer_hum : buf:Buffer.t -> ?indent:int -> t -> unit
  val to_buffer_mach : buf:Buffer.t -> t -> unit

  val to_buffer_gen
    :  buf:'buffer
    -> add_char:('buffer -> char -> unit)
    -> add_string:('buffer -> string -> unit)
    -> t
    -> unit

  val mach_maybe_esc_str : string -> string
  val must_escape : string -> bool
  val esc_str : string -> string
end
end = struct
[@@@ocaml.warning "-3"]

(* blit_string doesn't exist in [StdLabels.Bytes]...  *)
let bytes_blit_string ~src ~src_pos ~dst ~dst_pos ~len =
  Bytes.blit_string src src_pos dst dst_pos len
;;

open StdLabels
open Format

(** Type of S-expressions *)
type t =
  | Atom of string
  | List of t list

let sexp_of_t t = t
let t_of_sexp t = t

let rec compare_list a b =
  match a, b with
  | [], [] -> 0
  | [], _ -> -1
  | _, [] -> 1
  | x :: xs, y :: ys ->
    let res = compare x y in
    if res <> 0 then res else compare_list xs ys

and compare a b =
  if a == b
  then 0
  else (
    match a, b with
    | Atom a, Atom b -> String.compare a b
    | Atom _, _ -> -1
    | _, Atom _ -> 1
    | List a, List b -> compare_list a b)
;;

let rec equal a b =
  a == b
  ||
  match a, b with
  | Atom a, Atom b -> String.equal a b
  | Atom _, _ | _, Atom _ -> false
  | List a, List b -> List.equal ~eq:equal a b
;;

exception Not_found_s of t
exception Of_sexp_error of exn * t

module Printing = struct
  (* Default indentation level for human-readable conversions *)

  let default_indent = ref 1

  (* Escaping of strings used as atoms in S-expressions *)

  let must_escape str =
    let len = String.length str in
    len = 0
    ||
    let rec loop str ix =
      match str.[ix] with
      | '"' | '(' | ')' | ';' | '\\' -> true
      | '|' ->
        ix > 0
        &&
        let next = ix - 1 in
        Char.equal str.[next] '#' || loop str next
      | '#' ->
        ix > 0
        &&
        let next = ix - 1 in
        Char.equal str.[next] '|' || loop str next
      | '\000' .. '\032' | '\127' .. '\255' -> true
      | _ -> ix > 0 && loop str (ix - 1)
    in
    loop str (len - 1)
  ;;

  let escaped s =
    let n = ref 0 in
    for i = 0 to String.length s - 1 do
      n
        := !n
           +
           match String.unsafe_get s i with
           | '\"' | '\\' | '\n' | '\t' | '\r' | '\b' -> 2
           | ' ' .. '~' -> 1
           | _ -> 4
    done;
    if !n = String.length s
    then s
    else (
      let s' = Bytes.create !n in
      n := 0;
      for i = 0 to String.length s - 1 do
        (match String.unsafe_get s i with
         | ('\"' | '\\') as c ->
           Bytes.unsafe_set s' !n '\\';
           incr n;
           Bytes.unsafe_set s' !n c
         | '\n' ->
           Bytes.unsafe_set s' !n '\\';
           incr n;
           Bytes.unsafe_set s' !n 'n'
         | '\t' ->
           Bytes.unsafe_set s' !n '\\';
           incr n;
           Bytes.unsafe_set s' !n 't'
         | '\r' ->
           Bytes.unsafe_set s' !n '\\';
           incr n;
           Bytes.unsafe_set s' !n 'r'
         | '\b' ->
           Bytes.unsafe_set s' !n '\\';
           incr n;
           Bytes.unsafe_set s' !n 'b'
         | ' ' .. '~' as c -> Bytes.unsafe_set s' !n c
         | c ->
           let a = Char.code c in
           Bytes.unsafe_set s' !n '\\';
           incr n;
           Bytes.unsafe_set s' !n (Char.chr (48 + (a / 100)));
           incr n;
           Bytes.unsafe_set s' !n (Char.chr (48 + (a / 10 mod 10)));
           incr n;
           Bytes.unsafe_set s' !n (Char.chr (48 + (a mod 10))));
        incr n
      done;
      Bytes.unsafe_to_string s')
  ;;

  let esc_str str =
    let estr = escaped str in
    let elen = String.length estr in
    let res = Bytes.create (elen + 2) in
    bytes_blit_string ~src:estr ~src_pos:0 ~dst:res ~dst_pos:1 ~len:elen;
    Bytes.unsafe_set res 0 '"';
    Bytes.unsafe_set res (elen + 1) '"';
    Bytes.unsafe_to_string res
  ;;

  let index_of_newline str start = String.index_from_opt str start '\n'

  let get_substring str index end_pos_opt =
    let end_pos =
      match end_pos_opt with
      | None -> String.length str
      | Some end_pos -> end_pos
    in
    String.sub str ~pos:index ~len:(end_pos - index)
  ;;

  let is_one_line str =
    match index_of_newline str 0 with
    | None -> true
    | Some index -> index + 1 = String.length str
  ;;

  let pp_hum_maybe_esc_str ppf str =
    if not (must_escape str)
    then pp_print_string ppf str
    else if is_one_line str
    then pp_print_string ppf (esc_str str)
    else (
      let rec loop index =
        let next_newline = index_of_newline str index in
        let next_line = get_substring str index next_newline in
        pp_print_string ppf (escaped next_line);
        match next_newline with
        | None -> ()
        | Some newline_index ->
          pp_print_string ppf "\\";
          pp_force_newline ppf ();
          pp_print_string ppf "\\n";
          loop (newline_index + 1)
      in
      pp_open_box ppf 0;
      (* the leading space is to line up the lines *)
      pp_print_string ppf " \"";
      loop 0;
      pp_print_string ppf "\"";
      pp_close_box ppf ())
  ;;

  let mach_maybe_esc_str str = if must_escape str then esc_str str else str

  (* Output of S-expressions to formatters *)

  let rec pp_hum_indent indent ppf = function
    | Atom str -> pp_hum_maybe_esc_str ppf str
    | List (h :: t) ->
      pp_open_box ppf indent;
      pp_print_string ppf "(";
      pp_hum_indent indent ppf h;
      pp_hum_rest indent ppf t
    | List [] -> pp_print_string ppf "()"

  and pp_hum_rest indent ppf = function
    | h :: t ->
      pp_print_space ppf ();
      pp_hum_indent indent ppf h;
      pp_hum_rest indent ppf t
    | [] ->
      pp_print_string ppf ")";
      pp_close_box ppf ()
  ;;

  let rec pp_mach_internal may_need_space ppf = function
    | Atom str ->
      let str' = mach_maybe_esc_str str in
      let new_may_need_space = str' == str in
      if may_need_space && new_may_need_space then pp_print_string ppf " ";
      pp_print_string ppf str';
      new_may_need_space
    | List (h :: t) ->
      pp_print_string ppf "(";
      let may_need_space = pp_mach_internal false ppf h in
      pp_mach_rest may_need_space ppf t;
      false
    | List [] ->
      pp_print_string ppf "()";
      false

  and pp_mach_rest may_need_space ppf = function
    | h :: t ->
      let may_need_space = pp_mach_internal may_need_space ppf h in
      pp_mach_rest may_need_space ppf t
    | [] -> pp_print_string ppf ")"
  ;;

  let pp_hum ppf sexp = pp_hum_indent !default_indent ppf sexp
  let pp_mach ppf sexp = ignore (pp_mach_internal false ppf sexp)
  let pp = pp_mach

  (* Sexp size *)

  let rec size_loop ((v, c) as acc) = function
    | Atom str -> v + 1, c + String.length str
    | List lst -> List.fold_left lst ~init:acc ~f:size_loop
  ;;

  let size sexp = size_loop (0, 0) sexp

  (* Buffer conversions *)

  let to_buffer_hum ~buf ?(indent = !default_indent) sexp =
    let ppf = Format.formatter_of_buffer buf in
    Format.fprintf ppf "%a@?" (pp_hum_indent indent) sexp
  ;;

  let to_buffer_mach ~buf sexp =
    let rec loop may_need_space = function
      | Atom str ->
        let str' = mach_maybe_esc_str str in
        let new_may_need_space = str' == str in
        if may_need_space && new_may_need_space then Buffer.add_char buf ' ';
        Buffer.add_string buf str';
        new_may_need_space
      | List (h :: t) ->
        Buffer.add_char buf '(';
        let may_need_space = loop false h in
        loop_rest may_need_space t;
        false
      | List [] ->
        Buffer.add_string buf "()";
        false
    and loop_rest may_need_space = function
      | h :: t ->
        let may_need_space = loop may_need_space h in
        loop_rest may_need_space t
      | [] -> Buffer.add_char buf ')'
    in
    ignore (loop false sexp)
  ;;

  let to_buffer = to_buffer_mach

  let to_buffer_gen ~buf ~add_char ~add_string sexp =
    let rec loop may_need_space = function
      | Atom str ->
        let str' = mach_maybe_esc_str str in
        let new_may_need_space = str' == str in
        if may_need_space && new_may_need_space then add_char buf ' ';
        add_string buf str';
        new_may_need_space
      | List (h :: t) ->
        add_char buf '(';
        let may_need_space = loop false h in
        loop_rest may_need_space t;
        false
      | List [] ->
        add_string buf "()";
        false
    and loop_rest may_need_space = function
      | h :: t ->
        let may_need_space = loop may_need_space h in
        loop_rest may_need_space t
      | [] -> add_char buf ')'
    in
    ignore (loop false sexp)
  ;;

  (* The maximum size of a thing on the minor heap is 256 words.
     Previously, this size of the returned buffer here was 4096 bytes, which
     caused the Buffer to be allocated on the *major* heap every time.

     According to a simple benchmark by Ron, we can improve performance for
     small s-expressions by a factor of ~4 if we only allocate 1024 bytes
     (128 words + some small overhead) worth of buffer initially.  And one
     can argue that if it's free to allocate strings smaller than 256 words,
     large s-expressions requiring larger expensive buffers won't notice
     the extra two doublings from 1024 bytes to 2048 and 4096. And especially
     performance-sensitive applications to always pass in a larger buffer to
     use. *)
  let buffer () = Buffer.create 1024

  (* String conversions *)

  let to_string_hum ?indent = function
    | Atom str
      when match index_of_newline str 0 with
           | None -> true
           | Some _ -> false -> mach_maybe_esc_str str
    | sexp ->
      let buf = buffer () in
      to_buffer_hum ?indent sexp ~buf;
      Buffer.contents buf
  ;;

  let to_string_mach = function
    | Atom str -> mach_maybe_esc_str str
    | sexp ->
      let buf = buffer () in
      to_buffer_mach sexp ~buf;
      Buffer.contents buf
  ;;

  let to_string = to_string_mach
end

include Printing

let of_float_style : [ `Underscores | `No_underscores ] ref = ref `No_underscores
let of_int_style : [ `Underscores | `No_underscores ] ref = ref `No_underscores

module Private = struct
  include Printing
end

let message name fields =
  let rec conv_fields = function
    | [] -> []
    | (fname, fsexp) :: rest ->
      (match fname with
       | "" -> fsexp :: conv_fields rest
       | _ -> List [ Atom fname; fsexp ] :: conv_fields rest)
  in
  List (Atom name :: conv_fields fields)
;;
end
module Sexp_grammar = struct
(** Representation of S-expression grammars *)

(** This module defines a representation for s-expression grammars. Using ppx_sexp_conv
    and [[@@deriving sexp_grammar]] produces a grammar that is compatible with the derived
    [of_sexp] for a given type.

    As with other derived definitions, polymorphic types derive a function that takes a
    grammar for each type argument and produces a grammar for the monomorphized type.

    Monomorphic types derive a grammar directly. To avoid top-level side effects,
    [[@@deriving sexp_grammar]] wraps grammars in the [Lazy] constructor as needed.

    This type may change over time as our needs for expressive grammars change. We will
    attempt to make changes backward-compatible, or at least provide a reasonable upgrade
    path. *)

[@@@warning "-30"] (* allow duplicate field names *)

(** Grammar of a sexp. *)
type grammar =
  | Any of string (** accepts any sexp; string is a type name for human readability *)
  | Bool (** accepts the atoms "true" or "false", modulo capitalization *)
  | Char (** accepts any single-character atom *)
  | Integer (** accepts any atom matching ocaml integer syntax, regardless of bit width *)
  | Float (** accepts any atom matching ocaml float syntax *)
  | String (** accepts any atom *)
  | Option of grammar (** accepts an option, both [None] vs [Some _] and [()] vs [(_)]. *)
  | List of list_grammar (** accepts a list *)
  | Variant of variant (** accepts clauses keyed by a leading or sole atom *)
  | Union of grammar list (** accepts a sexp if any of the listed grammars accepts it *)
  | Tagged of grammar with_tag
      (** annotates a grammar with a client-specific key/value pair *)
  | Tyvar of string
      (** Name of a type variable, e.g. [Tyvar "a"] for ['a]. Only meaningful when the body of
      the innermost enclosing [defn] defines a corresponding type variable. *)
  | Tycon of string * grammar list * defn list
      (** Type constructor applied to arguments, and its definition.

      For example, writing [Tycon ("tree", [ Integer ], defns)] represents [int tree], for
      whatever [tree] is defined as in [defns]. The following defines [tree] as a binary
      tree with the parameter type stored at the leaves.

      {[
        let defns =
          [ { tycon = "tree"
            ; tyvars = ["a"]
            ; grammar =
                Variant
                  { name_kind = Capitalized
                  ; clauses =
                      [ { name = "Node"
                        ; args = Cons (Recursive ("node", [Tyvar "a"]), Empty)
                        }
                      ; { name = "Leaf"
                        ; args = Cons (Recursive ("leaf", [Tyvar "a"]), Empty)
                        }
                      ]
                  }
            }
          ; { tycon = "node"
            ; tyvars = ["a"]
            ; grammar = List (Many (Recursive "tree", [Tyvar "a"]))
            }
          ; { tycon = "leaf"
            ; tyvars = ["a"]
            ; grammar = [Tyvar "a"]
            }
          ]
        ;;
      ]}

      To illustrate the meaning of [Tycon] with respect to [defns], and to demonstrate one
      way to access them, it is equivalent to expand the definition of "tree" one level
      and move the [defns] to enclosed recursive references:

      {[
        Tycon ("tree", [ Integer ], defns)
        -->
        Variant
          { name_kind = Capitalized
          ; clauses =
              [ { name = "Node"
                ; args = Cons (Tycon ("node", [Tyvar "a"], defns), Empty)
                }
              ; { name = "Leaf"
                ; args = Cons (Tycon ("leaf", [Tyvar "a"], defns), Empty)
                }
              ]
          }
      ]}

      This transformation exposes the structure of a grammar with recursive references,
      while preserving the meaning of recursively-defined elements. *)
  | Recursive of string * grammar list
      (** Type constructor applied to arguments. Used to denote recursive type references.
      Only meaningful when used inside the [defn]s of a [Tycon] grammar, to refer to a
      type constructor in the nearest enclosing [defn] list. *)
  | Lazy of grammar lazy_t
      (** Lazily computed grammar. Use [Lazy] to avoid top-level side effects. To define
      recursive grammars, use [Recursive] instead. *)

(** Grammar of a list of sexps. *)
and list_grammar =
  | Empty (** accepts an empty list of sexps *)
  | Cons of grammar * list_grammar
      (** accepts a non-empty list with head and tail matching the given grammars *)
  | Many of grammar (** accepts zero or more sexps, each matching the given grammar *)
  | Fields of record (** accepts sexps representing fields of a record *)

(** Case sensitivity options for names of variant constructors. *)
and case_sensitivity =
  | Case_insensitive (** Comparison is case insensitive. Used for custom parsers. *)
  | Case_sensitive (** Comparison is case sensitive. Used for polymorphic variants. *)
  | Case_sensitive_except_first_character
      (** Comparison is case insensitive for the first character and case sensitive afterward.
      Used for regular variants. *)

(** Grammar of variants. Accepts any sexp matching one of the clauses. *)
and variant =
  { case_sensitivity : case_sensitivity
  ; clauses : clause with_tag_list list
  }

(** Grammar of a single variant clause. Accepts sexps based on the [clause_kind]. *)
and clause =
  { name : string
  ; clause_kind : clause_kind
  }

(** Grammar of a single variant clause's contents. [Atom_clause] accepts an atom matching
    the clause's name. [List_clause] accepts a list whose head is an atom matching the
    clause's name and whose tail matches [args]. The clause's name is matched modulo the
    variant's [name_kind]. *)
and clause_kind =
  | Atom_clause
  | List_clause of { args : list_grammar }

(** Grammar of a record. Accepts any list of sexps specifying each of the fields,
    regardless of order. If [allow_extra_fields] is specified, ignores sexps with names
    not found in [fields]. *)
and record =
  { allow_extra_fields : bool
  ; fields : field with_tag_list list
  }

(** Grammar of a record field. A field must show up exactly once in a record if
    [required], or at most once otherwise. Accepts a list headed by [name] as an atom,
    followed by sexps matching [args]. *)
and field =
  { name : string
  ; required : bool
  ; args : list_grammar
  }

(** Grammar tagged with client-specific key/value pair. *)
and 'a with_tag =
  { key : string
  ; value : Sexp.t
  ; grammar : 'a
  }

and 'a with_tag_list =
  | Tag of 'a with_tag_list with_tag
  | No_tag of 'a

(** Grammar of a recursive type definition. Names the [tycon] being defined, and the
    [tyvars] it takes as parameters. Specifies the [grammar] of the [tycon]. The grammar
    may refer to any of the [tyvars], and to any of the [tycon]s from the same set of
    [Recursive] definitions. *)
and defn =
  { tycon : string
  ; tyvars : string list
  ; grammar : grammar
  }

(** Top-level grammar type. Has a phantom type parameter to associate each grammar with
    the type its sexps represent. This makes it harder to apply grammars to the wrong
    type, while grammars can still be easily coerced to a new type if needed. *)
type _ t = { untyped : grammar } [@@unboxed]

let coerce (type a b) ({ untyped = _ } as t : a t) : b t = t

let tag (type a) ({ untyped = grammar } : a t) ~key ~value : a t =
  { untyped = Tagged { key; value; grammar } }
;;

(** This reserved key is used for all tags generated from doc comments. *)
let doc_comment_tag = "sexp_grammar.doc_comment"

(** This reserved key can be used to associate a type name with a grammar. *)
let type_name_tag = "sexp_grammar.type_name"

(** This reserved key indicates that a sexp represents a key/value association. The tag's
    value is ignored. *)
let assoc_tag = "sexp_grammar.assoc"

(** This reserved key indicates that a sexp is a key in a key/value association. The tag's
    value is ignored. *)
let assoc_key_tag = "sexp_grammar.assoc.key"

(** This reserved key indicates that a sexp is a value in a key/value association. The
    tag's value is ignored. *)
let assoc_value_tag = "sexp_grammar.assoc.value"

(** When the key is set to [Atom "false"] for a variant clause, that clause should not be
    suggested in auto-completion based on the sexp grammar. *)
let completion_suggested = "sexp_grammar.completion-suggested"
end
module Sexpable = struct
module type S = sig
  type t

  val t_of_sexp : Sexp.t -> t
  val sexp_of_t : t -> Sexp.t
end

module type S1 = sig
  type 'a t

  val t_of_sexp : (Sexp.t -> 'a) -> Sexp.t -> 'a t
  val sexp_of_t : ('a -> Sexp.t) -> 'a t -> Sexp.t
end

module type S2 = sig
  type ('a, 'b) t

  val t_of_sexp : (Sexp.t -> 'a) -> (Sexp.t -> 'b) -> Sexp.t -> ('a, 'b) t
  val sexp_of_t : ('a -> Sexp.t) -> ('b -> Sexp.t) -> ('a, 'b) t -> Sexp.t
end

module type S3 = sig
  type ('a, 'b, 'c) t

  val t_of_sexp
    :  (Sexp.t -> 'a)
    -> (Sexp.t -> 'b)
    -> (Sexp.t -> 'c)
    -> Sexp.t
    -> ('a, 'b, 'c) t

  val sexp_of_t
    :  ('a -> Sexp.t)
    -> ('b -> Sexp.t)
    -> ('c -> Sexp.t)
    -> ('a, 'b, 'c) t
    -> Sexp.t
end
end
module Sexp_conv_grammar : sig
(** Grammar constructors. *)

val sexp_grammar_with_tags
  :  Sexp_grammar.grammar
  -> tags:(string * Sexp.t) list
  -> Sexp_grammar.grammar

val sexp_grammar_with_tag_list
  :  'a Sexp_grammar.with_tag_list
  -> tags:(string * Sexp.t) list
  -> 'a Sexp_grammar.with_tag_list

(** Sexp grammar definitions. *)

val unit_sexp_grammar : unit Sexp_grammar.t
val bool_sexp_grammar : bool Sexp_grammar.t
val string_sexp_grammar : string Sexp_grammar.t
val bytes_sexp_grammar : bytes Sexp_grammar.t
val char_sexp_grammar : char Sexp_grammar.t
val int_sexp_grammar : int Sexp_grammar.t
val float_sexp_grammar : float Sexp_grammar.t
val int32_sexp_grammar : int32 Sexp_grammar.t
val int64_sexp_grammar : int64 Sexp_grammar.t
val nativeint_sexp_grammar : nativeint Sexp_grammar.t
val sexp_t_sexp_grammar : Sexp.t Sexp_grammar.t
val ref_sexp_grammar : 'a Sexp_grammar.t -> 'a ref Sexp_grammar.t
val lazy_t_sexp_grammar : 'a Sexp_grammar.t -> 'a lazy_t Sexp_grammar.t
val option_sexp_grammar : 'a Sexp_grammar.t -> 'a option Sexp_grammar.t
val list_sexp_grammar : 'a Sexp_grammar.t -> 'a list Sexp_grammar.t
val array_sexp_grammar : 'a Sexp_grammar.t -> 'a array Sexp_grammar.t
val opaque_sexp_grammar : 'a Sexp_grammar.t
val fun_sexp_grammar : 'a Sexp_grammar.t
end = struct
open StdLabels

let sexp_grammar_with_tags grammar ~tags =
  List.fold_right tags ~init:grammar ~f:(fun (key, value) grammar ->
    Sexp_grammar.Tagged { key; value; grammar })
;;

let sexp_grammar_with_tag_list x ~tags =
  List.fold_right tags ~init:x ~f:(fun (key, value) grammar ->
    Sexp_grammar.Tag { key; value; grammar })
;;

let unit_sexp_grammar : unit Sexp_grammar.t = { untyped = List Empty }
let bool_sexp_grammar : bool Sexp_grammar.t = { untyped = Bool }
let string_sexp_grammar : string Sexp_grammar.t = { untyped = String }
let bytes_sexp_grammar : bytes Sexp_grammar.t = { untyped = String }
let char_sexp_grammar : char Sexp_grammar.t = { untyped = Char }
let int_sexp_grammar : int Sexp_grammar.t = { untyped = Integer }
let float_sexp_grammar : float Sexp_grammar.t = { untyped = Float }
let int32_sexp_grammar : int32 Sexp_grammar.t = { untyped = Integer }
let int64_sexp_grammar : int64 Sexp_grammar.t = { untyped = Integer }
let nativeint_sexp_grammar : nativeint Sexp_grammar.t = { untyped = Integer }
let sexp_t_sexp_grammar : Sexp.t Sexp_grammar.t = { untyped = Any "Sexp.t" }
let ref_sexp_grammar grammar = Sexp_grammar.coerce grammar
let lazy_t_sexp_grammar grammar = Sexp_grammar.coerce grammar

let option_sexp_grammar ({ untyped } : _ Sexp_grammar.t) : _ option Sexp_grammar.t =
  { untyped = Option untyped }
;;

let list_sexp_grammar ({ untyped } : _ Sexp_grammar.t) : _ list Sexp_grammar.t =
  { untyped = List (Many untyped) }
;;

let array_sexp_grammar ({ untyped } : _ Sexp_grammar.t) : _ array Sexp_grammar.t =
  { untyped = List (Many untyped) }
;;

let empty_sexp_grammar : _ Sexp_grammar.t = { untyped = Union [] }
let opaque_sexp_grammar = empty_sexp_grammar
let fun_sexp_grammar = empty_sexp_grammar
end
module Sexp_conv : sig
(** Utility Module for S-expression Conversions *)

(** {6 Conversion of OCaml-values to S-expressions} *)

(** [default_string_of_float] reference to the default function used
    to convert floats to strings.

    Initially set to [fun n -> sprintf "%.20G" n]. *)
val default_string_of_float : (float -> string) ref

(** [write_old_option_format] reference for the default option format
    used to write option values.  If set to [true], the old-style option
    format will be used, the new-style one otherwise.

    Initially set to [true]. *)
val write_old_option_format : bool ref

(** [read_old_option_format] reference for the default option format
    used to read option values.  [Of_sexp_error] will be raised
    with old-style option values if this reference is set to [false].
    Reading new-style option values is always supported.  Using a global
    reference instead of changing the converter calling conventions is
    the only way to avoid breaking old code with the standard macros.

    Initially set to [true]. *)
val read_old_option_format : bool ref

(** We re-export a tail recursive map function, because some modules
    override the standard library functions (e.g. [StdLabels]) which
    wrecks havoc with the camlp4 extension. *)
val list_map : ('a -> 'b) -> 'a list -> 'b list

(** [sexp_of_unit ()] converts a value of type [unit] to an S-expression. *)
val sexp_of_unit : unit -> Sexp.t

(** [sexp_of_bool b] converts the value [x] of type [bool] to an
    S-expression. *)
val sexp_of_bool : bool -> Sexp.t

(** [sexp_of_string str] converts the value [str] of type [string] to an
    S-expression. *)
val sexp_of_string : string -> Sexp.t

(** [sexp_of_bytes str] converts the value [str] of type [bytes] to an
    S-expression. *)
val sexp_of_bytes : bytes -> Sexp.t

(** [sexp_of_char c] converts the value [c] of type [char] to an
    S-expression. *)
val sexp_of_char : char -> Sexp.t

(** [sexp_of_int n] converts the value [n] of type [int] to an
    S-expression. *)
val sexp_of_int : int -> Sexp.t

(** [sexp_of_float n] converts the value [n] of type [float] to an
    S-expression. *)
val sexp_of_float : float -> Sexp.t

(** [sexp_of_int32 n] converts the value [n] of type [int32] to an
    S-expression. *)
val sexp_of_int32 : int32 -> Sexp.t

(** [sexp_of_int64 n] converts the value [n] of type [int64] to an
    S-expression. *)
val sexp_of_int64 : int64 -> Sexp.t

(** [sexp_of_nativeint n] converts the value [n] of type [nativeint] to an
    S-expression. *)
val sexp_of_nativeint : nativeint -> Sexp.t

(** [sexp_of_ref conv r] converts the value [r] of type ['a ref] to
    an S-expression.  Uses [conv] to convert values of type ['a] to an
    S-expression. *)
val sexp_of_ref : ('a -> Sexp.t) -> 'a ref -> Sexp.t

(** [sexp_of_lazy_t conv l] converts the value [l] of type ['a lazy_t] to
    an S-expression.  Uses [conv] to convert values of type ['a] to an
    S-expression. *)
val sexp_of_lazy_t : ('a -> Sexp.t) -> 'a lazy_t -> Sexp.t

(** [sexp_of_option conv opt] converts the value [opt] of type ['a
    option] to an S-expression.  Uses [conv] to convert values of type
    ['a] to an S-expression. *)
val sexp_of_option : ('a -> Sexp.t) -> 'a option -> Sexp.t

(** [sexp_of_pair conv1 conv2 pair] converts a pair to an S-expression.
    It uses its first argument to convert the first element of the pair,
    and its second argument to convert the second element of the pair. *)
val sexp_of_pair : ('a -> Sexp.t) -> ('b -> Sexp.t) -> 'a * 'b -> Sexp.t

(** [sexp_of_triple conv1 conv2 conv3 triple] converts a triple to
    an S-expression using [conv1], [conv2], and [conv3] to convert its
    elements. *)
val sexp_of_triple
  :  ('a -> Sexp.t)
  -> ('b -> Sexp.t)
  -> ('c -> Sexp.t)
  -> 'a * 'b * 'c
  -> Sexp.t

(** [sexp_of_list conv lst] converts the value [lst] of type ['a
    list] to an S-expression.  Uses [conv] to convert values of type
    ['a] to an S-expression. *)
val sexp_of_list : ('a -> Sexp.t) -> 'a list -> Sexp.t

(** [sexp_of_array conv ar] converts the value [ar] of type ['a
    array] to an S-expression.  Uses [conv] to convert values of type
    ['a] to an S-expression. *)
val sexp_of_array : ('a -> Sexp.t) -> 'a array -> Sexp.t

(** [sexp_of_hashtbl conv_key conv_value htbl] converts the value [htbl]
    of type [('a, 'b) Hashtbl.t] to an S-expression.  Uses [conv_key]
    to convert the hashtable keys of type ['a], and [conv_value] to
    convert hashtable values of type ['b] to S-expressions. *)
val sexp_of_hashtbl : ('a -> Sexp.t) -> ('b -> Sexp.t) -> ('a, 'b) Hashtbl.t -> Sexp.t

(** [sexp_of_opaque x] converts the value [x] of opaque type to an
    S-expression.  This means the user need not provide converters,
    but the result cannot be interpreted. *)
val sexp_of_opaque : 'a -> Sexp.t

(** [sexp_of_fun f] converts the value [f] of function type to a
    dummy S-expression.  Functions cannot be serialized as S-expressions,
    but at least a placeholder can be generated for pretty-printing. *)
val sexp_of_fun : ('a -> 'b) -> Sexp.t

(** {6 Conversion of S-expressions to OCaml-values} *)

(** [Of_sexp_error (exn, sexp)] the exception raised when an S-expression
    could not be successfully converted to an OCaml-value. *)
exception Of_sexp_error of exn * Sexp.t

(** [record_check_extra_fields] checks for extra (= unknown) fields
    in record S-expressions. *)
val record_check_extra_fields : bool ref

(** [of_sexp_error reason sexp] @raise Of_sexp_error (Failure reason, sexp). *)
val of_sexp_error : string -> Sexp.t -> 'a

(** [of_sexp_error exc sexp] @raise Of_sexp_error (exc, sexp). *)
val of_sexp_error_exn : exn -> Sexp.t -> 'a

(** [unit_of_sexp sexp] converts S-expression [sexp] to a value of type
    [unit]. *)
val unit_of_sexp : Sexp.t -> unit

(** [bool_of_sexp sexp] converts S-expression [sexp] to a value of type
    [bool]. *)
val bool_of_sexp : Sexp.t -> bool

(** [string_of_sexp sexp] converts S-expression [sexp] to a value of type
    [string]. *)
val string_of_sexp : Sexp.t -> string

(** [bytes_of_sexp sexp] converts S-expression [sexp] to a value of type
    [bytes]. *)
val bytes_of_sexp : Sexp.t -> bytes

(** [char_of_sexp sexp] converts S-expression [sexp] to a value of type
    [char]. *)
val char_of_sexp : Sexp.t -> char

(** [int_of_sexp sexp] converts S-expression [sexp] to a value of type
    [int]. *)
val int_of_sexp : Sexp.t -> int

(** [float_of_sexp sexp] converts S-expression [sexp] to a value of type
    [float]. *)
val float_of_sexp : Sexp.t -> float

(** [int32_of_sexp sexp] converts S-expression [sexp] to a value of type
    [int32]. *)
val int32_of_sexp : Sexp.t -> int32

(** [int64_of_sexp sexp] converts S-expression [sexp] to a value of type
    [int64]. *)
val int64_of_sexp : Sexp.t -> int64

(** [nativeint_of_sexp sexp] converts S-expression [sexp] to a value
    of type [nativeint]. *)
val nativeint_of_sexp : Sexp.t -> nativeint

(** [ref_of_sexp conv sexp] converts S-expression [sexp] to a value
    of type ['a ref] using conversion function [conv], which converts
    an S-expression to a value of type ['a]. *)
val ref_of_sexp : (Sexp.t -> 'a) -> Sexp.t -> 'a ref

(** [lazy_t_of_sexp conv sexp] converts S-expression [sexp] to a value
    of type ['a lazy_t] using conversion function [conv], which converts
    an S-expression to a value of type ['a]. *)
val lazy_t_of_sexp : (Sexp.t -> 'a) -> Sexp.t -> 'a lazy_t

(** [option_of_sexp conv sexp] converts S-expression [sexp] to a value
    of type ['a option] using conversion function [conv], which converts
    an S-expression to a value of type ['a]. *)
val option_of_sexp : (Sexp.t -> 'a) -> Sexp.t -> 'a option

(** [pair_of_sexp conv1 conv2 sexp] converts S-expression [sexp] to a pair
    of type ['a * 'b] using conversion functions [conv1] and [conv2],
    which convert S-expressions to values of type ['a] and ['b]
    respectively. *)
val pair_of_sexp : (Sexp.t -> 'a) -> (Sexp.t -> 'b) -> Sexp.t -> 'a * 'b

(** [triple_of_sexp conv1 conv2 conv3 sexp] converts S-expression [sexp]
    to a triple of type ['a * 'b * 'c] using conversion functions [conv1],
    [conv2], and [conv3], which convert S-expressions to values of type
    ['a], ['b], and ['c] respectively. *)
val triple_of_sexp
  :  (Sexp.t -> 'a)
  -> (Sexp.t -> 'b)
  -> (Sexp.t -> 'c)
  -> Sexp.t
  -> 'a * 'b * 'c

(** [list_of_sexp conv sexp] converts S-expression [sexp] to a value
    of type ['a list] using conversion function [conv], which converts
    an S-expression to a value of type ['a]. *)
val list_of_sexp : (Sexp.t -> 'a) -> Sexp.t -> 'a list

(** [array_of_sexp conv sexp] converts S-expression [sexp] to a value
    of type ['a array] using conversion function [conv], which converts
    an S-expression to a value of type ['a]. *)
val array_of_sexp : (Sexp.t -> 'a) -> Sexp.t -> 'a array

(** [hashtbl_of_sexp conv_key conv_value sexp] converts S-expression
    [sexp] to a value of type [('a, 'b) Hashtbl.t] using conversion
    function [conv_key], which converts an S-expression to hashtable
    key of type ['a], and function [conv_value], which converts an
    S-expression to hashtable value of type ['b]. *)
val hashtbl_of_sexp : (Sexp.t -> 'a) -> (Sexp.t -> 'b) -> Sexp.t -> ('a, 'b) Hashtbl.t

(** [opaque_of_sexp sexp] @raise Of_sexp_error when attempting to
    convert an S-expression to an opaque value. *)
val opaque_of_sexp : Sexp.t -> 'a

(** [fun_of_sexp sexp] @raise Of_sexp_error when attempting to
    convert an S-expression to a function. *)
val fun_of_sexp : Sexp.t -> 'a

(** Sexp Grammars *)

include module type of struct
  include Sexp_conv_grammar
end

(** Exception converters *)

(** [sexp_of_exn exc] converts exception [exc] to an S-expression.
    If no suitable converter is found, the standard converter in
    [Printexc] will be used to generate an atomic S-expression. *)
val sexp_of_exn : exn -> Sexp.t

(** Converts an exception to a string via sexp, falling back to [Printexc.to_string] if no
    sexp conversion is registered for this exception.

    This is different from [Printexc.to_string] in that it additionally uses the sexp
    converters registered with [~printexc:false]. Another difference is that the behavior
    of [Printexc] can be overridden with [Printexc.register], but here we always try sexp
    conversion first.
*)
val printexc_prefer_sexp : exn -> string

(** [sexp_of_exn_opt exc] converts exception [exc] to [Some sexp].
    If no suitable converter is found, [None] is returned instead. *)
val sexp_of_exn_opt : exn -> Sexp.t option

module Exn_converter : sig
  (** [add constructor sexp_of_exn] registers exception S-expression
      converter [sexp_of_exn] for exceptions with the given [constructor].

      NOTE: [finalise] is ignored, and provided only for backward compatibility. *)
  val add
    :  ?printexc:bool
    -> ?finalise:bool
    -> extension_constructor
    -> (exn -> Sexp.t)
    -> unit

  module For_unit_tests_only : sig
    val size : unit -> int
  end
end

(**/**)

(*_ For the syntax extension *)
external ignore : _ -> unit = "%ignore"
external ( = ) : 'a -> 'a -> bool = "%equal"
end = struct
(* Utility Module for S-expression Conversions *)

open StdLabels
open MoreLabels
open Printf
open Sexp

(* Conversion of OCaml-values to S-expressions *)
external format_float : string -> float -> string = "caml_format_float"

(* '%.17g' is guaranteed to be round-trippable.

   '%.15g' will be round-trippable and not have noise at the last digit or two for a float
   which was converted from a decimal (string) with <= 15 significant digits.  So it's
   worth trying first to avoid things like "3.1400000000000001".

   See comment above [to_string_round_trippable] in {!Core.Float} for
   detailed explanation and examples. *)
let default_string_of_float =
  ref (fun x ->
    let y = format_float "%.15G" x in
    if float_of_string y = x then y else format_float "%.17G" x)
;;

let read_old_option_format = ref true
let write_old_option_format = ref true
let list_map f l = List.map l ~f
let sexp_of_unit () = List []
let sexp_of_bool b = Atom (string_of_bool b)
let sexp_of_string str = Atom str
let sexp_of_bytes bytes = Atom (Bytes.to_string bytes)
let sexp_of_char c = Atom (String.make 1 c)
let sexp_of_int n = Atom (string_of_int n)
let sexp_of_float n = Atom (!default_string_of_float n)
let sexp_of_int32 n = Atom (Int32.to_string n)
let sexp_of_int64 n = Atom (Int64.to_string n)
let sexp_of_nativeint n = Atom (Nativeint.to_string n)
let sexp_of_ref sexp_of__a rf = sexp_of__a !rf
let sexp_of_lazy_t sexp_of__a lv = sexp_of__a (Lazy.force lv)

let sexp_of_option sexp_of__a = function
  | Some x when !write_old_option_format -> List [ sexp_of__a x ]
  | Some x -> List [ Atom "some"; sexp_of__a x ]
  | None when !write_old_option_format -> List []
  | None -> Atom "none"
;;

let sexp_of_pair sexp_of__a sexp_of__b (a, b) = List [ sexp_of__a a; sexp_of__b b ]

let sexp_of_triple sexp_of__a sexp_of__b sexp_of__c (a, b, c) =
  List [ sexp_of__a a; sexp_of__b b; sexp_of__c c ]
;;

let sexp_of_list sexp_of__a lst = List (List.map lst ~f:sexp_of__a)

let sexp_of_array sexp_of__a ar =
  let lst_ref = ref [] in
  for i = Array.length ar - 1 downto 0 do
    lst_ref := sexp_of__a ar.(i) :: !lst_ref
  done;
  List !lst_ref
;;

let sexp_of_hashtbl sexp_of_key sexp_of_val htbl =
  let coll ~key:k ~data:v acc = List [ sexp_of_key k; sexp_of_val v ] :: acc in
  List (Hashtbl.fold htbl ~init:[] ~f:coll)
;;

let sexp_of_opaque _ = Atom "<opaque>"
let sexp_of_fun _ = Atom "<fun>"

(* Exception converter registration and lookup *)

module Exn_converter = struct
  (* These exception registration functions assume that context-switches
     cannot happen unless there is an allocation.  It is reasonable to expect
     that this will remain true for the foreseeable future.  That way we
     avoid using mutexes and thus a dependency on the threads library. *)

  (* Fast and automatic exception registration *)

  module Registration = struct
    type t =
      { sexp_of_exn : exn -> Sexp.t
      ; (* If [printexc = true] then this sexp converter is used for Printexc.to_string *)
        printexc : bool
      }
  end

  module Exn_table = Ephemeron.K1.Make (struct
    type t = extension_constructor

    let equal = ( == )
    let hash = Obj.Extension_constructor.id
  end)

  let the_exn_table : Registration.t Exn_table.t = Exn_table.create 17

  (* Ephemerons are used so that [sexp_of_exn] closure don't keep the
     extension_constructor live. *)
  let add ?(printexc = true) ?finalise:_ extension_constructor sexp_of_exn =
    Exn_table.add the_exn_table extension_constructor { sexp_of_exn; printexc }
  ;;

  let find_auto ~for_printexc exn =
    let extension_constructor = Obj.Extension_constructor.of_val exn in
    match Exn_table.find_opt the_exn_table extension_constructor with
    | None -> None
    | Some { sexp_of_exn; printexc } ->
      (match for_printexc, printexc with
       | false, _ | _, true -> Some (sexp_of_exn exn)
       | true, false -> None)
  ;;

  module For_unit_tests_only = struct
    let size () = (Exn_table.stats_alive the_exn_table).num_bindings
  end
end

let sexp_of_exn_opt_for_printexc exn = Exn_converter.find_auto ~for_printexc:true exn
let sexp_of_exn_opt exn = Exn_converter.find_auto ~for_printexc:false exn

let sexp_of_exn exn =
  match sexp_of_exn_opt exn with
  | None -> List [ Atom (Printexc.to_string exn) ]
  | Some sexp -> sexp
;;

let exn_to_string e = Sexp.to_string_hum (sexp_of_exn e)

(* {[exception Blah [@@deriving sexp]]} generates a call to the function
   [Exn_converter.add] defined in this file.  So we are guaranted that as soon as we
   mark an exception as sexpable, this module will be linked in and this printer will be
   registered, which is what we want. *)
let () =
  Printexc.register_printer (fun exn ->
    match sexp_of_exn_opt_for_printexc exn with
    | None -> None
    | Some sexp -> Some (Sexp.to_string_hum ~indent:2 sexp))
;;

let printexc_prefer_sexp exn =
  match sexp_of_exn_opt exn with
  | None -> Printexc.to_string exn
  | Some sexp -> Sexp.to_string_hum ~indent:2 sexp
;;

(* Conversion of S-expressions to OCaml-values *)

exception Of_sexp_error = Sexp.Of_sexp_error

let record_check_extra_fields = ref true
let of_sexp_error_exn exc sexp = raise (Of_sexp_error (exc, sexp))
let of_sexp_error what sexp = raise (Of_sexp_error (Failure what, sexp))

let unit_of_sexp sexp =
  match sexp with
  | List [] -> ()
  | Atom _ | List _ -> of_sexp_error "unit_of_sexp: empty list needed" sexp
;;

let bool_of_sexp sexp =
  match sexp with
  | Atom ("true" | "True") -> true
  | Atom ("false" | "False") -> false
  | Atom _ -> of_sexp_error "bool_of_sexp: unknown string" sexp
  | List _ -> of_sexp_error "bool_of_sexp: atom needed" sexp
;;

let string_of_sexp sexp =
  match sexp with
  | Atom str -> str
  | List _ -> of_sexp_error "string_of_sexp: atom needed" sexp
;;

let bytes_of_sexp sexp =
  match sexp with
  | Atom str -> Bytes.of_string str
  | List _ -> of_sexp_error "bytes_of_sexp: atom needed" sexp
;;

let char_of_sexp sexp =
  match sexp with
  | Atom str ->
    if String.length str <> 1
    then of_sexp_error "char_of_sexp: atom string must contain one character only" sexp;
    str.[0]
  | List _ -> of_sexp_error "char_of_sexp: atom needed" sexp
;;

let int_of_sexp sexp =
  match sexp with
  | Atom str ->
    (try int_of_string str with
     | exc -> of_sexp_error ("int_of_sexp: " ^ exn_to_string exc) sexp)
  | List _ -> of_sexp_error "int_of_sexp: atom needed" sexp
;;

let float_of_sexp sexp =
  match sexp with
  | Atom str ->
    (try float_of_string str with
     | exc -> of_sexp_error ("float_of_sexp: " ^ exn_to_string exc) sexp)
  | List _ -> of_sexp_error "float_of_sexp: atom needed" sexp
;;

let int32_of_sexp sexp =
  match sexp with
  | Atom str ->
    (try Int32.of_string str with
     | exc -> of_sexp_error ("int32_of_sexp: " ^ exn_to_string exc) sexp)
  | List _ -> of_sexp_error "int32_of_sexp: atom needed" sexp
;;

let int64_of_sexp sexp =
  match sexp with
  | Atom str ->
    (try Int64.of_string str with
     | exc -> of_sexp_error ("int64_of_sexp: " ^ exn_to_string exc) sexp)
  | List _ -> of_sexp_error "int64_of_sexp: atom needed" sexp
;;

let nativeint_of_sexp sexp =
  match sexp with
  | Atom str ->
    (try Nativeint.of_string str with
     | exc -> of_sexp_error ("nativeint_of_sexp: " ^ exn_to_string exc) sexp)
  | List _ -> of_sexp_error "nativeint_of_sexp: atom needed" sexp
;;

let ref_of_sexp a__of_sexp sexp = ref (a__of_sexp sexp)
let lazy_t_of_sexp a__of_sexp sexp = Lazy.from_val (a__of_sexp sexp)

let option_of_sexp a__of_sexp sexp =
  if !read_old_option_format
  then (
    match sexp with
    | List [] | Atom ("none" | "None") -> None
    | List [ el ] | List [ Atom ("some" | "Some"); el ] -> Some (a__of_sexp el)
    | List _ -> of_sexp_error "option_of_sexp: list must represent optional value" sexp
    | Atom _ -> of_sexp_error "option_of_sexp: only none can be atom" sexp)
  else (
    match sexp with
    | Atom ("none" | "None") -> None
    | List [ Atom ("some" | "Some"); el ] -> Some (a__of_sexp el)
    | Atom _ -> of_sexp_error "option_of_sexp: only none can be atom" sexp
    | List _ -> of_sexp_error "option_of_sexp: list must be (some el)" sexp)
;;

let pair_of_sexp a__of_sexp b__of_sexp sexp =
  match sexp with
  | List [ a_sexp; b_sexp ] ->
    let a = a__of_sexp a_sexp in
    let b = b__of_sexp b_sexp in
    a, b
  | List _ ->
    of_sexp_error "pair_of_sexp: list must contain exactly two elements only" sexp
  | Atom _ -> of_sexp_error "pair_of_sexp: list needed" sexp
;;

let triple_of_sexp a__of_sexp b__of_sexp c__of_sexp sexp =
  match sexp with
  | List [ a_sexp; b_sexp; c_sexp ] ->
    let a = a__of_sexp a_sexp in
    let b = b__of_sexp b_sexp in
    let c = c__of_sexp c_sexp in
    a, b, c
  | List _ ->
    of_sexp_error "triple_of_sexp: list must contain exactly three elements only" sexp
  | Atom _ -> of_sexp_error "triple_of_sexp: list needed" sexp
;;

let list_of_sexp a__of_sexp sexp =
  match sexp with
  | List lst -> List.map lst ~f:a__of_sexp
  | Atom _ -> of_sexp_error "list_of_sexp: list needed" sexp
;;

let array_of_sexp a__of_sexp sexp =
  match sexp with
  | List [] -> [||]
  | List (h :: t) ->
    let len = List.length t + 1 in
    let res = Array.make len (a__of_sexp h) in
    let rec loop i = function
      | [] -> res
      | h :: t ->
        res.(i) <- a__of_sexp h;
        loop (i + 1) t
    in
    loop 1 t
  | Atom _ -> of_sexp_error "array_of_sexp: list needed" sexp
;;

let hashtbl_of_sexp key_of_sexp val_of_sexp sexp =
  match sexp with
  | List lst ->
    let htbl = Hashtbl.create 0 in
    let act = function
      | List [ k_sexp; v_sexp ] ->
        Hashtbl.add htbl ~key:(key_of_sexp k_sexp) ~data:(val_of_sexp v_sexp)
      | List _ | Atom _ -> of_sexp_error "hashtbl_of_sexp: tuple list needed" sexp
    in
    List.iter lst ~f:act;
    htbl
  | Atom _ -> of_sexp_error "hashtbl_of_sexp: list needed" sexp
;;

let opaque_of_sexp sexp =
  of_sexp_error "opaque_of_sexp: cannot convert opaque values" sexp
;;

let fun_of_sexp sexp = of_sexp_error "fun_of_sexp: cannot convert function values" sexp

(* Sexp Grammars *)

include Sexp_conv_grammar

(* Registering default exception printers *)

let get_flc_error name (file, line, chr) = Atom (sprintf "%s %s:%d:%d" name file line chr)

let () =
  List.iter
    ~f:(fun (extension_constructor, handler) ->
      Exn_converter.add ~printexc:false ~finalise:false extension_constructor handler)
    [ ( [%extension_constructor Assert_failure]
      , function
        | Assert_failure arg -> get_flc_error "Assert_failure" arg
        | _ -> assert false )
    ; ( [%extension_constructor Exit]
      , function
        | Exit -> Atom "Exit"
        | _ -> assert false )
    ; ( [%extension_constructor End_of_file]
      , function
        | End_of_file -> Atom "End_of_file"
        | _ -> assert false )
    ; ( [%extension_constructor Failure]
      , function
        | Failure arg -> List [ Atom "Failure"; Atom arg ]
        | _ -> assert false )
    ; ( [%extension_constructor Not_found]
      , function
        | Not_found -> Atom "Not_found"
        | _ -> assert false )
    ; ( [%extension_constructor Invalid_argument]
      , function
        | Invalid_argument arg -> List [ Atom "Invalid_argument"; Atom arg ]
        | _ -> assert false )
    ; ( [%extension_constructor Match_failure]
      , function
        | Match_failure arg -> get_flc_error "Match_failure" arg
        | _ -> assert false )
    ; ( [%extension_constructor Not_found_s]
      , function
        | Not_found_s arg -> List [ Atom "Not_found_s"; arg ]
        | _ -> assert false )
    ; ( [%extension_constructor Sys_error]
      , function
        | Sys_error arg -> List [ Atom "Sys_error"; Atom arg ]
        | _ -> assert false )
    ; ( [%extension_constructor Arg.Help]
      , function
        | Arg.Help arg -> List [ Atom "Arg.Help"; Atom arg ]
        | _ -> assert false )
    ; ( [%extension_constructor Arg.Bad]
      , function
        | Arg.Bad arg -> List [ Atom "Arg.Bad"; Atom arg ]
        | _ -> assert false )
    ; ( [%extension_constructor Lazy.Undefined]
      , function
        | Lazy.Undefined -> Atom "Lazy.Undefined"
        | _ -> assert false )
    ; ( [%extension_constructor Parsing.Parse_error]
      , function
        | Parsing.Parse_error -> Atom "Parsing.Parse_error"
        | _ -> assert false )
    ; ( [%extension_constructor Queue.Empty]
      , function
        | Queue.Empty -> Atom "Queue.Empty"
        | _ -> assert false )
    ; ( [%extension_constructor Scanf.Scan_failure]
      , function
        | Scanf.Scan_failure arg -> List [ Atom "Scanf.Scan_failure"; Atom arg ]
        | _ -> assert false )
    ; ( [%extension_constructor Stack.Empty]
      , function
        | Stack.Empty -> Atom "Stack.Empty"
        | _ -> assert false )
    ; ( [%extension_constructor Sys.Break]
      , function
        | Sys.Break -> Atom "Sys.Break"
        | _ -> assert false )
    ]
;;

let () =
  List.iter
    ~f:(fun (extension_constructor, handler) ->
      Exn_converter.add ~printexc:true ~finalise:false extension_constructor handler)
    [ ( [%extension_constructor Of_sexp_error]
      , function
        | Of_sexp_error (exc, sexp) ->
          List [ Atom "Sexplib.Conv.Of_sexp_error"; sexp_of_exn exc; sexp ]
        | _ -> assert false )
    ]
;;

external ignore : _ -> unit = "%ignore"
external ( = ) : 'a -> 'a -> bool = "%equal"
end
module Sexp_conv_error = struct
(* Conv_error: Module for Handling Errors during Automated S-expression
   Conversions *)

open StdLabels
open Printf
open Sexp_conv

exception Of_sexp_error = Of_sexp_error

let error ~loc ~sexp msg = of_sexp_error (sprintf "%s_of_sexp: %s" loc msg) sexp
let simple_error msg loc sexp = error ~loc ~sexp msg

(* Errors concerning tuples *)

let tuple_of_size_n_expected loc n sexp =
  error ~loc ~sexp (sprintf "tuple of size %d expected" n)
;;

let tuple_pair_expected loc name sexp =
  let msg = sprintf "%s_of_sexp: expected a pair beginning with label %s" loc name in
  of_sexp_error msg sexp
;;

let tuple_incorrect_label loc name pos sexp =
  let msg =
    sprintf "%s_of_sexp: incorrect label for element %s at position %i" loc name pos
  in
  of_sexp_error msg sexp
;;

(* Errors concerning sum types *)

let stag_no_args = simple_error "this constructor does not take arguments"

let stag_incorrect_n_args loc tag sexp =
  error ~loc ~sexp (sprintf "sum tag %S has incorrect number of arguments" tag)
;;

let stag_takes_args = simple_error "this constructor requires arguments"
let nested_list_invalid_sum = simple_error "expected a variant type, saw a nested list"
let empty_list_invalid_sum = simple_error "expected a variant type, saw an empty list"
let unexpected_stag = simple_error "unexpected variant constructor"

(* Errors concerning records *)

let record_sexp_bool_with_payload =
  simple_error "record conversion: a [sexp.bool] field was given a payload."
;;

let record_only_pairs_expected =
  simple_error
    "record conversion: only pairs expected, their first element must be an atom"
;;

let record_invalid_fields ~what ~loc fld_names sexp =
  let fld_names_str = String.concat fld_names ~sep:" " in
  error ~loc ~sexp (sprintf "%s: %s" what fld_names_str)
;;

let record_duplicate_fields loc fld_names sexp =
  record_invalid_fields ~what:"duplicate fields" ~loc fld_names sexp
;;

let record_extra_fields loc fld_names sexp =
  record_invalid_fields ~what:"extra fields" ~loc fld_names sexp
;;

let rec record_get_undefined_loop fields = function
  | [] -> String.concat (List.rev fields) ~sep:" "
  | (true, field) :: rest -> record_get_undefined_loop (field :: fields) rest
  | _ :: rest -> record_get_undefined_loop fields rest
;;

let record_undefined_elements loc sexp lst =
  let undefined = record_get_undefined_loop [] lst in
  let msg = sprintf "the following record elements were undefined: %s" undefined in
  error ~loc ~sexp msg
;;

let record_list_instead_atom = simple_error "list instead of atom for record expected"

let record_poly_field_value =
  simple_error "cannot convert values of types resulting from polymorphic record fields"
;;

(* Errors concerning polymorphic variants *)

exception No_variant_match

let no_variant_match () = raise No_variant_match
let no_matching_variant_found = simple_error "no matching variant found"
let ptag_no_args = simple_error "polymorphic variant does not take arguments"

let ptag_incorrect_n_args loc cnstr sexp =
  error
    ~loc
    ~sexp
    (sprintf "polymorphic variant tag %S has incorrect number of arguments" cnstr)
;;

let ptag_takes_args = simple_error "polymorphic variant tag takes an argument"

let nested_list_invalid_poly_var =
  simple_error "a nested list is an invalid polymorphic variant"
;;

let empty_list_invalid_poly_var =
  simple_error "the empty list is an invalid polymorphic variant"
;;

let empty_type = simple_error "trying to convert an empty type"
end
module Sexp_conv_labeled_tuple : sig
(* Parses sexps for labeled tuples, a language feature currently only implemented in Jane
   Street's experimental branch of the compiler
   (https://github.com/ocaml-flambda/flambda-backend/). *)

module Fields : sig
  type _ t =
    | Field :
        { name : string
        ; conv : Sexp.t -> 'a
        ; rest : 'b t
        }
        -> ('a * 'b) t
    | Empty : unit t
end

val labeled_tuple_of_sexp
  :  caller:string
  -> fields:'a Fields.t
  -> create:('a -> 'b)
  -> Sexp.t
  -> 'b
end = struct
module Fields = struct
  type _ t =
    | Field :
        { name : string
        ; conv : Sexp.t -> 'a
        ; rest : 'b t
        }
        -> ('a * 'b) t
    | Empty : unit t

  let rec length_loop : type a. a t -> int -> int =
    fun t acc ->
    match t with
    | Empty -> acc
    | Field field -> length_loop field.rest (acc + 1)
  ;;

  let length t = length_loop t 0
end

let[@tail_mod_cons] rec of_list
  : type a.
    caller:string
    -> fields:a Fields.t
    -> len:int
    -> original_sexp:Sexp.t
    -> pos:int
    -> Sexp.t list
    -> a
  =
  fun ~caller ~fields ~len ~original_sexp ~pos list ->
  match fields with
  | Empty ->
    (match list with
     | [] -> ()
     | _ :: _ -> Sexp_conv_error.tuple_of_size_n_expected caller len original_sexp)
  | Field { name; conv; rest } ->
    (match list with
     | [] -> Sexp_conv_error.tuple_of_size_n_expected caller len original_sexp
     | sexp :: list ->
       (match sexp with
        | List [ Atom atom; sexp ] ->
          if String.equal atom name
          then
            ( conv sexp
            , of_list ~caller ~fields:rest ~len ~original_sexp ~pos:(pos + 1) list )
          else Sexp_conv_error.tuple_incorrect_label caller name pos original_sexp
        | _ -> Sexp_conv_error.tuple_pair_expected caller name sexp))
;;

let labeled_tuple_of_sexp ~caller ~fields ~create original_sexp =
  let len = Fields.length fields in
  match (original_sexp : Sexp.t) with
  | Atom _ -> Sexp_conv_error.tuple_of_size_n_expected caller len original_sexp
  | List list -> create (of_list ~caller ~fields ~len ~original_sexp ~pos:0 list)
;;
end
module Sexp_conv_record : sig
module Kind : sig
  (** A GADT specifying how to parse a record field. See documentation for
      [ppx_sexp_conv]. *)
  type (_, _) t =
    | Default : (unit -> 'a) -> ('a, Sexp.t -> 'a) t
    | Omit_nil : ('a, Sexp.t -> 'a) t
    | Required : ('a, Sexp.t -> 'a) t
    | Sexp_array : ('a array, Sexp.t -> 'a) t
    | Sexp_bool : (bool, unit) t
    | Sexp_list : ('a list, Sexp.t -> 'a) t
    | Sexp_option : ('a option, Sexp.t -> 'a) t
end

module Fields : sig
  (** A GADT specifying record fields. *)
  type _ t =
    | Empty : unit t
    | Field :
        { name : string
        ; kind : ('a, 'conv) Kind.t
        ; conv : 'conv
        ; rest : 'b t
        }
        -> ('a * 'b) t
end

(** Parses a record from a sexp that must be a list of fields.

    Uses [caller] as the source for error messages. Parses using the given [field]s. Uses
    [index_of_field] to look up field names found in sexps. If [allow_extra_fields] is
    true, extra fields are allowed and discarded without error. [create] is used to
    construct the final returned value.
*)
val record_of_sexp
  :  caller:string
  -> fields:'a Fields.t
  -> index_of_field:(string -> int)
  -> allow_extra_fields:bool
  -> create:('a -> 'b)
  -> Sexp.t
  -> 'b

(** Like [record_of_sexp], but for a list of sexps with no [List] wrapper. Used, for
    example, to parse arguments to a variant constructor with an inlined record argument.
    Reports [context] for parse errors when no more specific sexp is applicable. *)
val record_of_sexps
  :  caller:string
  -> context:Sexp.t
  -> fields:'a Fields.t
  -> index_of_field:(string -> int)
  -> allow_extra_fields:bool
  -> create:('a -> 'b)
  -> Sexp.t list
  -> 'b
end = struct
open! StdLabels
open! Sexp_conv
open! Sexp_conv_error

module Kind = struct
  type (_, _) t =
    | Default : (unit -> 'a) -> ('a, Sexp.t -> 'a) t
    | Omit_nil : ('a, Sexp.t -> 'a) t
    | Required : ('a, Sexp.t -> 'a) t
    | Sexp_array : ('a array, Sexp.t -> 'a) t
    | Sexp_bool : (bool, unit) t
    | Sexp_list : ('a list, Sexp.t -> 'a) t
    | Sexp_option : ('a option, Sexp.t -> 'a) t
end

module Fields = struct
  type _ t =
    | Empty : unit t
    | Field :
        { name : string
        ; kind : ('a, 'conv) Kind.t
        ; conv : 'conv
        ; rest : 'b t
        }
        -> ('a * 'b) t

  let length =
    let rec length_loop : type a. a t -> int -> int =
      fun t acc ->
      match t with
      | Field { rest; _ } -> length_loop rest (acc + 1)
      | Empty -> acc
    in
    fun t -> length_loop t 0
  ;;
end

module Malformed = struct
  (* Represents errors that can occur due to malformed record sexps. Accumulated as a
     value so we can report multiple names at once for extra fields, duplicate fields, or
     missing fields. *)
  type t =
    | Bool_payload
    | Extras of string list
    | Dups of string list
    | Missing of string list
    | Non_pair of Sexp.t option

  let combine a b =
    match a, b with
    (* choose the first bool-payload or non-pair error that occurs *)
    | ((Bool_payload | Non_pair _) as t), _ -> t
    | _, ((Bool_payload | Non_pair _) as t) -> t
    (* combine lists of similar errors *)
    | Extras a, Extras b -> Extras (a @ b)
    | Dups a, Dups b -> Dups (a @ b)
    | Missing a, Missing b -> Missing (a @ b)
    (* otherwise, dups > extras > missing *)
    | (Dups _ as t), _ | _, (Dups _ as t) -> t
    | (Extras _ as t), _ | _, (Extras _ as t) -> t
  ;;

  let raise t ~caller ~context =
    match t with
    | Bool_payload -> record_sexp_bool_with_payload caller context
    | Extras names -> record_extra_fields caller names context
    | Dups names -> record_duplicate_fields caller names context
    | Missing names ->
      List.map names ~f:(fun name -> true, name)
      |> record_undefined_elements caller context
    | Non_pair maybe_context ->
      let context = Option.value maybe_context ~default:context in
      record_only_pairs_expected caller context
  ;;
end

exception Malformed of Malformed.t

module State = struct
  (* Stores sexps corresponding to record fields, in the order the fields were declared.
     Excludes fields already parsed in the fast path.

     List sexps represent a field that is present, such as (x 1) for a field named "x".
     Atom sexps represent a field that is absent, or at least not yet seen. *)
  type t = { state : Sexp.t array } [@@unboxed]

  let unsafe_get t pos = Array.unsafe_get t.state pos
  let unsafe_set t pos sexp = Array.unsafe_set t.state pos sexp
  let absent = Sexp.Atom ""
  let create len = { state = Array.make len absent }
end

(* Parsing field values from state. *)

let rec parse_value_malformed
  : type a b. Malformed.t -> fields:(a * b) Fields.t -> state:State.t -> pos:int -> a
  =
  fun malformed ~fields ~state ~pos ->
  let (Field field) = fields in
  let malformed =
    match parse_values ~fields:field.rest ~state ~pos:(pos + 1) with
    | (_ : b) -> malformed
    | exception Malformed other -> Malformed.combine malformed other
  in
  raise (Malformed malformed)

and parse_value : type a b. fields:(a * b) Fields.t -> state:State.t -> pos:int -> a * b =
  fun ~fields ~state ~pos ->
  let (Field { name; kind; conv; rest }) = fields in
  let value : a =
    match kind, State.unsafe_get state pos with
    (* well-formed *)
    | Required, List [ _; sexp ] -> conv sexp
    | Default _, List [ _; sexp ] -> conv sexp
    | Omit_nil, List [ _; sexp ] -> conv sexp
    | Sexp_option, List [ _; sexp ] -> Some (conv sexp)
    | Sexp_list, List [ _; sexp ] -> list_of_sexp conv sexp
    | Sexp_array, List [ _; sexp ] -> array_of_sexp conv sexp
    | Sexp_bool, List [ _ ] -> true
    (* ill-formed *)
    | ( (Required | Default _ | Omit_nil | Sexp_option | Sexp_list | Sexp_array)
      , (List (_ :: _ :: _ :: _) as sexp) ) ->
      parse_value_malformed (Non_pair (Some sexp)) ~fields ~state ~pos
    | ( (Required | Default _ | Omit_nil | Sexp_option | Sexp_list | Sexp_array)
      , List ([] | [ _ ]) ) -> parse_value_malformed (Non_pair None) ~fields ~state ~pos
    | Sexp_bool, List ([] | _ :: _ :: _) ->
      parse_value_malformed Bool_payload ~fields ~state ~pos
    (* absent *)
    | Required, Atom _ -> parse_value_malformed (Missing [ name ]) ~fields ~state ~pos
    | Default default, Atom _ -> default ()
    | Omit_nil, Atom _ -> conv (List [])
    | Sexp_option, Atom _ -> None
    | Sexp_list, Atom _ -> []
    | Sexp_array, Atom _ -> [||]
    | Sexp_bool, Atom _ -> false
  in
  value, parse_values ~fields:rest ~state ~pos:(pos + 1)

and parse_values : type a. fields:a Fields.t -> state:State.t -> pos:int -> a =
  fun ~fields ~state ~pos ->
  match fields with
  | Field _ -> parse_value ~fields ~state ~pos
  | Empty -> ()
;;

(* Populating state. Handles slow path cases where there may be reordered, duplicated,
   missing, or extra fields. *)

let rec parse_spine_malformed malformed ~index ~extra ~seen ~state ~len sexps =
  let malformed =
    match parse_spine_slow ~index ~extra ~seen ~state ~len sexps with
    | () -> malformed
    | exception Malformed other -> Malformed.combine malformed other
  in
  raise (Malformed malformed)

and parse_spine_slow ~index ~extra ~seen ~state ~len sexps =
  match (sexps : Sexp.t list) with
  | [] -> ()
  | (List (Atom name :: _) as field) :: sexps ->
    let i = index name in
    (match seen <= i && i < len with
     | true ->
       (* valid field for slow-path parsing *)
       let pos = i - seen in
       (match State.unsafe_get state pos with
        | Atom _ ->
          (* field not seen yet *)
          State.unsafe_set state pos field;
          parse_spine_slow ~index ~extra ~seen ~state ~len sexps
        | List _ ->
          (* field already seen *)
          parse_spine_malformed (Dups [ name ]) ~index ~extra ~seen ~state ~len sexps)
     | false ->
       (match 0 <= i && i < seen with
        | true ->
          (* field seen in fast path *)
          parse_spine_malformed (Dups [ name ]) ~index ~extra ~seen ~state ~len sexps
        | false ->
          (* extra field *)
          (match extra with
           | true -> parse_spine_slow ~index ~extra ~seen ~state ~len sexps
           | false ->
             parse_spine_malformed (Extras [ name ]) ~index ~extra ~seen ~state ~len sexps)))
  | sexp :: sexps ->
    parse_spine_malformed (Non_pair (Some sexp)) ~index ~extra ~seen ~state ~len sexps
;;

(* Slow path for record parsing. Uses state to store fields as they are discovered. *)

let parse_record_slow ~fields ~index ~extra ~seen sexps =
  let unseen = Fields.length fields in
  let state = State.create unseen in
  let len = seen + unseen in
  (* populate state *)
  parse_spine_slow ~index ~extra ~seen ~state ~len sexps;
  (* parse values from state *)
  parse_values ~fields ~state ~pos:0
;;

(* Fast path for record parsing. Directly parses and returns fields in the order they are
   declared. Falls back on slow path if any fields are absent, reordered, or malformed. *)

let rec parse_field_fast
  : type a b.
    fields:(a * b) Fields.t
    -> index:(string -> int)
    -> extra:bool
    -> seen:int
    -> Sexp.t list
    -> a * b
  =
  fun ~fields ~index ~extra ~seen sexps ->
  let (Field { name; kind; conv; rest }) = fields in
  match sexps with
  | List (Atom atom :: args) :: others when String.equal atom name ->
    (match kind, args with
     | Required, [ sexp ] ->
       conv sexp, parse_spine_fast ~fields:rest ~index ~extra ~seen:(seen + 1) others
     | Default _, [ sexp ] ->
       conv sexp, parse_spine_fast ~fields:rest ~index ~extra ~seen:(seen + 1) others
     | Omit_nil, [ sexp ] ->
       conv sexp, parse_spine_fast ~fields:rest ~index ~extra ~seen:(seen + 1) others
     | Sexp_option, [ sexp ] ->
       ( Some (conv sexp)
       , parse_spine_fast ~fields:rest ~index ~extra ~seen:(seen + 1) others )
     | Sexp_list, [ sexp ] ->
       ( list_of_sexp conv sexp
       , parse_spine_fast ~fields:rest ~index ~extra ~seen:(seen + 1) others )
     | Sexp_array, [ sexp ] ->
       ( array_of_sexp conv sexp
       , parse_spine_fast ~fields:rest ~index ~extra ~seen:(seen + 1) others )
     | Sexp_bool, [] ->
       true, parse_spine_fast ~fields:rest ~index ~extra ~seen:(seen + 1) others
     (* malformed field of some kind, dispatch to slow path *)
     | _, _ -> parse_record_slow ~fields ~index ~extra ~seen sexps)
  (* malformed or out-of-order field, dispatch to slow path *)
  | _ -> parse_record_slow ~fields ~index ~extra ~seen sexps

and parse_spine_fast
  : type a.
    fields:a Fields.t
    -> index:(string -> int)
    -> extra:bool
    -> seen:int
    -> Sexp.t list
    -> a
  =
  fun ~fields ~index ~extra ~seen sexps ->
  match fields with
  | Field _ -> parse_field_fast ~fields ~index ~extra ~seen sexps
  | Empty ->
    (match sexps with
     | [] -> ()
     | _ :: _ ->
       (* extra sexps, dispatch to slow path *)
       parse_record_slow ~fields ~index ~extra ~seen sexps)
;;

let parse_record_fast ~fields ~index ~extra sexps =
  parse_spine_fast ~fields ~index ~extra ~seen:0 sexps
;;

(* Entry points. *)

let record_of_sexps
  ~caller
  ~context
  ~fields
  ~index_of_field
  ~allow_extra_fields
  ~create
  sexps
  =
  let allow_extra_fields =
    allow_extra_fields || not !Sexp_conv.record_check_extra_fields
  in
  match
    parse_record_fast ~fields ~index:index_of_field ~extra:allow_extra_fields sexps
  with
  | value -> create value
  | exception Malformed malformed -> Malformed.raise malformed ~caller ~context
;;

let record_of_sexp ~caller ~fields ~index_of_field ~allow_extra_fields ~create sexp =
  match (sexp : Sexp.t) with
  | Atom _ as context -> record_list_instead_atom caller context
  | List sexps as context ->
    record_of_sexps
      ~caller
      ~context
      ~fields
      ~index_of_field
      ~allow_extra_fields
      ~create
      sexps
;;
end
module Sexplib0 = struct
module Sexp = Sexp
module Sexp_conv = Sexp_conv
module Sexp_conv_error = Sexp_conv_error
module Sexp_conv_record = Sexp_conv_record
module Sexp_conv_labeled_tuple = Sexp_conv_labeled_tuple
module Sexp_grammar = Sexp_grammar
module Sexpable = Sexpable
end
open Sexplib0
(* THIS FILE WAS AUTOMATICALLY GENERATED BY CAT'ING LIBRARY SOURCES *)
[@@@ocaml.warning "-27-32-35"]
module Import = struct
module Ppx_sexp_conv_lib = struct
  module Conv_error = Sexplib0.Sexp_conv_error
  module Conv = Sexplib0.Sexp_conv
  module Sexp = Sexplib0.Sexp
end

module Sexp = Sexplib0.Sexp
include Sexplib0.Sexp_conv
module List = ListLabels
end
module Positions : sig
(** Compact set of positions *)

open! Import

(** A [t] value represent a sequence of positions. The focus is on small memory footprint.

    Given a s-expression and a sequence of positions, one can reconstruct the location of
    every sub s-expression. This is used to report location informations without having to
    annotate every node in the s-expression during parsing.

    The s-expression parser saves the positions of each opening and closing parentheses as
    well as the positions of the first and last character of each atom.

    Note that a [t] can hold the same given positions no more than twice. The parser
    stores the same position twice for non-quoted single character atoms.
*)
type t [@@deriving_inline sexp_of]

include sig
  [@@@ocaml.warning "-32"]

  val sexp_of_t : t -> Sexplib0.Sexp.t
end
[@@ocaml.doc "@inline"]

[@@@end]

val compare : t -> t -> int

(** Represent a position in the input *)
type pos =
  { line : int (** Line number. The first line has number [1].               *)
  ; col : int (** Column number. The first column has number [0].           *)
  ; offset : int
      (** Number of bytes from the beginning of the input. The first
      byte has offset [0]. *)
  }
[@@deriving_inline sexp_of]

include sig
  [@@@ocaml.warning "-32"]

  val sexp_of_pos : pos -> Sexplib0.Sexp.t
end
[@@ocaml.doc "@inline"]

[@@@end]

val compare_pos : pos -> pos -> int
val beginning_of_file : pos
val shift_pos : pos -> cols:int -> pos

(** Range of positions, as reported in error messages. We follow the lexing conventions of
    OCaml, i.e. [start_pos] points to the first character and [end_pos] points to the
    position just after the last character.

    This allow for instance to represent empty ranges with [start_pos = end_pos].
*)
type range =
  { start_pos : pos
  ; end_pos : pos
  }
[@@deriving_inline sexp_of]

include sig
  [@@@ocaml.warning "-32"]

  val sexp_of_range : range -> Sexplib0.Sexp.t
end
[@@ocaml.doc "@inline"]

[@@@end]

val compare_range : range -> range -> int

(** Make a range from two positions where both positions are inclusive, i.e. [start_pos]
    points to the first character and [end_pos] points to the last one.
    The character at [last_pos] is assumed to not be a newline character. *)
val make_range_incl : start_pos:pos -> last_pos:pos -> range

module Builder : sig
  type positions
  type t

  val create : ?initial_pos:pos -> unit -> t

  (** [add], [add_twice] and [add_newline] must be called with strictly increasing
      [offset] values. *)

  (** int is absolute offset of the position *)
  val add : t -> offset:int -> unit

  val add_twice : t -> offset:int -> unit

  (** int is absolute offset of the newline character *)
  val add_newline : t -> offset:int -> unit

  val contents : t -> positions
  val reset : t -> pos -> unit
end
with type positions := t

(** Build the list of all positions in [t]. *)
val to_list : t -> pos list

(** Build the array of all positions in [t]. *)
val to_array : t -> pos array

(** [find t start stop] returns the range of positions starting at position with index
    [start] in [t] and ending at position with index [stop].

    [find t i j] is the same as:

    {[
      let a = to_array t in
      make_range_incl ~start_pos:a.(i) ~last_pos:a.(j)
    ]}

    but more efficient.
*)
val find : t -> int -> int -> range

(** [find_sub_sexp_phys t sexp ~sub] looks for [sub] in [sexp] and return its location,
    assuming [t] is the sequence of positions associated with [sexp].

    Comparison is done using physical equality.
*)
val find_sub_sexp_phys : t -> Sexp.t -> sub:Sexp.t -> range option

val find_sub_sexp_in_list_phys : t -> Sexp.t list -> sub:Sexp.t -> range option

(** Returns how much memory is used by [t] *)
val memory_footprint_in_bytes : t -> int

(** API for iterating over positions in an efficient way *)
module Iterator : sig
  type positions = t
  type t

  val create : positions -> t

  (** Exception raised when the iterator has reached the end of the sequence. *)
  exception No_more

  (** [advance t ~skip] skips the next [skip] positions in the sequence, advance to the
      next position and return it.
      Raises [No_more] when reaching the end of the position set. *)
  val advance_exn : t -> skip:int -> pos

  (** Advance over a whole s-expression worth of positions. Returns the position range
      corresponding to that s-expression. *)
  val advance_sexp_exn : t -> Sexp.t -> range
end
with type positions := t
end = struct
(* This module builds a buffer of "instructions", in order to represent a compact sequence
   of delimiting positions and newlines. The parser stores the positions of each:

   - newline
   - beginning of atom
   - end of atom
   - left parenthesis
   - right parenthesis

   Instructions are encoded as a sequence bits. The next instruction is determined by
   looking at the next few bits:

   - bit 0 represents a saved position followed by an offset increment
   - bits 10 represent an offset increment
   - bits 110 are followed by 5 bits of payload. The 5-bit payloads of any subsequent 110-
     instructions are squashed to form a number (least significant 5-bit chunk first).
     This number + 5 represents an offset increment
   - bits 1110 marks the beginning of a new line (with offset incremented)
   - bits 1111 represent a position saved twice followed by an offset increment

   For instance let's consider the following sexp:

   {[
     {|
(abc
      "foo
 bar"
)
|}
   ]}

   the sequence of instructions to record in order to reconstruct the position of any
   sub-sexp is:

   - 0         save position and advance 1: first '('
   - 0         save position and advance 1: start of "abc"
   - 10        advance 1
   - 0         save position and advance 1: end of "abc"
   - 1110      newline
   - 1100_0001 advance 6
   - 0         save position and advance 1: start of "foo\n  bar"
   - 10        advance 1
   - 10        advance 1
   - 10        advance 1
   - 1110      newline
   - 1100_0000 advance 5
   - 0         save position and advance 1: end of "foo\n  bar"
   - 1110      newline
   - 0         save position and advance 1: last ')'

   (we save the position after the closing parenthesis)

   The total sequence is 42 bits, so we need 6 bytes to store it

   The sequence of bits is encoded as a sequence of 16-bit values, where the earlier bits
   are most significant.

   Note that the parser stores the end positions as inclusive. This way only single
   character atoms require a double positions. If we were storing end positions as
   exclusive, we would need double positions for [)(] and [a(], which are likely to be
   frequent in s-expressions printed with the non [_hum] printer. We expect single
   character atoms to be less frequent so it makes sense to penalize them instead.
*)

open! Import

type pos =
  { line : int
  ; col : int
  ; offset : int
  }
[@@deriving_inline sexp_of]

let sexp_of_pos =
  (fun { line = line__002_; col = col__004_; offset = offset__006_ } ->
     let bnds__001_ = ([] : _ Stdlib.List.t) in
     let bnds__001_ =
       let arg__007_ = sexp_of_int offset__006_ in
       (Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "offset"; arg__007_ ] :: bnds__001_
         : _ Stdlib.List.t)
     in
     let bnds__001_ =
       let arg__005_ = sexp_of_int col__004_ in
       (Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "col"; arg__005_ ] :: bnds__001_
         : _ Stdlib.List.t)
     in
     let bnds__001_ =
       let arg__003_ = sexp_of_int line__002_ in
       (Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "line"; arg__003_ ] :: bnds__001_
         : _ Stdlib.List.t)
     in
     Sexplib0.Sexp.List bnds__001_
    : pos -> Sexplib0.Sexp.t)
;;

[@@@end]

let compare_pos = Stdlib.compare
let beginning_of_file = { line = 1; col = 0; offset = 0 }
let shift_pos pos ~cols = { pos with col = pos.col + cols; offset = pos.offset + cols }

type range =
  { start_pos : pos
  ; end_pos : pos
  }
[@@deriving_inline sexp_of]

let sexp_of_range =
  (fun { start_pos = start_pos__009_; end_pos = end_pos__011_ } ->
     let bnds__008_ = ([] : _ Stdlib.List.t) in
     let bnds__008_ =
       let arg__012_ = sexp_of_pos end_pos__011_ in
       (Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "end_pos"; arg__012_ ] :: bnds__008_
         : _ Stdlib.List.t)
     in
     let bnds__008_ =
       let arg__010_ = sexp_of_pos start_pos__009_ in
       (Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "start_pos"; arg__010_ ] :: bnds__008_
         : _ Stdlib.List.t)
     in
     Sexplib0.Sexp.List bnds__008_
    : range -> Sexplib0.Sexp.t)
;;

[@@@end]

let compare_range = Stdlib.compare

let make_range_incl ~start_pos ~last_pos =
  { start_pos; end_pos = shift_pos last_pos ~cols:1 }
;;

module Chunk : sig
  (** Represents an array of [length/2] signed 16-bit values *)
  type t

  (** Length in bytes. *)
  val length : int

  val alloc : unit -> t

  (** [get16 ~pos] and [set16 ~pos] manipulate the [pos/2]th stored value.
      [pos] must be even.
      [set16 x] only uses the 16 least significant bits of [x]. *)
  val get16 : t -> pos:int -> int

  val set16 : t -> pos:int -> int -> unit
end = struct
  type t = bytes

  (* OCaml strings always waste two bytes at the end, so we take a power of two minus two
     to be sure we don't waste space. *)
  let length = 62
  let alloc () = Bytes.create length

  external get16 : bytes -> pos:int -> int = "%caml_bytes_get16"
  external set16 : bytes -> pos:int -> int -> unit = "%caml_bytes_set16"

  (* If we want to make a [Positions.t] serializable:

     {[
       external bswap16 : int -> int = "%bswap16";;

       let get16 =
         if Caml.Sys.arch_big_endian then
           fun buf ~pos -> get16 buf ~pos |> bswap16
         else
           get16

       let set16 =
         if Caml.Sys.arch_big_endian then
           fun buf ~pos x -> set16 buf ~pos (bswap16 x)
         else
           set16
     ]}
  *)
end

type t_ =
  { chunks : Chunk.t list
  ; (* [num_bytes * 8 + extra_bits] is the number of bits stored in [chunks].
       The last [extra_bits] bits will be stored as the *least* significant bits
       of the appropriate pair of bytes of the last chunk. *)
    num_bytes : int
  ; extra_bits : int
  ; initial_pos : pos
  }

type t = t_ Lazy.t

let memory_footprint_in_bytes (lazy t) =
  let num_fields = 4 in
  let header_words = 1 in
  let word_bytes =
    match Sys.word_size with
    | 32 -> 4
    | 64 -> 8
    | _ -> assert false
  in
  let chunk_words =
    let div_ceil a b = (a + b - 1) / b in
    let n =
      div_ceil
        (Chunk.length
         + 1 (* NUL terminating bytes *)
         + 1 (* number of wasted bytes to fill a word *))
        word_bytes
    in
    n + header_words
  in
  let pos_fields = 3 in
  let pos_words = header_words + pos_fields in
  let list_cons_words = header_words + 2 in
  (header_words
   + num_fields
   + pos_words
   + (List.length t.chunks * (chunk_words + list_cons_words)))
  * word_bytes
;;

module Builder = struct
  type t =
    { mutable chunk : Chunk.t
    ; mutable chunk_pos : int
    ; mutable filled_chunks : Chunk.t list (* Filled chunks in reverse order *)
    ; mutable offset : int
        (* Offset of the last saved position or newline plus
       one, or [initial_pos] *)
    ; mutable int_buf : int
        (* the [num_bits] least significant bits of [int_buf]
       are the bits not yet pushed to [chunk]. *)
    ; mutable num_bits : int (* number of bits stored in [int_buf] *)
    ; mutable initial_pos : pos
    }

  let invariant t =
    assert (t.chunk_pos >= 0 && t.chunk_pos <= Chunk.length);
    assert (t.offset >= t.initial_pos.offset);
    assert (t.num_bits <= 15)
  ;;

  let check_invariant = false
  let invariant t = if check_invariant then invariant t

  let create ?(initial_pos = beginning_of_file) () =
    { chunk = Chunk.alloc ()
    ; chunk_pos = 0
    ; filled_chunks = []
    ; offset = initial_pos.offset
    ; int_buf = 0
    ; num_bits = 0
    ; initial_pos
    }
  ;;

  let reset t (pos : pos) =
    (* We need a new chunk as [contents] keeps the current chunk in the closure of the
       lazy value. *)
    t.chunk <- Chunk.alloc ();
    t.chunk_pos <- 0;
    t.filled_chunks <- [];
    t.offset <- pos.offset;
    t.int_buf <- 0;
    t.num_bits <- 0;
    t.initial_pos <- pos
  ;;

  let[@inline never] alloc_new_chunk t =
    t.filled_chunks <- t.chunk :: t.filled_chunks;
    t.chunk <- Chunk.alloc ();
    t.chunk_pos <- 0
  ;;

  let add_uint16 t n =
    if t.chunk_pos = Chunk.length then alloc_new_chunk t;
    Chunk.set16 t.chunk ~pos:t.chunk_pos n
  ;;

  let add_bits t n ~num_bits =
    let int_buf = (t.int_buf lsl num_bits) lor n in
    let num_bits = t.num_bits + num_bits in
    t.int_buf <- int_buf;
    if num_bits < 16
    then t.num_bits <- num_bits
    else (
      let num_bits = num_bits - 16 in
      t.num_bits <- num_bits;
      add_uint16 t (int_buf lsr num_bits);
      t.chunk_pos <- t.chunk_pos + 2
      (* no need to clear the bits of int_buf we just wrote, as further set16 will ignore
         these extra bits. *))
  ;;

  let contents t =
    (* Flush the current [t.int_buf] *)
    add_uint16 t t.int_buf;
    let rev_chunks = t.chunk :: t.filled_chunks in
    let chunk_pos = t.chunk_pos in
    let extra_bits = t.num_bits in
    let initial_pos = t.initial_pos in
    lazy
      { chunks = List.rev rev_chunks
      ; num_bytes = ((List.length rev_chunks - 1) * Chunk.length) + chunk_pos
      ; extra_bits
      ; initial_pos
      }
  ;;

  let long_shift t n =
    let n = ref (n - 5) in
    while !n > 0 do
      add_bits t (0b1100_0000 lor (!n land 0b0001_1111)) ~num_bits:8;
      n := !n lsr 5
    done
  ;;

  (* precondition: n >= 5 *)
  let[@inline never] add_gen_slow t n ~instr ~instr_bits =
    long_shift t n;
    add_bits t instr ~num_bits:instr_bits
  ;;

  let shift4 = 0b10_10_10_10

  let[@inline always] add_gen t ~offset ~instr ~instr_bits =
    invariant t;
    let n = offset - t.offset in
    t.offset <- offset + 1;
    match n with
    | 0 | 1 | 2 | 3 | 4 ->
      let num_bits = (n lsl 1) + instr_bits in
      add_bits t ((shift4 lsl instr_bits) lor instr land ((1 lsl num_bits) - 1)) ~num_bits
    | 5
    | 6
    | 7
    | 8
    | 9
    | 10
    | 11
    | 12
    | 13
    | 14
    | 15
    | 16
    | 17
    | 18
    | 19
    | 20
    | 21
    | 22
    | 23
    | 24
    | 25
    | 26
    | 27
    | 28
    | 29
    | 30
    | 31
    | 32
    | 33
    | 34
    | 35
    | 36 ->
      add_bits
        t
        (((0b1100_0000 lor (n - 5)) lsl instr_bits) lor instr)
        ~num_bits:(8 + instr_bits)
    | _ ->
      if n < 0 then invalid_arg "Parsexp.Positions.add_gen";
      add_gen_slow t n ~instr ~instr_bits
  ;;

  let add t ~offset = add_gen t ~offset ~instr:0b0 ~instr_bits:1
  let add_twice t ~offset = add_gen t ~offset ~instr:0b1111 ~instr_bits:4
  let add_newline t ~offset = add_gen t ~offset ~instr:0b1110 ~instr_bits:4
end

type positions = t

let rec sub_sexp_count (sexp : Sexp.t) =
  match sexp with
  | Atom _ -> 1
  | List l -> List.fold_left l ~init:1 ~f:(fun acc x -> acc + sub_sexp_count x)
;;

let sexp_positions_count sexp = sub_sexp_count sexp * 2

module Iterator : sig
  type t

  val create : positions -> t

  exception No_more

  (* [advance t ~skip] ignores [skip] saved positions and returns the next saved position.
     Raises [No_more] when reaching the end of the position set. *)
  val advance_exn : t -> skip:int -> pos
  val advance_sexp_exn : t -> Sexp.t -> range
end = struct
  type t =
    { mutable chunk : Chunk.t
    ; mutable chunks : Chunk.t list
    ; (* [num_bytes * 8 + extra_bits] is the number of bits available from [instr_pos] in
         [chunk :: chunks]. *)
      mutable num_bytes : int
    ; extra_bits : int
    ; mutable instr_pos : int (* position in [chunk] *)
    ; mutable offset : int
    ; mutable line : int
    ; mutable bol : int
    ; mutable int_buf : int
    ; mutable num_bits : int (* Number of bits not yet consumed in [int_buf] *)
    ; mutable pending : pos option
    }

  let create ((lazy p) : positions) =
    match p.chunks with
    | [] -> assert false
    | chunk :: chunks ->
      { chunk
      ; chunks
      ; num_bytes = p.num_bytes
      ; extra_bits = p.extra_bits
      ; instr_pos = 0
      ; offset = p.initial_pos.offset
      ; line = p.initial_pos.line
      ; bol = p.initial_pos.offset - p.initial_pos.col
      ; int_buf = 0
      ; num_bits = 0
      ; pending = None
      }
  ;;

  exception No_more

  let no_more () = raise_notrace No_more

  let[@inline never] fetch_chunk t =
    match t.chunks with
    | [] -> assert false
    | chunk :: chunks ->
      t.instr_pos <- 0;
      t.num_bytes <- t.num_bytes - Chunk.length;
      t.chunk <- chunk;
      t.chunks <- chunks
  ;;

  let fetch t =
    if t.instr_pos > t.num_bytes then no_more ();
    if t.instr_pos = Chunk.length then fetch_chunk t;
    let v = Chunk.get16 t.chunk ~pos:t.instr_pos in
    let added_bits = if t.instr_pos = t.num_bytes then t.extra_bits else 16 in
    t.int_buf <- (t.int_buf lsl added_bits) lor (v land ((1 lsl added_bits) - 1));
    t.num_bits <- t.num_bits + added_bits;
    t.instr_pos <- t.instr_pos + 2
  ;;

  let next_instruction_bits t ~num_bits =
    if t.num_bits < num_bits
    then (
      fetch t;
      if t.num_bits < num_bits then no_more ());
    let n = (t.int_buf lsr (t.num_bits - num_bits)) land ((1 lsl num_bits) - 1) in
    t.num_bits <- t.num_bits - num_bits;
    n
  ;;

  (* [offset_shift] and [offset_shift_num_bits] encode the offset number
     specified by the immediately preceding [110] instructions. *)
  let rec advance t ~skip ~offset_shift ~offset_shift_num_bits =
    match next_instruction_bits t ~num_bits:1 with
    | 0 ->
      (* bit seq 0 -> new item *)
      let offset = t.offset + offset_shift in
      t.offset <- offset + 1;
      if skip = 0
      then { line = t.line; col = offset - t.bol; offset }
      else advance t ~skip:(skip - 1) ~offset_shift:0 ~offset_shift_num_bits:0
    | _ ->
      (match next_instruction_bits t ~num_bits:1 with
       | 0 ->
         (* bit seq 10 -> shift *)
         t.offset <- t.offset + offset_shift + 1;
         advance t ~skip ~offset_shift:0 ~offset_shift_num_bits:0
       | _ ->
         (match next_instruction_bits t ~num_bits:1 with
          | 0 ->
            (* bit seq 110 -> long shift *)
            let n = next_instruction_bits t ~num_bits:5 in
            let offset_shift = if offset_shift_num_bits = 0 then 5 else offset_shift in
            advance
              t
              ~skip
              ~offset_shift:(offset_shift + (n lsl offset_shift_num_bits))
              ~offset_shift_num_bits:(offset_shift_num_bits + 5)
          | _ ->
            (match next_instruction_bits t ~num_bits:1 with
             | 0 ->
               (* bit seq 1110 -> newline *)
               t.offset <- t.offset + offset_shift + 1;
               t.bol <- t.offset;
               t.line <- t.line + 1;
               advance t ~skip ~offset_shift:0 ~offset_shift_num_bits:0
             | _ ->
               (* bit seq 1111 -> 2 new items *)
               let offset = t.offset + offset_shift in
               t.offset <- offset + 1;
               if skip <= 1
               then (
                 let pos = { line = t.line; col = offset - t.bol; offset } in
                 if skip = 0 then t.pending <- Some pos;
                 pos)
               else advance t ~skip:(skip - 2) ~offset_shift:0 ~offset_shift_num_bits:0)))
  ;;

  let advance_exn t ~skip =
    match t.pending with
    | Some pos ->
      t.pending <- None;
      if skip = 0
      then pos
      else advance t ~skip:(skip - 1) ~offset_shift:0 ~offset_shift_num_bits:0
    | None -> advance t ~skip ~offset_shift:0 ~offset_shift_num_bits:0
  ;;

  let advance_sexp_exn t sexp =
    let positions_count = sexp_positions_count sexp in
    let start_pos = advance_exn t ~skip:0 in
    let last_pos = advance_exn t ~skip:(positions_count - 2) in
    make_range_incl ~start_pos ~last_pos
  ;;
end

let find t a b =
  if a < 0 || b <= a then invalid_arg "Parsexp.Positions.find";
  let iter = Iterator.create t in
  try
    let start_pos = Iterator.advance_exn iter ~skip:a in
    let last_pos = Iterator.advance_exn iter ~skip:(b - a - 1) in
    make_range_incl ~start_pos ~last_pos
  with
  | Iterator.No_more -> failwith "Parsexp.Position.find"
;;

module Sexp_search = struct
  exception Found of int

  let rec loop ~sub index (sexp : Sexp.t) =
    if sexp == sub
    then raise_notrace (Found index)
    else (
      match sexp with
      | Atom _ -> index + 2
      | List l ->
        let index = loop_list ~sub (index + 1) l in
        index + 1)

  and loop_list ~sub index (sexps : Sexp.t list) =
    List.fold_left sexps ~init:index ~f:(loop ~sub)
  ;;

  let finalize t ~sub a =
    let b = a + (sub_sexp_count sub * 2) - 1 in
    Some (find t a b)
  ;;

  let find_sub_sexp_phys t sexp ~sub =
    match loop ~sub 0 sexp with
    | (_ : int) -> None
    | exception Found n -> finalize t ~sub n
  ;;

  let find_sub_sexp_in_list_phys t sexps ~sub =
    match loop_list ~sub 0 sexps with
    | (_ : int) -> None
    | exception Found n -> finalize t ~sub n
  ;;
end

let find_sub_sexp_phys = Sexp_search.find_sub_sexp_phys
let find_sub_sexp_in_list_phys = Sexp_search.find_sub_sexp_in_list_phys

let to_list t =
  let iter = Iterator.create t in
  let rec loop acc =
    match Iterator.advance_exn iter ~skip:0 with
    | exception Iterator.No_more -> List.rev acc
    | pos -> loop (pos :: acc)
  in
  loop []
;;

let to_array t = to_list t |> Array.of_list
let compare t1 t2 = Stdlib.compare (to_array t1) (to_array t2)
let sexp_of_t t = sexp_of_array sexp_of_pos (to_array t)
end
module Parse_error_intf = struct
open! Import

module Reason = struct
  (*_ Some of these come from [Parsexp_symbolic_automaton.Parse_error_reason]. *)
  type t =
    (*$ Parsexp_cinaps_helpers.Gen_parse_error.print_constructors () *)
    | Automaton_in_error_state
    | Comment_token_in_unquoted_atom
    | Unexpected_char_parsing_dec_escape
    | Unexpected_char_parsing_hex_escape
    | Unexpected_character_after_cr
    | Unterminated_block_comment
    | Unterminated_quoted_string
    (*$*)
    | Closed_paren_without_opened
    | Escape_sequence_out_of_range
    | No_sexp_found_in_input
    | Sexp_comment_without_sexp
    | Too_many_sexps
    | Unclosed_paren
end

module type Parse_error = sig
  type t [@@deriving_inline sexp_of]

  include sig
    [@@@ocaml.warning "-32"]

    val sexp_of_t : t -> Sexplib0.Sexp.t
  end
  [@@ocaml.doc "@inline"]

  [@@@end]

  val position : t -> Positions.pos
  val message : t -> string

  (** Report an error in a style similar to OCaml, for instance:

      File "blah", line 42, character 10:
      Error: s-expression parsing error;
      unterminated quoted string.
  *)
  val report : Format.formatter -> filename:string -> t -> unit

  exception Parse_error of t

  (**/**)

  module Private : sig
    module Reason = Reason

    (** To match the old behavior, the old parser sometimes raised [Failure] and sometimes
        raised [Parse_error] *)
    val old_parser_exn : t -> [ `Parse_error | `Failure ]

    val raise : Reason.t -> Positions.pos -> at_eof:bool -> atom_buffer:Buffer.t -> 'a
  end
end
end
module Old_parser_cont_state : sig
open! Import

type t =
  | Parsing_toplevel_whitespace
  | Parsing_nested_whitespace
  | Parsing_atom
  | Parsing_list
  | Parsing_sexp_comment
  | Parsing_block_comment
[@@deriving_inline sexp_of]

include sig
  [@@@ocaml.warning "-32"]

  val sexp_of_t : t -> Sexplib0.Sexp.t
end
[@@ocaml.doc "@inline"]

[@@@end]

val to_string : t -> string
end = struct
open! Import

type t =
  | Parsing_toplevel_whitespace
  | Parsing_nested_whitespace
  | Parsing_atom
  | Parsing_list
  | Parsing_sexp_comment
  | Parsing_block_comment
[@@deriving_inline sexp_of]

let sexp_of_t =
  (function
   | Parsing_toplevel_whitespace -> Sexplib0.Sexp.Atom "Parsing_toplevel_whitespace"
   | Parsing_nested_whitespace -> Sexplib0.Sexp.Atom "Parsing_nested_whitespace"
   | Parsing_atom -> Sexplib0.Sexp.Atom "Parsing_atom"
   | Parsing_list -> Sexplib0.Sexp.Atom "Parsing_list"
   | Parsing_sexp_comment -> Sexplib0.Sexp.Atom "Parsing_sexp_comment"
   | Parsing_block_comment -> Sexplib0.Sexp.Atom "Parsing_block_comment"
    : t -> Sexplib0.Sexp.t)
;;

[@@@end]

let to_string t =
  match sexp_of_t t with
  | Atom s -> s
  | List _ -> failwith "BUG: [sexp_of_t] returned a [List _]"
;;
end
module Of_sexp_error : sig
open! Import

type t [@@deriving_inline sexp_of]

include sig
  [@@@ocaml.warning "-32"]

  val sexp_of_t : t -> Sexplib0.Sexp.t
end
[@@ocaml.doc "@inline"]

[@@@end]

(** Exception raised by the user function *)
val user_exn : t -> exn

(** S-expression that failed to be converted *)
val sub_sexp : t -> Sexp.t

(** Position of [sub_sexp t] in the original source, if found *)
val location : t -> Positions.range option

(** Similar to [Parse_error.report] *)
val report : Format.formatter -> filename:string -> t -> unit

(** Exception raised in case of a conversion error *)
exception Of_sexp_error of t

val raise : user_exn:exn -> sub_sexp:Sexp.t -> location:Positions.range option -> 'a
end = struct
open! Import

type t =
  { user_exn : exn
  ; sub_sexp : Sexp.t
  ; location : Positions.range option
  }
[@@deriving_inline sexp_of]

let sexp_of_t =
  (fun { user_exn = user_exn__002_; sub_sexp = sub_sexp__004_; location = location__006_ } ->
     let bnds__001_ = ([] : _ Stdlib.List.t) in
     let bnds__001_ =
       let arg__007_ = sexp_of_option Positions.sexp_of_range location__006_ in
       (Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "location"; arg__007_ ] :: bnds__001_
         : _ Stdlib.List.t)
     in
     let bnds__001_ =
       let arg__005_ = Sexp.sexp_of_t sub_sexp__004_ in
       (Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "sub_sexp"; arg__005_ ] :: bnds__001_
         : _ Stdlib.List.t)
     in
     let bnds__001_ =
       let arg__003_ = sexp_of_exn user_exn__002_ in
       (Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "user_exn"; arg__003_ ] :: bnds__001_
         : _ Stdlib.List.t)
     in
     Sexplib0.Sexp.List bnds__001_
    : t -> Sexplib0.Sexp.t)
;;

[@@@end]

let user_exn t = t.user_exn
let sub_sexp t = t.sub_sexp
let location t = t.location

let report ppf ~filename t =
  let line, start, stop =
    match t.location with
    | None -> 1, 0, 0
    | Some { start_pos; end_pos } ->
      start_pos.line, start_pos.col, start_pos.col + end_pos.offset - start_pos.offset
  in
  Format.fprintf
    ppf
    "File \"%s\", line %d, characters %d-%d:\n\
     Error: s-expression conversion error;\n\
     exception %s\n"
    filename
    line
    start
    stop
    (Sexplib0.Sexp_conv.printexc_prefer_sexp t.user_exn)
;;

exception Of_sexp_error of t [@@deriving_inline sexp_of]

let () =
  Sexplib0.Sexp_conv.Exn_converter.add [%extension_constructor Of_sexp_error] (function
    | Of_sexp_error arg0__008_ ->
      let res0__009_ = sexp_of_t arg0__008_ in
      Sexplib0.Sexp.List
        [ Sexplib0.Sexp.Atom "of_sexp_error.ml.Of_sexp_error"; res0__009_ ]
    | _ -> assert false)
;;

[@@@end]

let raise ~user_exn ~sub_sexp ~location =
  raise (Of_sexp_error { user_exn; sub_sexp; location })
;;
end
module Cst : sig
(** Concrete syntax tree of s-expressions *)

(** This module exposes a type that describe the full contents of a source file containing
    s-expressions.

    One can use this type to do low-level rewriting of s-expression files.
*)

open! Import

type t =
  | Atom of
      { loc : Positions.range
      ; atom : string
          (** Source syntax of atom. The parser only fills this for atoms that are quoted in
          the source, but it makes sense for unquoted atoms too (to ensure they get
          printed unquoted). *)
      ; unescaped : string option
      }
  | List of
      { loc : Positions.range
      ; elements : t_or_comment list
      }

and t_or_comment =
  | Sexp of t
  | Comment of comment

and comment =
  | Plain_comment of
      { loc : Positions.range
      ; comment : string
      } (** Line or block comment *)
  | Sexp_comment of
      { hash_semi_pos : Positions.pos
      ; comments : comment list
      ; sexp : t
      }
[@@deriving_inline sexp_of]

include sig
  [@@@ocaml.warning "-32"]

  val sexp_of_t : t -> Sexplib0.Sexp.t
  val sexp_of_t_or_comment : t_or_comment -> Sexplib0.Sexp.t
  val sexp_of_comment : comment -> Sexplib0.Sexp.t
end
[@@ocaml.doc "@inline"]

[@@@end]

val compare : t -> t -> int
val compare_t_or_comment : t_or_comment -> t_or_comment -> int
val compare_comment : comment -> comment -> int

module Forget : sig
  val t : t -> Ppx_sexp_conv_lib.Sexp.t
  val t_or_comment : t_or_comment -> Ppx_sexp_conv_lib.Sexp.t option
  val t_or_comments : t_or_comment list -> Ppx_sexp_conv_lib.Sexp.t list
end
end = struct
open! Import

type t =
  | Atom of
      { loc : Positions.range
      ; atom : string
      ; unescaped : string option
      }
  | List of
      { loc : Positions.range
      ; elements : t_or_comment list
      }

and t_or_comment =
  | Sexp of t
  | Comment of comment

and comment =
  | Plain_comment of
      { loc : Positions.range
      ; comment : string
      }
  | Sexp_comment of
      { hash_semi_pos : Positions.pos
      ; comments : comment list
      ; sexp : t
      }
[@@deriving_inline sexp_of]

let rec sexp_of_t =
  (function
   | Atom { loc = loc__002_; atom = atom__004_; unescaped = unescaped__006_ } ->
     let bnds__001_ = ([] : _ Stdlib.List.t) in
     let bnds__001_ =
       let arg__007_ = sexp_of_option sexp_of_string unescaped__006_ in
       (Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "unescaped"; arg__007_ ] :: bnds__001_
         : _ Stdlib.List.t)
     in
     let bnds__001_ =
       let arg__005_ = sexp_of_string atom__004_ in
       (Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "atom"; arg__005_ ] :: bnds__001_
         : _ Stdlib.List.t)
     in
     let bnds__001_ =
       let arg__003_ = Positions.sexp_of_range loc__002_ in
       (Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "loc"; arg__003_ ] :: bnds__001_
         : _ Stdlib.List.t)
     in
     Sexplib0.Sexp.List (Sexplib0.Sexp.Atom "Atom" :: bnds__001_)
   | List { loc = loc__009_; elements = elements__011_ } ->
     let bnds__008_ = ([] : _ Stdlib.List.t) in
     let bnds__008_ =
       let arg__012_ = sexp_of_list sexp_of_t_or_comment elements__011_ in
       (Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "elements"; arg__012_ ] :: bnds__008_
         : _ Stdlib.List.t)
     in
     let bnds__008_ =
       let arg__010_ = Positions.sexp_of_range loc__009_ in
       (Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "loc"; arg__010_ ] :: bnds__008_
         : _ Stdlib.List.t)
     in
     Sexplib0.Sexp.List (Sexplib0.Sexp.Atom "List" :: bnds__008_)
    : t -> Sexplib0.Sexp.t)

and sexp_of_t_or_comment =
  (function
   | Sexp arg0__013_ ->
     let res0__014_ = sexp_of_t arg0__013_ in
     Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "Sexp"; res0__014_ ]
   | Comment arg0__015_ ->
     let res0__016_ = sexp_of_comment arg0__015_ in
     Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "Comment"; res0__016_ ]
    : t_or_comment -> Sexplib0.Sexp.t)

and sexp_of_comment =
  (function
   | Plain_comment { loc = loc__018_; comment = comment__020_ } ->
     let bnds__017_ = ([] : _ Stdlib.List.t) in
     let bnds__017_ =
       let arg__021_ = sexp_of_string comment__020_ in
       (Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "comment"; arg__021_ ] :: bnds__017_
         : _ Stdlib.List.t)
     in
     let bnds__017_ =
       let arg__019_ = Positions.sexp_of_range loc__018_ in
       (Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "loc"; arg__019_ ] :: bnds__017_
         : _ Stdlib.List.t)
     in
     Sexplib0.Sexp.List (Sexplib0.Sexp.Atom "Plain_comment" :: bnds__017_)
   | Sexp_comment
       { hash_semi_pos = hash_semi_pos__023_
       ; comments = comments__025_
       ; sexp = sexp__027_
       } ->
     let bnds__022_ = ([] : _ Stdlib.List.t) in
     let bnds__022_ =
       let arg__028_ = sexp_of_t sexp__027_ in
       (Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "sexp"; arg__028_ ] :: bnds__022_
         : _ Stdlib.List.t)
     in
     let bnds__022_ =
       let arg__026_ = sexp_of_list sexp_of_comment comments__025_ in
       (Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "comments"; arg__026_ ] :: bnds__022_
         : _ Stdlib.List.t)
     in
     let bnds__022_ =
       let arg__024_ = Positions.sexp_of_pos hash_semi_pos__023_ in
       (Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "hash_semi_pos"; arg__024_ ] :: bnds__022_
         : _ Stdlib.List.t)
     in
     Sexplib0.Sexp.List (Sexplib0.Sexp.Atom "Sexp_comment" :: bnds__022_)
    : comment -> Sexplib0.Sexp.t)
;;

[@@@end]

let compare = Stdlib.compare
let compare_t_or_comment = Stdlib.compare
let compare_comment = Stdlib.compare

module Forget = struct
  (* In cps to prevent non-tail recursion.
     The polymorphism in the signature ensures that each function returns
     only through the continuation. *)
  module Cps : sig
    val forget_t : t -> (Sexp.t -> 'r) -> 'r
    val forget_toc : t_or_comment -> (Sexp.t option -> 'r) -> 'r
    val forget_tocs : t_or_comment list -> (Sexp.t list -> 'r) -> 'r
  end = struct
    let rec forget_t t k =
      match t with
      | Atom { atom; _ } -> k (Sexp.Atom atom)
      | List { elements; _ } -> forget_tocs elements (fun xs -> k (Sexp.List xs))

    and forget_tocs tocs k =
      match tocs with
      | [] -> k []
      | toc :: tocs ->
        forget_toc toc (function
          | None -> forget_tocs tocs k
          | Some x -> forget_tocs tocs (fun xs -> k (x :: xs)))

    and forget_toc toc k =
      match toc with
      | Comment _ -> k None
      | Sexp t -> forget_t t (fun x -> k (Some x))
    ;;
  end

  let t x = Cps.forget_t x (fun y -> y)
  let t_or_comment x = Cps.forget_toc x (fun y -> y)
  let t_or_comments x = Cps.forget_tocs x (fun y -> y)
end
end
module Automaton_stack_intf = struct
open! Import

(** Automaton stack represents a prefix of a sexp (or of a sexp sequence) while it's being
    parsed.  We have three different types of the stack depending on how much detail about
    the sexp structure is being recorded (just the sexp, sexp with comments and positions
    (CST), or just positions. *)

module type Automaton_stack = sig
  module For_cst : sig
    type t =
      | Empty (** at top-level *)
      | T_or_comment of Cst.t_or_comment * t (** after the given sexp or comment *)
      | Open of Positions.pos * t (** after the opening paren *)
      | In_sexp_comment of
          { hash_semi_pos : Positions.pos
          ; rev_comments : Cst.comment list
          ; stack : t
          }
          (** [In_sexp_comment] only indicates if the next s-expression is to be commented
          out, but if we are nested below parens below an sexp comment, the stack would
          look like [Open (.., In_sexp_comment ..)]. *)

    val empty : t

    (** Raises if [t] contains a partial sexp. *)
    val get_many : t -> Cst.t_or_comment list
  end

  (** The recorded positions are stored elsewhere *)
  module Just_positions : sig
    type t = unit

    val empty : t
  end

  type t =
    | Empty
    | Open of t
    | Sexp of Sexp.t * t

  val empty : t

  (** Raises if [t] is not exactly one complete sexp. *)
  val get_single : t -> Sexp.t

  (** Raises if [t] contains a partial sexp. *)
  val get_many : t -> Sexp.t list
end
end
module Parse_error : sig
include Parse_error_intf.Parse_error
end = struct
open! Import
include Parse_error_intf

type t =
  { position : Positions.pos
  ; message : string
  ; old_parser_exn : [ `Parse_error | `Failure ]
  }

let sexp_of_t { position; message; old_parser_exn = _ } : Sexp.t =
  List
    [ List [ Atom "position"; Positions.sexp_of_pos position ]
    ; List [ Atom "message"; sexp_of_string message ]
    ]
;;

let position t = t.position
let message t = t.message
let old_parser_exn t = t.old_parser_exn

let report ppf ~filename t =
  let pos = position t in
  let msg = message t in
  Format.fprintf
    ppf
    "File \"%s\", line %d, character %d:\nError: s-expression parsing error;\n%s\n"
    filename
    pos.line
    pos.col
    msg
;;

exception Parse_error of t [@@deriving_inline sexp]

let () =
  Sexplib0.Sexp_conv.Exn_converter.add [%extension_constructor Parse_error] (function
    | Parse_error arg0__001_ ->
      let res0__002_ = sexp_of_t arg0__001_ in
      Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "parse_error.ml.Parse_error"; res0__002_ ]
    | _ -> assert false)
;;

[@@@end]

let raise (reason : Reason.t) position ~at_eof ~atom_buffer =
  let message =
    (* These messages where choosen such that we can build the various Sexplib parsing
       functions on top of Parsexp and keep the same exceptions.

       At the time of writing this, a simple layer on top of parsexp to implement the
       sexplib API is passing all the sexplib tests.

       Note that parsexp matches the semantic of Sexp.parse which is slightly
       different from the ocamllex/ocamlyacc based parser of Sexplib. The latter one
       is less tested and assumed to be less used. *)
    match reason with
    | Unexpected_char_parsing_hex_escape -> "unterminated hexadecimal escape sequence"
    | Unexpected_char_parsing_dec_escape -> "unterminated decimal escape sequence"
    | Unterminated_quoted_string -> "unterminated quoted string"
    | Unterminated_block_comment -> "unterminated block comment"
    | Escape_sequence_out_of_range -> "escape sequence in quoted string out of range"
    | Unclosed_paren -> "unclosed parentheses at end of input"
    | Too_many_sexps -> "s-expression followed by data"
    | Closed_paren_without_opened -> "unexpected character: ')'"
    | Comment_token_in_unquoted_atom ->
      if String.equal (Buffer.contents atom_buffer) "|"
      then "illegal end of comment"
      else "comment tokens in unquoted atom"
    | Sexp_comment_without_sexp -> "unterminated sexp comment"
    | Unexpected_character_after_cr ->
      if at_eof
      then "unexpected end of input after carriage return"
      else "unexpected character after carriage return"
    | No_sexp_found_in_input -> "no s-expression found in input"
    | Automaton_in_error_state -> failwith "Parsexp.Parser_automaton: parser is dead"
  in
  let old_parser_exn =
    match reason, at_eof with
    | Too_many_sexps, _ | _, true -> `Failure
    | Comment_token_in_unquoted_atom, _
      when String.equal (Buffer.contents atom_buffer) "|" -> `Failure
    | _ -> `Parse_error
  in
  raise (Parse_error { position; message; old_parser_exn })
;;

module Private = struct
  module Reason = Reason

  let old_parser_exn = old_parser_exn
  let raise = raise
end
end
module Conv_error : sig
open! Import

type t =
  | Parse_error of Parse_error.t
  | Of_sexp_error of Of_sexp_error.t
[@@deriving_inline sexp_of]

include sig
  [@@@ocaml.warning "-32"]

  val sexp_of_t : t -> Sexplib0.Sexp.t
end
[@@ocaml.doc "@inline"]

[@@@end]

(** Similar to [Parse_error.report] *)
val report : Format.formatter -> filename:string -> t -> unit
end = struct
open! Import

type t =
  | Parse_error of Parse_error.t
  | Of_sexp_error of Of_sexp_error.t
[@@deriving_inline sexp_of]

let sexp_of_t =
  (function
   | Parse_error arg0__001_ ->
     let res0__002_ = Parse_error.sexp_of_t arg0__001_ in
     Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "Parse_error"; res0__002_ ]
   | Of_sexp_error arg0__003_ ->
     let res0__004_ = Of_sexp_error.sexp_of_t arg0__003_ in
     Sexplib0.Sexp.List [ Sexplib0.Sexp.Atom "Of_sexp_error"; res0__004_ ]
    : t -> Sexplib0.Sexp.t)
;;

[@@@end]

let report ppf ~filename t =
  match t with
  | Parse_error e -> Parse_error.report ppf ~filename e
  | Of_sexp_error e -> Of_sexp_error.report ppf ~filename e
;;
end
module Automaton_stack : sig
include Automaton_stack_intf.Automaton_stack
end = struct
open! Import
include Automaton_stack_intf

module For_cst = struct
  type t =
    | Empty
    | T_or_comment of Cst.t_or_comment * t
    | Open of Positions.pos * t
    | In_sexp_comment of
        { hash_semi_pos : Positions.pos
        ; rev_comments : Cst.comment list
        ; stack : t
        }

  let empty = Empty

  let get_many =
    let rec loop acc = function
      | Empty -> acc
      | T_or_comment (t, stack) -> loop (t :: acc) stack
      | Open _ | In_sexp_comment _ -> failwith "Automaton_stack.For_cst.get_many"
    in
    fun stack -> loop [] stack
  ;;
end

module Just_positions = struct
  type t = unit

  let empty = ()
end

type t =
  | Empty
  | Open of t
  | Sexp of Sexp.t * t

let empty = Empty

let get_single = function
  | Sexp (sexp, Empty) -> sexp
  | _ -> failwith "Automaton_stack.get_single"
;;

let get_many =
  let rec loop acc = function
    | Empty -> acc
    | Open _ -> failwith "Automaton_stack.get_many"
    | Sexp (sexp, stack) -> loop (sexp :: acc) stack
  in
  fun stack -> loop [] stack
;;
end
module Automaton_state_intf = struct
open! Import

module Context = struct
  type t =
    | Sexp_comment
    | Sexp
end

module For_cst = struct
  type t =
    { token_buffer : Buffer.t (** Starting positions of the current token **)
    ; mutable token_start_pos : Positions.pos
    }
  [@@deriving sexp_of]
end

module Kind = struct
  type ('u, 's) t =
    | Positions : (Positions.Builder.t, unit) t
    | Sexp : (unit, Automaton_stack.t) t
    | Sexp_with_positions : (Positions.Builder.t, Automaton_stack.t) t
    | Cst : (For_cst.t, Automaton_stack.For_cst.t) t
end

module rec State : sig
  type ('u, 's) t =
    { mutable automaton_state : int
    ; kind : ('u, 's) Kind.t
    ; mutable depth : int (** Number of opened #| when parsing a block comment *)
    ; mutable block_comment_depth : int
        (** Stack of ignoring depths; the current depth is pushed
        each time a #; comment is entered. *)
    ; mutable ignoring_stack : int list
        (** When parsing an escape sequence of the form "\\NNN" or "\\XX", this accumulates
        the computed number *)
    ; mutable escaped_value : int (** Buffer for accumulating atoms *)
    ; atom_buffer : Buffer.t
    ; user_state : 'u
    ; mode : ('u, 's) Mode.t
    ; mutable full_sexps : int
    ; mutable offset : int (** global offset **)
    ; mutable line_number : int
    ; mutable bol_offset : int (** offset of beginning of line **)
    }
end =
  State

and Mode : sig
  type ('u, 's) t =
    | Single
    | Many
    | Eager of
        { got_sexp : ('u, 's) State.t -> 's -> 's
        ; reraise_notrace : bool
        ; mutable no_sexp_is_error : bool
        }
end =
  Mode

module type Automaton_state = sig
  module Context = Context
  module For_cst = For_cst
  module Kind = Kind
  module Mode = Mode
  module State = State

  type ('u, 's) t = ('u, 's) State.t

  val create
    :  ?initial_pos:Positions.pos
    -> ('u, 's) Mode.t
    -> ('u, 's) Kind.t
    -> ('u, 's) t

  val reset : ?pos:Positions.pos -> _ t -> unit
  val positions : (Positions.Builder.t, _) t -> Positions.t
  val mode : ('u, 's) t -> ('u, 's) Mode.t

  (** Number of characters fed to the parser *)
  val offset : _ t -> int

  (** Position in the text *)
  val line : _ t -> int

  val column : _ t -> int

  (** Whether there are some unclosed parentheses *)
  val has_unclosed_paren : ('u, 's) t -> bool

  val set_error_state : _ t -> unit

  (**/**)

  (*_ Only for converting errors to the old parser errors *)
  val atom_buffer : _ t -> Buffer.t

  (*_ For coverate tests *)
  val automaton_state : ('u, 's) t -> int
  val context : _ t -> Context.t
end
end
module Automaton_state : sig
include Automaton_state_intf.Automaton_state
end = struct
open! Import
include Automaton_state_intf

type ('u, 's) t = ('u, 's) State.t

open State

let initial_user_state : type u s. (u, s) Kind.t -> Positions.pos -> u =
  fun kind initial_pos ->
  match kind with
  | Positions -> Positions.Builder.create ~initial_pos ()
  | Sexp -> ()
  | Sexp_with_positions -> Positions.Builder.create ~initial_pos ()
  | Cst ->
    (* [token_start_pos] is set to a dummy location here. It is properly set when we
       start to capture a token from the input *)
    { token_buffer = Buffer.create 128; token_start_pos = Positions.beginning_of_file }
;;

(*$ Parsexp_cinaps_helpers.Gen_automaton_state.print_constants () *)
let initial_state = 0
let error_state = 1

(*$*)

let create ?(initial_pos = Positions.beginning_of_file) mode kind =
  { kind
  ; depth = 0
  ; automaton_state = initial_state
  ; block_comment_depth = 0
  ; ignoring_stack = []
  ; escaped_value = 0
  ; atom_buffer = Buffer.create 128
  ; user_state = initial_user_state kind initial_pos
  ; mode
  ; full_sexps = 0
  ; offset = initial_pos.offset
  ; line_number = initial_pos.line
  ; bol_offset = initial_pos.offset - initial_pos.col
  }
;;

let mode t = t.mode
let positions t = Positions.Builder.contents t.user_state
let atom_buffer t = t.atom_buffer
let offset state = state.offset
let line state = state.line_number
let column state = state.offset - state.bol_offset
let position t = { Positions.col = column t; line = line t; offset = offset t }

let reset_user_state : type u s. (u, s) t -> unit =
  fun t ->
  match t.kind with
  | Positions -> Positions.Builder.reset t.user_state (position t)
  | Sexp -> ()
  | Sexp_with_positions -> Positions.Builder.reset t.user_state (position t)
  | Cst -> Buffer.clear t.user_state.token_buffer
;;

let reset ?(pos = Positions.beginning_of_file) t =
  t.depth <- 0;
  t.automaton_state <- initial_state;
  t.block_comment_depth <- 0;
  t.ignoring_stack <- [];
  t.escaped_value <- 0;
  t.full_sexps <- 0;
  t.offset <- pos.offset;
  t.line_number <- pos.line;
  t.bol_offset <- pos.offset - pos.col;
  reset_user_state t;
  Buffer.clear t.atom_buffer
;;

let context state : Context.t =
  match state.ignoring_stack with
  | _ :: _ -> Sexp_comment
  | [] -> Sexp
;;

let has_unclosed_paren state = state.depth > 0
let set_error_state state = state.automaton_state <- error_state
let automaton_state state = state.automaton_state
end
module Automaton_intf = struct
(** Convenience functions for feeding the automaton. *)

open! Import

module type Automaton = sig
  module Stack = Automaton_stack

  include module type of struct
    include Automaton_state
  end

  val feed_bytes : (_, 'stack) t -> bytes -> 'stack -> 'stack
  val feed_string : (_, 'stack) t -> string -> 'stack -> 'stack
  val feed_subbytes : (_, 'stack) t -> bytes -> pos:int -> len:int -> 'stack -> 'stack
  val feed_substring : (_, 'stack) t -> string -> pos:int -> len:int -> 'stack -> 'stack
  val feed : ('a, 'b) t -> char -> 'b -> 'b
  val feed_eoi : ('a, 'b) t -> 'b -> 'b
  val old_parser_cont_state : ('a, 'b) t -> Old_parser_cont_state.t

  val of_substring
    :  ('u, 's) Mode.t
    -> ('u, 's) Kind.t
    -> string
    -> pos:int
    -> len:int
    -> ('u, 's) t * 's
end
end
module Automaton_action : sig
(** Internal bits used by the generated automaton, not part of the public API *)

open! Import

val raise_error : _ Automaton_state.t -> at_eof:bool -> Parse_error.Private.Reason.t -> _

type context = Automaton_state.Context.t =
  | Sexp_comment
  | Sexp

val context : _ Automaton_state.t -> context
val set_automaton_state : ('u, 's) Automaton_state.t -> int -> unit

(** Advance the position counters. [advance_eol] is for when we read a newline
    character. *)
val advance : ('u, 's) Automaton_state.t -> unit

val advance_eol : ('u, 's) Automaton_state.t -> unit

(** Number of opened #| *)
val block_comment_depth : ('u, 's) Automaton_state.t -> int

type ('u, 's) t = ('u, 's) Automaton_state.t -> char -> 's -> 's

module Poly : sig
  type nonrec t = { f : 'u 's. ('u, 's) t } [@@unboxed]
end

module Epsilon : sig
  type ('u, 's) t = ('u, 's) Automaton_state.t -> 's -> 's

  module Poly : sig
    type nonrec t = { f : 'u 's. ('u, 's) t } [@@unboxed]
  end
end

(** Add a character to the atom buffer. [add_quoted_atom_char] does the same for quoted
    atoms *)
val add_atom_char : _ t

val add_quoted_atom_char : _ t

(** Add a character that just follows a '\\' and the '\\' itself if necessary. *)
val add_escaped : _ t

(** [escaped_value <- escaped_value * 10 + (char - '0')]

    These functions make the assumption that [char] is between '0' and '9'.
    [add_dec_escape_char] also assumes the result doesn't overflow. The automaton
    definition must make sure this is the case.

    [add_last_dec_escape_char] also adds the resulting character to the atom buffer.
*)
val add_dec_escape_char : _ t

val add_last_dec_escape_char : _ t

(** Same but for quoted strings inside comments. Useful because it can fail. *)
val comment_add_last_dec_escape_char : _ t

(** Same as [add_dec_escape_char] but for hexadicemal escape sequences *)
val add_hex_escape_char : _ t

val add_last_hex_escape_char : _ t

(** Ignore one more full sexp to come *)
val start_sexp_comment : _ t

(** Add the first char of an unquoted atom. *)
val add_first_char : _ t

val start_quoted_string : _ t

(** Takes note of a control character in quoted atoms or the uninterpreted characters of
    comments, for which there is no corresponding [add_*] call (a backslash and the x in
    "\xff" or any character in a line comment).  This does not get called for the opening
    ([start_quoted_string]) or closing ([push_quoted_atom]) quotes themselves.
*)
val add_token_char : _ t

val opening : _ t
val closing : _ t
val push_quoted_atom : _ t
val start_block_comment : _ t
val end_block_comment : _ t
val start_line_comment : _ t
val end_line_comment : _ Epsilon.t
val eps_push_atom : _ Epsilon.t
val eps_add_first_char_hash : _ Epsilon.t
val eps_eoi_check : _ Epsilon.t
val eps_add_escaped_cr : _ Epsilon.t
end = struct
open! Import
open Automaton_state
open State

let raise_error : type a b. (a, b) Automaton_state.t -> _ =
  fun state ~at_eof reason ->
  set_error_state state;
  Parse_error.Private.raise
    reason
    { line = state.line_number
    ; col = state.offset - state.bol_offset
    ; offset = state.offset
    }
    ~at_eof
    ~atom_buffer:state.atom_buffer
;;

type nonrec context = Automaton_state.Context.t =
  | Sexp_comment
  | Sexp

let context = Automaton_state.context

type ('u, 's) t = ('u, 's) Automaton_state.t -> char -> 's -> 's

module Poly = struct
  type nonrec t = { f : 'u 's. ('u, 's) t } [@@unboxed]
end

module Epsilon = struct
  type ('u, 's) t = ('u, 's) Automaton_state.t -> 's -> 's

  module Poly = struct
    type nonrec t = { f : 'u 's. ('u, 's) t } [@@unboxed]
  end
end

let current_pos ?(delta = 0) state : Positions.pos =
  let offset = state.offset + delta in
  { line = state.line_number; col = offset - state.bol_offset; offset }
;;

let set_automaton_state state x = state.automaton_state <- x
let advance state = state.offset <- state.offset + 1

let advance_eol : type u s. (u, s) Automaton_state.t -> unit =
  fun state ->
  let newline_offset = state.offset in
  state.offset <- newline_offset + 1;
  state.bol_offset <- state.offset;
  state.line_number <- state.line_number + 1;
  match state.kind with
  | Positions -> Positions.Builder.add_newline state.user_state ~offset:newline_offset
  | Sexp_with_positions ->
    Positions.Builder.add_newline state.user_state ~offset:newline_offset
  | _ -> ()
;;

let block_comment_depth state = state.block_comment_depth

let add_token_char : type u s. (u, s) t =
  fun state char stack ->
  match state.kind with
  | Cst ->
    Buffer.add_char state.user_state.token_buffer char;
    stack
  | _ -> stack
;;

let add_atom_char state c stack =
  Buffer.add_char state.atom_buffer c;
  stack
;;

let add_quoted_atom_char state c stack =
  Buffer.add_char state.atom_buffer c;
  add_token_char state c stack
;;

let is_ignoring state =
  match context state with
  | Sexp -> false
  | Sexp_comment -> true
;;

let is_not_ignoring state = not (is_ignoring state)

let check_new_sexp_allowed state =
  let is_single =
    match state.mode with
    | Single -> true
    | _ -> false
  in
  if is_single && state.full_sexps > 0 && is_not_ignoring state
  then raise_error state ~at_eof:false Too_many_sexps
;;

let add_pos state ~delta =
  Positions.Builder.add state.user_state ~offset:(state.offset + delta)
;;

let add_first_char : type u s. (u, s) t =
  fun state char stack ->
  check_new_sexp_allowed state;
  Buffer.add_char state.atom_buffer char;
  (* For non-quoted atoms, we save both positions at the end. We can always determine the
     start position from the end position and the atom length for non-quoted atoms.

     Doing it this way allows us to detect single characater atoms for which we need to
     save the position twice. *)
  stack
;;

let eps_add_first_char_hash : type u s. (u, s) Epsilon.t =
  fun state stack ->
  check_new_sexp_allowed state;
  Buffer.add_char state.atom_buffer '#';
  stack
;;

let start_quoted_string : type u s. (u, s) t =
  fun state _char stack ->
  check_new_sexp_allowed state;
  match state.kind with
  | Positions ->
    if is_not_ignoring state then add_pos state ~delta:0;
    stack
  | Sexp_with_positions ->
    if is_not_ignoring state then add_pos state ~delta:0;
    stack
  | Cst ->
    state.user_state.token_start_pos <- current_pos state;
    Buffer.add_char state.user_state.token_buffer '"';
    stack
  | Sexp -> stack
;;

let add_escaped state c stack =
  let c' =
    match c with
    | 'n' -> '\n'
    | 'r' -> '\r'
    | 'b' -> '\b'
    | 't' -> '\t'
    | '\\' | '\'' | '"' -> c
    | _ ->
      Buffer.add_char state.atom_buffer '\\';
      c
  in
  Buffer.add_char state.atom_buffer c';
  add_token_char state c stack
;;

let eps_add_escaped_cr state stack =
  Buffer.add_char state.atom_buffer '\r';
  stack
;;

let dec_val c = Char.code c - Char.code '0'

let hex_val c =
  match c with
  | '0' .. '9' -> Char.code c - Char.code '0'
  | 'a' .. 'f' -> Char.code c - Char.code 'a' + 10
  | _ -> Char.code c - Char.code 'A' + 10
;;

let add_dec_escape_char state c stack =
  state.escaped_value <- (state.escaped_value * 10) + dec_val c;
  add_token_char state c stack
;;

let add_last_dec_escape_char state c stack =
  let value = (state.escaped_value * 10) + dec_val c in
  state.escaped_value <- 0;
  if value > 255 then raise_error state ~at_eof:false Escape_sequence_out_of_range;
  Buffer.add_char state.atom_buffer (Char.chr value);
  add_token_char state c stack
;;

let comment_add_last_dec_escape_char state c stack =
  let value = (state.escaped_value * 10) + dec_val c in
  state.escaped_value <- 0;
  if value > 255 then raise_error state ~at_eof:false Escape_sequence_out_of_range;
  add_token_char state c stack
;;

let add_hex_escape_char state c stack =
  state.escaped_value <- (state.escaped_value lsl 4) lor hex_val c;
  add_token_char state c stack
;;

let add_last_hex_escape_char state c stack =
  let value = (state.escaped_value lsl 4) lor hex_val c in
  state.escaped_value <- 0;
  Buffer.add_char state.atom_buffer (Char.chr value);
  add_token_char state c stack
;;

let opening : type u s. (u, s) Automaton_state.t -> char -> s -> s =
  fun state _char stack ->
  check_new_sexp_allowed state;
  state.depth <- state.depth + 1;
  match state.kind with
  | Positions ->
    if is_not_ignoring state then add_pos state ~delta:0;
    stack
  | Sexp -> if is_not_ignoring state then Open stack else stack
  | Sexp_with_positions ->
    if is_not_ignoring state
    then (
      add_pos state ~delta:0;
      Open stack)
    else stack
  | Cst -> Open (current_pos state, stack)
;;

let do_reset_positions state =
  Positions.Builder.reset
    state.user_state
    { line = state.line_number
    ; col = state.offset - state.bol_offset
    ; offset = state.offset
    }
;;

let reset_positions : type u s. (u, s) Automaton_state.t -> unit =
  fun state ->
  match state.kind with
  | Positions -> do_reset_positions state
  | Sexp_with_positions -> do_reset_positions state
  | Sexp -> ()
  | Cst -> ()
;;

let toplevel_sexp_or_comment_added state stack ~delta =
  match state.mode with
  | Single | Many -> stack
  | Eager { got_sexp = f; reraise_notrace; _ } ->
    (* Modify the offset so that [f] get a state pointing to the end of the current
       s-expression *)
    let saved_offset = state.offset in
    state.offset <- state.offset + delta;
    let saved_full_sexps = state.full_sexps in
    (match f state stack with
     | exception e ->
       set_error_state state;
       if reraise_notrace then raise_notrace e else raise e
     | stack ->
       (* This assert is not a full protection against the user mutating the state but
          it should catch most cases. *)
       assert (state.offset = saved_offset + delta && state.full_sexps = saved_full_sexps);
       state.offset <- saved_offset;
       reset_positions state;
       stack)
;;

let is_top_level state = is_not_ignoring state && state.depth = 0

let comment_added_assuming_cst state stack ~delta =
  if is_top_level state then toplevel_sexp_or_comment_added state stack ~delta else stack
;;

let maybe_pop_ignoring_stack state =
  match state.ignoring_stack with
  | inner_comment_depth :: _tl when inner_comment_depth > state.depth ->
    raise_error state ~at_eof:false Sexp_comment_without_sexp
  | inner_comment_depth :: tl when inner_comment_depth = state.depth ->
    state.ignoring_stack <- tl;
    true
  | _ -> false
;;

let sexp_added : type u s. (u, s) Automaton_state.t -> s -> delta:int -> s =
  fun state stack ~delta ->
  let is_comment = maybe_pop_ignoring_stack state in
  if is_top_level state
  then (
    if not is_comment then state.full_sexps <- state.full_sexps + 1;
    if (not is_comment)
       ||
       match state.kind with
       | Cst -> true
       | _ -> false
    then toplevel_sexp_or_comment_added state stack ~delta
    else stack)
  else stack
;;

let rec make_list acc : Automaton_stack.t -> Automaton_stack.t = function
  | Empty -> assert false
  | Open stack ->
    (* [opaque_identity] is needed to prevent the compiler from sharing multiple copies
       of [List []] after inlining. Such sharing is problematic because it prevents us
       from computing the correct sexp locations, since we base that on
       physical identity. *)
    Sexp (List (Sys.opaque_identity acc), stack)
  | Sexp (sexp, stack) -> make_list (sexp :: acc) stack
;;

let add_comment_to_stack_cst comment (stack : Automaton_stack.For_cst.t)
  : Automaton_stack.For_cst.t
  =
  match stack with
  | In_sexp_comment r ->
    In_sexp_comment { r with rev_comments = comment :: r.rev_comments }
  | _ -> T_or_comment (Comment comment, stack)
;;

let add_sexp_to_stack_cst sexp : Automaton_stack.For_cst.t -> Automaton_stack.For_cst.t
  = function
  | In_sexp_comment { hash_semi_pos; rev_comments; stack } ->
    let comment : Cst.comment =
      Sexp_comment { hash_semi_pos; comments = List.rev rev_comments; sexp }
    in
    add_comment_to_stack_cst comment stack
  | stack -> T_or_comment (Sexp sexp, stack)
;;

let rec make_list_cst end_pos acc : Automaton_stack.For_cst.t -> Automaton_stack.For_cst.t
  = function
  | T_or_comment (t, stack) -> make_list_cst end_pos (t :: acc) stack
  | Open (start_pos, stack) ->
    let sexp : Cst.t = List { loc = { start_pos; end_pos }; elements = acc } in
    add_sexp_to_stack_cst sexp stack
  | Empty | In_sexp_comment _ -> assert false
;;

let closing : type u s. (u, s) Automaton_state.t -> char -> s -> s =
  fun state _char stack ->
  if state.depth > 0
  then (
    let stack : s =
      match state.kind with
      | Positions ->
        (* Note we store end positions as inclusive in [Positions.t], so we use [delta:0],
           while in the [Cst] case we save directly the final ranges, so we use
           [delta:1]. *)
        if is_not_ignoring state then add_pos state ~delta:0;
        stack
      | Sexp -> if is_not_ignoring state then make_list [] stack else stack
      | Sexp_with_positions ->
        if is_not_ignoring state
        then (
          add_pos state ~delta:0;
          make_list [] stack)
        else stack
      | Cst -> make_list_cst (current_pos state ~delta:1) [] stack
    in
    state.depth <- state.depth - 1;
    sexp_added state stack ~delta:1)
  else raise_error state ~at_eof:false Closed_paren_without_opened
;;

let make_loc ?(delta = 0) (state : (Automaton_state.For_cst.t, _) Automaton_state.t)
  : Positions.range
  =
  { start_pos = state.user_state.token_start_pos; end_pos = current_pos state ~delta }
;;

(* This is always called on the position exactly following the last character of a
   non-quoted atom *)
let add_non_quoted_atom_pos state ~atom =
  let len = String.length atom in
  if len = 1
  then Positions.Builder.add_twice state.user_state ~offset:(state.offset - 1)
  else (
    add_pos state ~delta:(-len);
    add_pos state ~delta:(-1))
;;

let eps_push_atom : type u s. (u, s) Epsilon.t =
  fun state stack ->
  let str = Buffer.contents state.atom_buffer in
  Buffer.clear state.atom_buffer;
  let stack : s =
    match state.kind with
    | Positions ->
      if is_not_ignoring state then add_non_quoted_atom_pos state ~atom:str;
      stack
    | Sexp -> if is_not_ignoring state then Sexp (Atom str, stack) else stack
    | Sexp_with_positions ->
      if is_not_ignoring state
      then (
        add_non_quoted_atom_pos state ~atom:str;
        Sexp (Atom str, stack))
      else stack
    | Cst ->
      let loc : Positions.range =
        { start_pos = current_pos state ~delta:(-String.length str)
        ; end_pos = current_pos state ~delta:0
        }
      in
      let sexp : Cst.t = Atom { loc; atom = str; unescaped = Some str } in
      add_sexp_to_stack_cst sexp stack
  in
  sexp_added state stack ~delta:0
;;

let push_quoted_atom : type u s. (u, s) t =
  fun state _char stack ->
  let str = Buffer.contents state.atom_buffer in
  Buffer.clear state.atom_buffer;
  let stack : s =
    match state.kind with
    | Positions ->
      if is_not_ignoring state then add_pos state ~delta:0;
      stack
    | Sexp -> if is_not_ignoring state then Sexp (Atom str, stack) else stack
    | Sexp_with_positions ->
      if is_not_ignoring state
      then (
        add_pos state ~delta:0;
        Sexp (Atom str, stack))
      else stack
    | Cst ->
      let buf = state.user_state.token_buffer in
      Buffer.add_char buf '"';
      let s = Buffer.contents buf in
      Buffer.clear buf;
      let sexp : Cst.t =
        Atom { loc = make_loc state ~delta:1; atom = str; unescaped = Some s }
      in
      add_sexp_to_stack_cst sexp stack
  in
  sexp_added state stack ~delta:1
;;

let start_sexp_comment : type u s. (u, s) t =
  fun state _char stack ->
  state.ignoring_stack <- state.depth :: state.ignoring_stack;
  match state.kind with
  | Cst ->
    In_sexp_comment
      { hash_semi_pos = current_pos state ~delta:(-1); rev_comments = []; stack }
  | _ -> stack
;;

let start_block_comment : type u s. (u, s) Automaton_state.t -> char -> s -> s =
  fun state char stack ->
  state.block_comment_depth <- state.block_comment_depth + 1;
  match state.kind with
  | Positions -> stack
  | Sexp -> stack
  | Sexp_with_positions -> stack
  | Cst ->
    if state.block_comment_depth = 1
    then (
      state.user_state.token_start_pos <- current_pos state ~delta:(-1);
      Buffer.add_char state.user_state.token_buffer '#');
    Buffer.add_char state.user_state.token_buffer char;
    stack
;;

let end_block_comment : type u s. (u, s) Automaton_state.t -> char -> s -> s =
  fun state char stack ->
  state.block_comment_depth <- state.block_comment_depth - 1;
  match state.kind with
  | Positions -> stack
  | Sexp -> stack
  | Sexp_with_positions -> stack
  | Cst ->
    let buf = state.user_state.token_buffer in
    Buffer.add_char buf char;
    if state.block_comment_depth = 0
    then (
      let s = Buffer.contents buf in
      Buffer.clear buf;
      let comment : Cst.comment =
        Plain_comment { loc = make_loc state ~delta:1; comment = s }
      in
      let stack = add_comment_to_stack_cst comment stack in
      comment_added_assuming_cst state stack ~delta:1)
    else stack
;;

let start_line_comment : type u s. (u, s) t =
  fun state char stack ->
  match state.kind with
  | Cst ->
    state.user_state.token_start_pos <- current_pos state;
    Buffer.add_char state.user_state.token_buffer char;
    stack
  | _ -> stack
;;

let end_line_comment : type u s. (u, s) Epsilon.t =
  fun state stack ->
  match state.kind with
  | Positions -> stack
  | Sexp -> stack
  | Sexp_with_positions -> stack
  | Cst ->
    let buf = state.user_state.token_buffer in
    let s = Buffer.contents buf in
    Buffer.clear buf;
    let comment : Cst.comment = Plain_comment { loc = make_loc state; comment = s } in
    let stack = add_comment_to_stack_cst comment stack in
    comment_added_assuming_cst state stack ~delta:0
;;

let eps_eoi_check : type u s. (u, s) Epsilon.t =
  fun state stack ->
  if state.depth > 0 then raise_error state ~at_eof:true Unclosed_paren;
  if is_ignoring state then raise_error state ~at_eof:true Sexp_comment_without_sexp;
  if state.full_sexps = 0
  then (
    match state.mode with
    | Many | Eager { no_sexp_is_error = false; _ } -> ()
    | Single | Eager { no_sexp_is_error = true; _ } ->
      raise_error state ~at_eof:true No_sexp_found_in_input);
  stack
;;
end
module Parser_intf = struct
open! Import

module type State = sig
  (** State of the parser *)
  type t

  (** Create a new parser state. [pos] is the initial position, it defaults to
      [{line=1;col=0;offset=0}]. *)
  val create : ?pos:Positions.pos -> unit -> t

  (** Reset the given parsing state. The following always succeed:

      {[
        reset t ?pos;
        assert (t = create ?pos ())
      ]}
  *)
  val reset : ?pos:Positions.pos -> t -> unit

  (** Number of characters fed to the parser *)
  val offset : t -> int

  (** Position in the text *)

  val line : t -> int
  val column : t -> int
  val position : t -> Positions.pos

  (** Prevent the state from receiving any more characters. Trying to feed more characters
      will result in an exception, unless the state is reset. *)
  val stop : t -> unit
end

module type Stack = sig
  (** Parser stack. The stack is not in [state] for optimization purposes. *)
  type t

  val empty : t
end

module type S = sig
  (** Values produced by the parser *)
  type parsed_value

  module State : State
  module Stack : Stack

  (** Feed one character to the parser. In case of error, it raises [Parse_error] *)
  val feed : State.t -> char -> Stack.t -> Stack.t

  (** Instruct the parser that the end of input was reached. In case of error, it raises
      [Parse_error] *)
  val feed_eoi : State.t -> Stack.t -> parsed_value

  (** {3 Convenience functions} *)

  val feed_string : State.t -> string -> Stack.t -> Stack.t
  val feed_substring : State.t -> string -> pos:int -> len:int -> Stack.t -> Stack.t
  val feed_bytes : State.t -> bytes -> Stack.t -> Stack.t
  val feed_subbytes : State.t -> bytes -> pos:int -> len:int -> Stack.t -> Stack.t

  (** {3 High-level functions} *)

  val parse_string : string -> (parsed_value, Parse_error.t) result
  val parse_string_exn : string -> parsed_value
end

module type S_eager = sig
  (** Same as [Parser] but gives back a s-expression as soon as they are found in the
      input.

      For instance you can use this function to parse a stream and stop at the first
      s-expression:

      {[
        exception Got_sexp of Sexp.t

        let fetch_sexp stream =
          let module P = Parsexp.Sexp_parsing.Eager in
          let rec hot_loop state stream stack =
            match Stream.peek stream with
            | None -> P.feed_eoi state stack
            | Some char ->
              let stack = P.feed state char stack in
              Stream.junk stream;
              hot_loop state stream stack
          in
          let got_sexp state sexp =
            raise_notrace (Got_sexp sexp)
          in
          let count = Stream.count stream in
          let state = P.State.create ~f:got_sexp ~no_sexp_is_error:true in
          match hot_loop state stream P.Stack.empty with
          | () -> assert false
          | exception (Got_sexp sexp) ->
            (* This test is true if the s-expression includes the last character passed to
               the parser *)
            if P.State.offset state > Stream.count stream - count then Stream.junk stream;
            sexp
      ]}
  *)

  (** Values produces by the parser *)
  type parsed_value

  module State : sig
    include State

    module Read_only : sig
      (** Read-only handle to a parser state *)
      type t

      val offset : t -> int
      val line : t -> int
      val column : t -> int
      val position : t -> Positions.pos
    end

    (** [create ~f] create a new eager parser state. [f] will be called on each
        s-expression found. If [f] raises, then the parser is made unusable ([stop t] is
        invoked).

        [no_sexp_is_error] controls the behavior of the parse when the end of input is
        reached and no s-expression has been found. When [no_sexp_is_error] is [false]
        (the default) [feed_eoi] just returns [()], when it is [false] [feed_eoi]
        raises. In any case, if the end of input is reached while parsing an incomplete
        s-expression such as [(abc], error is raised.

        [reraise_notrace] controls whether or not the exceptions raised by [f] are
        reraised without a backtrace. ([false]: with, [true]: without)
        Generally you should pass [true] if you're using [raise_nontrace] in [f],
        especially if using exceptions for control flow.

        [f] must not save the read-only parser state it receives to access it after
        returning. It is unspecified what values it will read if it does so. *)
    val create
      :  ?pos:Positions.pos
      -> ?reraise_notrace:bool (** default: false *)
      -> ?no_sexp_is_error:bool (** default: false *)
      -> (Read_only.t -> parsed_value -> unit)
      -> t

    (**/**)

    val old_parser_cont_state : t -> Old_parser_cont_state.t

    (**/**)
  end

  module Stack : Stack

  val feed : State.t -> char -> Stack.t -> Stack.t
  val feed_eoi : State.t -> Stack.t -> unit
  val feed_string : State.t -> string -> Stack.t -> Stack.t
  val feed_substring : State.t -> string -> pos:int -> len:int -> Stack.t -> Stack.t
  val feed_bytes : State.t -> bytes -> Stack.t -> Stack.t
  val feed_subbytes : State.t -> bytes -> pos:int -> len:int -> Stack.t -> Stack.t

  module Lexbuf_consumer : sig
    type t

    val create : unit -> t

    (** Consume exactly one s-expression from the given lexing buffer *)
    val parse : t -> Lexing.lexbuf -> parsed_value

    (** Consume exactly one s-expression from the given lexing buffer. Returns [None] if
        the end of input is reached before seeing any s-expression. *)
    val parse_opt : t -> Lexing.lexbuf -> parsed_value option
  end
end

module type Parser = sig
  module type S = S
  module type S_eager = S_eager
  module type Stack = Stack

  val make
    :  ('state, 'stack) Automaton_state.Kind.t
    -> ('state, 'stack) Automaton_state.Mode.t
    -> (('state, 'stack) Automaton_state.t -> 'stack -> 'a)
    -> (module S
          with type parsed_value = 'a
           and type State.t = ('state, 'stack) Automaton_state.t
           and type Stack.t = 'stack)

  val make_eager
    :  ('state, 'stack) Automaton_state.Kind.t
    -> (('state, 'stack) Automaton_state.t -> 'stack -> 'a)
    -> (module S_eager
          with type parsed_value = 'a
           and type State.t = ('state, 'stack) Automaton_state.t
           and type Stack.t = 'stack)
end
end
module Automaton_tables : sig
(** Parser automaton *)

type u'
type s'

val transitions : Automaton_action.Poly.t array
val transitions_eoi : Automaton_action.Epsilon.Poly.t array
val old_parser_approx_cont_states : Old_parser_cont_state.t array
end = struct
open Automaton_action

let raise = Automaton_action.raise_error

type u'
type s'

(*$ Parsexp_cinaps_helpers.Gen_automaton_tables.print_code () *)
let tr_00_f state char stack =
  let stack = add_first_char state char stack in
  set_automaton_state state 3;
  advance state;
  stack
;;

let tr_00 : Automaton_action.Poly.t = { f = tr_00_f }

let tr_01_f state _char stack =
  set_automaton_state state 0;
  advance state;
  stack
;;

let tr_01 : Automaton_action.Poly.t = { f = tr_01_f }

let tr_02_f state _char stack =
  set_automaton_state state 0;
  advance_eol state;
  stack
;;

let tr_02 : Automaton_action.Poly.t = { f = tr_02_f }

let tr_03_f state _char stack =
  set_automaton_state state 2;
  advance state;
  stack
;;

let tr_03 : Automaton_action.Poly.t = { f = tr_03_f }

let tr_04_f state char stack =
  let stack = start_quoted_string state char stack in
  set_automaton_state state 8;
  advance state;
  stack
;;

let tr_04 : Automaton_action.Poly.t = { f = tr_04_f }

let tr_05_f state _char stack =
  set_automaton_state state 7;
  advance state;
  stack
;;

let tr_05 : Automaton_action.Poly.t = { f = tr_05_f }

let tr_06_f state char stack =
  let stack = opening state char stack in
  set_automaton_state state 0;
  advance state;
  stack
;;

let tr_06 : Automaton_action.Poly.t = { f = tr_06_f }

let tr_07_f state char stack =
  let stack = closing state char stack in
  set_automaton_state state 0;
  advance state;
  stack
;;

let tr_07 : Automaton_action.Poly.t = { f = tr_07_f }

let tr_08_f state char stack =
  let stack = start_line_comment state char stack in
  set_automaton_state state 6;
  advance state;
  stack
;;

let tr_08 : Automaton_action.Poly.t = { f = tr_08_f }

let tr_09_f state char stack =
  let stack = add_first_char state char stack in
  set_automaton_state state 5;
  advance state;
  stack
;;

let tr_09 : Automaton_action.Poly.t = { f = tr_09_f }
let tr_10_f _state _char _stack = raise _state ~at_eof:false Automaton_in_error_state
let tr_10 : Automaton_action.Poly.t = { f = tr_10_f }
let tr_11_f _state _char _stack = raise _state ~at_eof:false Unexpected_character_after_cr
let tr_11 : Automaton_action.Poly.t = { f = tr_11_f }

let tr_12_f state char stack =
  let stack = add_atom_char state char stack in
  set_automaton_state state 3;
  advance state;
  stack
;;

let tr_12 : Automaton_action.Poly.t = { f = tr_12_f }

let tr_13_f state _char stack =
  let stack = eps_push_atom state stack in
  set_automaton_state state 0;
  advance state;
  stack
;;

let tr_13 : Automaton_action.Poly.t = { f = tr_13_f }

let tr_14_f state _char stack =
  let stack = eps_push_atom state stack in
  set_automaton_state state 0;
  advance_eol state;
  stack
;;

let tr_14 : Automaton_action.Poly.t = { f = tr_14_f }

let tr_15_f state _char stack =
  let stack = eps_push_atom state stack in
  set_automaton_state state 2;
  advance state;
  stack
;;

let tr_15 : Automaton_action.Poly.t = { f = tr_15_f }

let tr_16_f state char stack =
  let stack = eps_push_atom state stack in
  let stack = start_quoted_string state char stack in
  set_automaton_state state 8;
  advance state;
  stack
;;

let tr_16 : Automaton_action.Poly.t = { f = tr_16_f }

let tr_17_f state char stack =
  let stack = add_atom_char state char stack in
  set_automaton_state state 4;
  advance state;
  stack
;;

let tr_17 : Automaton_action.Poly.t = { f = tr_17_f }

let tr_18_f state char stack =
  let stack = eps_push_atom state stack in
  let stack = opening state char stack in
  set_automaton_state state 0;
  advance state;
  stack
;;

let tr_18 : Automaton_action.Poly.t = { f = tr_18_f }

let tr_19_f state char stack =
  let stack = eps_push_atom state stack in
  let stack = closing state char stack in
  set_automaton_state state 0;
  advance state;
  stack
;;

let tr_19 : Automaton_action.Poly.t = { f = tr_19_f }

let tr_20_f state char stack =
  let stack = eps_push_atom state stack in
  let stack = start_line_comment state char stack in
  set_automaton_state state 6;
  advance state;
  stack
;;

let tr_20 : Automaton_action.Poly.t = { f = tr_20_f }

let tr_21_f state char stack =
  let stack = add_atom_char state char stack in
  set_automaton_state state 5;
  advance state;
  stack
;;

let tr_21 : Automaton_action.Poly.t = { f = tr_21_f }

let tr_22_f _state _char _stack =
  raise _state ~at_eof:false Comment_token_in_unquoted_atom
;;

let tr_22 : Automaton_action.Poly.t = { f = tr_22_f }

let tr_23_f state char stack =
  let stack = add_token_char state char stack in
  set_automaton_state state 6;
  advance state;
  stack
;;

let tr_23 : Automaton_action.Poly.t = { f = tr_23_f }

let tr_24_f state _char stack =
  let stack = end_line_comment state stack in
  set_automaton_state state 0;
  advance_eol state;
  stack
;;

let tr_24 : Automaton_action.Poly.t = { f = tr_24_f }

let tr_25_f state _char stack =
  let stack = end_line_comment state stack in
  set_automaton_state state 2;
  advance state;
  stack
;;

let tr_25 : Automaton_action.Poly.t = { f = tr_25_f }

let tr_26_f state char stack =
  let stack = eps_add_first_char_hash state stack in
  let stack = add_atom_char state char stack in
  set_automaton_state state 3;
  advance state;
  stack
;;

let tr_26 : Automaton_action.Poly.t = { f = tr_26_f }

let tr_27_f state _char stack =
  let stack = eps_add_first_char_hash state stack in
  let stack = eps_push_atom state stack in
  set_automaton_state state 0;
  advance state;
  stack
;;

let tr_27 : Automaton_action.Poly.t = { f = tr_27_f }

let tr_28_f state _char stack =
  let stack = eps_add_first_char_hash state stack in
  let stack = eps_push_atom state stack in
  set_automaton_state state 0;
  advance_eol state;
  stack
;;

let tr_28 : Automaton_action.Poly.t = { f = tr_28_f }

let tr_29_f state _char stack =
  let stack = eps_add_first_char_hash state stack in
  let stack = eps_push_atom state stack in
  set_automaton_state state 2;
  advance state;
  stack
;;

let tr_29 : Automaton_action.Poly.t = { f = tr_29_f }

let tr_30_f state char stack =
  let stack = eps_add_first_char_hash state stack in
  let stack = eps_push_atom state stack in
  let stack = start_quoted_string state char stack in
  set_automaton_state state 8;
  advance state;
  stack
;;

let tr_30 : Automaton_action.Poly.t = { f = tr_30_f }

let tr_31_f state char stack =
  let stack = eps_add_first_char_hash state stack in
  let stack = add_atom_char state char stack in
  set_automaton_state state 4;
  advance state;
  stack
;;

let tr_31 : Automaton_action.Poly.t = { f = tr_31_f }

let tr_32_f state char stack =
  let stack = eps_add_first_char_hash state stack in
  let stack = eps_push_atom state stack in
  let stack = opening state char stack in
  set_automaton_state state 0;
  advance state;
  stack
;;

let tr_32 : Automaton_action.Poly.t = { f = tr_32_f }

let tr_33_f state char stack =
  let stack = eps_add_first_char_hash state stack in
  let stack = eps_push_atom state stack in
  let stack = closing state char stack in
  set_automaton_state state 0;
  advance state;
  stack
;;

let tr_33 : Automaton_action.Poly.t = { f = tr_33_f }

let tr_34_f state char stack =
  let stack = start_sexp_comment state char stack in
  set_automaton_state state 0;
  advance state;
  stack
;;

let tr_34 : Automaton_action.Poly.t = { f = tr_34_f }

let tr_35_f state char stack =
  let stack = start_block_comment state char stack in
  set_automaton_state state 16;
  advance state;
  stack
;;

let tr_35 : Automaton_action.Poly.t = { f = tr_35_f }

let tr_36_f state char stack =
  let stack = add_quoted_atom_char state char stack in
  set_automaton_state state 8;
  advance state;
  stack
;;

let tr_36 : Automaton_action.Poly.t = { f = tr_36_f }

let tr_37_f state char stack =
  let stack = add_quoted_atom_char state char stack in
  set_automaton_state state 8;
  advance_eol state;
  stack
;;

let tr_37 : Automaton_action.Poly.t = { f = tr_37_f }

let tr_38_f state char stack =
  let stack = push_quoted_atom state char stack in
  set_automaton_state state 0;
  advance state;
  stack
;;

let tr_38 : Automaton_action.Poly.t = { f = tr_38_f }

let tr_39_f state char stack =
  let stack = add_token_char state char stack in
  set_automaton_state state 9;
  advance state;
  stack
;;

let tr_39 : Automaton_action.Poly.t = { f = tr_39_f }

let tr_40_f state char stack =
  let stack = add_escaped state char stack in
  set_automaton_state state 8;
  advance state;
  stack
;;

let tr_40 : Automaton_action.Poly.t = { f = tr_40_f }

let tr_41_f state char stack =
  let stack = add_token_char state char stack in
  set_automaton_state state 15;
  advance_eol state;
  stack
;;

let tr_41 : Automaton_action.Poly.t = { f = tr_41_f }

let tr_42_f state char stack =
  let stack = add_token_char state char stack in
  set_automaton_state state 10;
  advance state;
  stack
;;

let tr_42 : Automaton_action.Poly.t = { f = tr_42_f }

let tr_43_f state char stack =
  let stack = add_dec_escape_char state char stack in
  set_automaton_state state 11;
  advance state;
  stack
;;

let tr_43 : Automaton_action.Poly.t = { f = tr_43_f }

let tr_44_f state char stack =
  let stack = add_token_char state char stack in
  set_automaton_state state 13;
  advance state;
  stack
;;

let tr_44 : Automaton_action.Poly.t = { f = tr_44_f }

let tr_45_f state char stack =
  let stack = eps_add_escaped_cr state stack in
  let stack = add_quoted_atom_char state char stack in
  set_automaton_state state 8;
  advance state;
  stack
;;

let tr_45 : Automaton_action.Poly.t = { f = tr_45_f }

let tr_46_f state char stack =
  let stack = eps_add_escaped_cr state stack in
  let stack = push_quoted_atom state char stack in
  set_automaton_state state 0;
  advance state;
  stack
;;

let tr_46 : Automaton_action.Poly.t = { f = tr_46_f }

let tr_47_f state char stack =
  let stack = eps_add_escaped_cr state stack in
  let stack = add_token_char state char stack in
  set_automaton_state state 9;
  advance state;
  stack
;;

let tr_47 : Automaton_action.Poly.t = { f = tr_47_f }

let tr_48_f _state _char _stack =
  raise _state ~at_eof:false Unexpected_char_parsing_dec_escape
;;

let tr_48 : Automaton_action.Poly.t = { f = tr_48_f }

let tr_49_f state char stack =
  let stack = add_dec_escape_char state char stack in
  set_automaton_state state 12;
  advance state;
  stack
;;

let tr_49 : Automaton_action.Poly.t = { f = tr_49_f }

let tr_50_f state char stack =
  let stack = add_last_dec_escape_char state char stack in
  set_automaton_state state 8;
  advance state;
  stack
;;

let tr_50 : Automaton_action.Poly.t = { f = tr_50_f }

let tr_51_f _state _char _stack =
  raise _state ~at_eof:false Unexpected_char_parsing_hex_escape
;;

let tr_51 : Automaton_action.Poly.t = { f = tr_51_f }

let tr_52_f state char stack =
  let stack = add_hex_escape_char state char stack in
  set_automaton_state state 14;
  advance state;
  stack
;;

let tr_52 : Automaton_action.Poly.t = { f = tr_52_f }

let tr_53_f state char stack =
  let stack = add_last_hex_escape_char state char stack in
  set_automaton_state state 8;
  advance state;
  stack
;;

let tr_53 : Automaton_action.Poly.t = { f = tr_53_f }

let tr_54_f state char stack =
  let stack = add_quoted_atom_char state char stack in
  set_automaton_state state 8;
  advance state;
  stack
;;

let tr_54 : Automaton_action.Poly.t = { f = tr_54_f }

let tr_55_f state char stack =
  let stack = add_token_char state char stack in
  set_automaton_state state 15;
  advance state;
  stack
;;

let tr_55 : Automaton_action.Poly.t = { f = tr_55_f }

let tr_56_f state char stack =
  let stack = add_quoted_atom_char state char stack in
  set_automaton_state state 8;
  advance_eol state;
  stack
;;

let tr_56 : Automaton_action.Poly.t = { f = tr_56_f }

let tr_57_f state char stack =
  let stack = push_quoted_atom state char stack in
  set_automaton_state state 0;
  advance state;
  stack
;;

let tr_57 : Automaton_action.Poly.t = { f = tr_57_f }

let tr_58_f state char stack =
  let stack = add_token_char state char stack in
  set_automaton_state state 9;
  advance state;
  stack
;;

let tr_58 : Automaton_action.Poly.t = { f = tr_58_f }

let tr_59_f state char stack =
  let stack = add_token_char state char stack in
  set_automaton_state state 16;
  advance state;
  stack
;;

let tr_59 : Automaton_action.Poly.t = { f = tr_59_f }

let tr_60_f state char stack =
  let stack = add_token_char state char stack in
  set_automaton_state state 16;
  advance_eol state;
  stack
;;

let tr_60 : Automaton_action.Poly.t = { f = tr_60_f }

let tr_61_f state char stack =
  let stack = add_token_char state char stack in
  set_automaton_state state 19;
  advance state;
  stack
;;

let tr_61 : Automaton_action.Poly.t = { f = tr_61_f }

let tr_62_f state char stack =
  let stack = add_token_char state char stack in
  set_automaton_state state 18;
  advance state;
  stack
;;

let tr_62 : Automaton_action.Poly.t = { f = tr_62_f }

let tr_63_f state char stack =
  let stack = add_token_char state char stack in
  set_automaton_state state 17;
  advance state;
  stack
;;

let tr_63 : Automaton_action.Poly.t = { f = tr_63_f }

let tr_64_f state char stack =
  let stack = end_block_comment state char stack in
  set_automaton_state state (if block_comment_depth state <> 0 then 16 else 0);
  advance state;
  stack
;;

let tr_64 : Automaton_action.Poly.t = { f = tr_64_f }

let tr_65_f state char stack =
  let stack = add_token_char state char stack in
  set_automaton_state state 19;
  advance_eol state;
  stack
;;

let tr_65 : Automaton_action.Poly.t = { f = tr_65_f }

let tr_66_f state char stack =
  let stack = add_token_char state char stack in
  set_automaton_state state 20;
  advance state;
  stack
;;

let tr_66 : Automaton_action.Poly.t = { f = tr_66_f }

let tr_67_f state char stack =
  let stack = add_token_char state char stack in
  set_automaton_state state 26;
  advance_eol state;
  stack
;;

let tr_67 : Automaton_action.Poly.t = { f = tr_67_f }

let tr_68_f state char stack =
  let stack = add_token_char state char stack in
  set_automaton_state state 21;
  advance state;
  stack
;;

let tr_68 : Automaton_action.Poly.t = { f = tr_68_f }

let tr_69_f state char stack =
  let stack = add_dec_escape_char state char stack in
  set_automaton_state state 22;
  advance state;
  stack
;;

let tr_69 : Automaton_action.Poly.t = { f = tr_69_f }

let tr_70_f state char stack =
  let stack = add_token_char state char stack in
  set_automaton_state state 24;
  advance state;
  stack
;;

let tr_70 : Automaton_action.Poly.t = { f = tr_70_f }

let tr_71_f state char stack =
  let stack = add_token_char state char stack in
  set_automaton_state state 19;
  advance state;
  stack
;;

let tr_71 : Automaton_action.Poly.t = { f = tr_71_f }

let tr_72_f state char stack =
  let stack = add_token_char state char stack in
  set_automaton_state state 16;
  advance state;
  stack
;;

let tr_72 : Automaton_action.Poly.t = { f = tr_72_f }

let tr_73_f state char stack =
  let stack = add_token_char state char stack in
  set_automaton_state state 20;
  advance state;
  stack
;;

let tr_73 : Automaton_action.Poly.t = { f = tr_73_f }

let tr_74_f state char stack =
  let stack = add_dec_escape_char state char stack in
  set_automaton_state state 23;
  advance state;
  stack
;;

let tr_74 : Automaton_action.Poly.t = { f = tr_74_f }

let tr_75_f state char stack =
  let stack = comment_add_last_dec_escape_char state char stack in
  set_automaton_state state 19;
  advance state;
  stack
;;

let tr_75 : Automaton_action.Poly.t = { f = tr_75_f }

let tr_76_f state char stack =
  let stack = add_token_char state char stack in
  set_automaton_state state 25;
  advance state;
  stack
;;

let tr_76 : Automaton_action.Poly.t = { f = tr_76_f }

let tr_77_f state char stack =
  let stack = add_token_char state char stack in
  set_automaton_state state 26;
  advance state;
  stack
;;

let tr_77 : Automaton_action.Poly.t = { f = tr_77_f }

let tr_78_f state char stack =
  let stack = add_token_char state char stack in
  set_automaton_state state 19;
  advance_eol state;
  stack
;;

let tr_78 : Automaton_action.Poly.t = { f = tr_78_f }
let tr_eoi_00_f state stack = eps_eoi_check state stack
let tr_eoi_00 : Automaton_action.Epsilon.Poly.t = { f = tr_eoi_00_f }
let tr_eoi_01_f state _stack = raise state ~at_eof:true Automaton_in_error_state
let tr_eoi_01 : Automaton_action.Epsilon.Poly.t = { f = tr_eoi_01_f }
let tr_eoi_02_f state _stack = raise state ~at_eof:true Unexpected_character_after_cr
let tr_eoi_02 : Automaton_action.Epsilon.Poly.t = { f = tr_eoi_02_f }

let tr_eoi_03_f state stack =
  let stack = eps_push_atom state stack in
  eps_eoi_check state stack
;;

let tr_eoi_03 : Automaton_action.Epsilon.Poly.t = { f = tr_eoi_03_f }

let tr_eoi_04_f state stack =
  let stack = end_line_comment state stack in
  eps_eoi_check state stack
;;

let tr_eoi_04 : Automaton_action.Epsilon.Poly.t = { f = tr_eoi_04_f }

let tr_eoi_05_f state stack =
  let stack = eps_add_first_char_hash state stack in
  let stack = eps_push_atom state stack in
  eps_eoi_check state stack
;;

let tr_eoi_05 : Automaton_action.Epsilon.Poly.t = { f = tr_eoi_05_f }
let tr_eoi_06_f state _stack = raise state ~at_eof:true Unterminated_quoted_string
let tr_eoi_06 : Automaton_action.Epsilon.Poly.t = { f = tr_eoi_06_f }
let tr_eoi_07_f state _stack = raise state ~at_eof:true Unterminated_block_comment
let tr_eoi_07 : Automaton_action.Epsilon.Poly.t = { f = tr_eoi_07_f }

let transitions =
  [| tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_01
   ; tr_02
   ; tr_00
   ; tr_01
   ; tr_03
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_01
   ; tr_00
   ; tr_04
   ; tr_05
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_06
   ; tr_07
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_08
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_09
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_00
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_10
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_02
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_11
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_13
   ; tr_14
   ; tr_12
   ; tr_13
   ; tr_15
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_13
   ; tr_12
   ; tr_16
   ; tr_17
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_18
   ; tr_19
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_20
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_21
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_13
   ; tr_14
   ; tr_12
   ; tr_13
   ; tr_15
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_13
   ; tr_12
   ; tr_16
   ; tr_17
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_18
   ; tr_19
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_20
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_22
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_13
   ; tr_14
   ; tr_12
   ; tr_13
   ; tr_15
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_13
   ; tr_12
   ; tr_16
   ; tr_22
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_18
   ; tr_19
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_20
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_21
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_12
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_24
   ; tr_23
   ; tr_23
   ; tr_25
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_23
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_27
   ; tr_28
   ; tr_26
   ; tr_27
   ; tr_29
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_27
   ; tr_26
   ; tr_30
   ; tr_31
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_32
   ; tr_33
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_34
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_35
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_26
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_37
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_38
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_39
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_36
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_41
   ; tr_40
   ; tr_40
   ; tr_42
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_43
   ; tr_43
   ; tr_43
   ; tr_43
   ; tr_43
   ; tr_43
   ; tr_43
   ; tr_43
   ; tr_43
   ; tr_43
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_44
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_40
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_41
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_46
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_47
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_45
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_49
   ; tr_49
   ; tr_49
   ; tr_49
   ; tr_49
   ; tr_49
   ; tr_49
   ; tr_49
   ; tr_49
   ; tr_49
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_50
   ; tr_50
   ; tr_50
   ; tr_50
   ; tr_50
   ; tr_50
   ; tr_50
   ; tr_50
   ; tr_50
   ; tr_50
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_52
   ; tr_52
   ; tr_52
   ; tr_52
   ; tr_52
   ; tr_52
   ; tr_52
   ; tr_52
   ; tr_52
   ; tr_52
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_52
   ; tr_52
   ; tr_52
   ; tr_52
   ; tr_52
   ; tr_52
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_52
   ; tr_52
   ; tr_52
   ; tr_52
   ; tr_52
   ; tr_52
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_53
   ; tr_53
   ; tr_53
   ; tr_53
   ; tr_53
   ; tr_53
   ; tr_53
   ; tr_53
   ; tr_53
   ; tr_53
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_53
   ; tr_53
   ; tr_53
   ; tr_53
   ; tr_53
   ; tr_53
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_53
   ; tr_53
   ; tr_53
   ; tr_53
   ; tr_53
   ; tr_53
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_55
   ; tr_56
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_55
   ; tr_54
   ; tr_57
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_58
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_54
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_60
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_61
   ; tr_62
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_63
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_60
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_61
   ; tr_64
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_63
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_60
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_61
   ; tr_62
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_35
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_59
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_65
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_59
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_66
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_67
   ; tr_61
   ; tr_61
   ; tr_68
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_69
   ; tr_69
   ; tr_69
   ; tr_69
   ; tr_69
   ; tr_69
   ; tr_69
   ; tr_69
   ; tr_69
   ; tr_69
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_70
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_67
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_72
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_73
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_74
   ; tr_74
   ; tr_74
   ; tr_74
   ; tr_74
   ; tr_74
   ; tr_74
   ; tr_74
   ; tr_74
   ; tr_74
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_75
   ; tr_75
   ; tr_75
   ; tr_75
   ; tr_75
   ; tr_75
   ; tr_75
   ; tr_75
   ; tr_75
   ; tr_75
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_48
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_76
   ; tr_76
   ; tr_76
   ; tr_76
   ; tr_76
   ; tr_76
   ; tr_76
   ; tr_76
   ; tr_76
   ; tr_76
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_76
   ; tr_76
   ; tr_76
   ; tr_76
   ; tr_76
   ; tr_76
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_76
   ; tr_76
   ; tr_76
   ; tr_76
   ; tr_76
   ; tr_76
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_61
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_51
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_77
   ; tr_78
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_77
   ; tr_71
   ; tr_72
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_73
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
   ; tr_71
  |]
;;

let transitions_eoi =
  [| tr_eoi_00
   ; tr_eoi_01
   ; tr_eoi_02
   ; tr_eoi_03
   ; tr_eoi_03
   ; tr_eoi_03
   ; tr_eoi_04
   ; tr_eoi_05
   ; tr_eoi_06
   ; tr_eoi_06
   ; tr_eoi_06
   ; tr_eoi_06
   ; tr_eoi_06
   ; tr_eoi_06
   ; tr_eoi_06
   ; tr_eoi_06
   ; tr_eoi_07
   ; tr_eoi_07
   ; tr_eoi_07
   ; tr_eoi_07
   ; tr_eoi_07
   ; tr_eoi_07
   ; tr_eoi_07
   ; tr_eoi_07
   ; tr_eoi_07
   ; tr_eoi_07
   ; tr_eoi_07
  |]
;;

let old_parser_approx_cont_states : Old_parser_cont_state.t array =
  [| Parsing_toplevel_whitespace
   ; Parsing_toplevel_whitespace
   ; Parsing_nested_whitespace
   ; Parsing_atom
   ; Parsing_atom
   ; Parsing_atom
   ; Parsing_toplevel_whitespace
   ; Parsing_atom
   ; Parsing_atom
   ; Parsing_atom
   ; Parsing_atom
   ; Parsing_atom
   ; Parsing_atom
   ; Parsing_atom
   ; Parsing_atom
   ; Parsing_atom
   ; Parsing_block_comment
   ; Parsing_block_comment
   ; Parsing_block_comment
   ; Parsing_block_comment
   ; Parsing_block_comment
   ; Parsing_block_comment
   ; Parsing_block_comment
   ; Parsing_block_comment
   ; Parsing_block_comment
   ; Parsing_block_comment
   ; Parsing_block_comment
  |]
;;
(*$*)
end
module Automaton : sig
include Automaton_intf.Automaton
end = struct
open! Import
module Stack = Automaton_stack
include Automaton_state

let feed (type u s) (state : (u, s) Automaton_state.t) char (stack : s) : s =
  let idx = (automaton_state state lsl 8) lor Char.code char in
  Automaton_tables.transitions.(idx).f state char stack
  [@@inline always]
;;

let feed_eoi (type u s) (state : (u, s) Automaton_state.t) (stack : s) : s =
  let stack = Automaton_tables.transitions_eoi.(automaton_state state).f state stack in
  set_error_state state;
  stack
;;

let old_parser_cont_state state : Old_parser_cont_state.t =
  match context state with
  | Sexp_comment -> Parsing_sexp_comment
  | Sexp ->
    (match
       ( Automaton_tables.old_parser_approx_cont_states.(automaton_state state)
       , has_unclosed_paren state )
     with
     | Parsing_toplevel_whitespace, true -> Parsing_list
     | s, _ -> s)
;;

let rec feed_substring_unsafe str state stack i stop =
  if i < stop
  then (
    let c = String.unsafe_get str i in
    let stack = feed state c stack in
    feed_substring_unsafe str state stack (i + 1) stop)
  else stack
;;

let rec feed_subbytes_unsafe str state stack i stop =
  if i < stop
  then (
    let c = Bytes.unsafe_get str i in
    let stack = feed state c stack in
    feed_subbytes_unsafe str state stack (i + 1) stop)
  else stack
;;

let feed_substring state str ~pos ~len stack =
  let str_len = String.length str in
  if pos < 0 || len < 0 || pos > str_len - len then invalid_arg "Parsexp.feed_substring";
  feed_substring_unsafe str state stack pos (pos + len)
;;

let feed_subbytes state str ~pos ~len stack =
  let str_len = Bytes.length str in
  if pos < 0 || len < 0 || pos > str_len - len then invalid_arg "Parsexp.feed_subbytes";
  feed_subbytes_unsafe str state stack pos (pos + len)
;;

let feed_string state str stack =
  feed_substring_unsafe str state stack 0 (String.length str)
;;

let feed_bytes state str stack = feed_subbytes_unsafe str state stack 0 (Bytes.length str)

let empty_stack : type u s. (u, s) Kind.t -> s = function
  | Sexp -> Stack.empty
  | Sexp_with_positions -> Stack.empty
  | Positions -> Stack.Just_positions.empty
  | Cst -> Stack.For_cst.empty
;;

let of_substring (type u s) (mode : (u, s) Mode.t) (kind : (u, s) Kind.t) s ~pos ~len =
  let state = create mode kind in
  let stack = feed_substring state s ~pos ~len (empty_stack kind) in
  state, stack
;;
end
module Parser : sig
include Parser_intf.Parser (** @inline *)
end = struct
open! Import
include Parser_intf
module A = Automaton

let kind_to_stack
  : type stack.
    ('state, stack) Automaton_state.Kind.t -> (module Stack with type t = stack)
  =
  fun (type state) (kind : (state, stack) Automaton_state.Kind.t) ->
  match kind with
  | Sexp -> (module Automaton_stack : Stack with type t = stack)
  | Positions -> (module Automaton_stack.Just_positions : Stack with type t = stack)
  | Sexp_with_positions -> (module Automaton_stack : Stack with type t = stack)
  | Cst -> (module Automaton_stack.For_cst : Stack with type t = stack)
;;

let make (type stack state parsed_value) kind mode make_value
  : (module S
       with type parsed_value = parsed_value
        and type State.t = (state, stack) Automaton_state.t
        and type Stack.t = stack)
  =
  (module struct
    type nonrec parsed_value = parsed_value

    module Stack = (val kind_to_stack kind : Stack with type t = stack)

    module State = struct
      type t = (state, Stack.t) Automaton_state.t

      let create ?pos () = A.create ?initial_pos:pos mode kind
      let reset = A.reset
      let offset = A.offset
      let line = A.line
      let column = A.column

      let position t : Positions.pos =
        { offset = offset t; line = line t; col = column t }
      ;;

      let stop state = A.set_error_state state
    end

    let feed = A.feed
    let feed_eoi state stack = make_value state (A.feed_eoi state stack)
    let feed_substring = Automaton.feed_substring
    let feed_string = Automaton.feed_string
    let feed_subbytes = Automaton.feed_subbytes
    let feed_bytes = Automaton.feed_bytes

    let parse_string_exn str =
      let state = State.create () in
      feed_eoi state (feed_string state str Stack.empty)
    ;;

    let parse_string str =
      match parse_string_exn str with
      | x -> Ok x
      | exception Parse_error.Parse_error e -> Error e
    ;;
  end)
;;

let make_eager (type stack state parsed_value) kind make_value
  : (module S_eager
       with type parsed_value = parsed_value
        and type State.t = (state, stack) Automaton_state.t
        and type Stack.t = stack)
  =
  (module struct
    type nonrec parsed_value = parsed_value

    module Stack = (val kind_to_stack kind : Stack with type t = stack)

    module State = struct
      module Read_only = struct
        type t = (state, Stack.t) Automaton_state.t

        let offset = A.offset
        let line = A.line
        let column = A.column

        let position t : Positions.pos =
          { offset = offset t; line = line t; col = column t }
        ;;
      end

      include Read_only

      let create ?pos ?(reraise_notrace = false) ?(no_sexp_is_error = false) f =
        let got_sexp state stack =
          let parsed_value = make_value state stack in
          f state parsed_value;
          Stack.empty
        in
        A.create
          ?initial_pos:pos
          (Eager { got_sexp; reraise_notrace; no_sexp_is_error })
          kind
      ;;

      let reset = A.reset
      let stop t = A.set_error_state t
      let old_parser_cont_state t = Automaton.old_parser_cont_state t
    end

    let feed = A.feed
    let feed_eoi state stack = ignore (A.feed_eoi state stack : Stack.t)
    let feed_substring = Automaton.feed_substring
    let feed_string = Automaton.feed_string
    let feed_subbytes = Automaton.feed_subbytes
    let feed_bytes = Automaton.feed_bytes

    module Lexbuf_consumer = struct
      type t = State.t

      exception Got_sexp of parsed_value * Positions.pos

      let got_sexp state parsed_value =
        raise_notrace (Got_sexp (parsed_value, State.position state))
      ;;

      let create () = State.create got_sexp

      let pos_of_lexbuf lexbuf =
        let p = lexbuf.Lexing.lex_curr_p in
        { Positions.line = p.pos_lnum; col = p.pos_cnum - p.pos_bol; offset = p.pos_cnum }
      ;;

      let update_lexbuf (lexbuf : Lexing.lexbuf) (pos : Positions.pos) =
        let p = pos.offset - lexbuf.lex_abs_pos in
        lexbuf.lex_curr_pos <- p;
        lexbuf.lex_start_pos <- p;
        lexbuf.lex_curr_p
          <- { lexbuf.lex_curr_p with
               pos_lnum = pos.line
             ; pos_cnum = pos.offset
             ; pos_bol = pos.offset - pos.col
             }
      ;;

      let rec feed_lexbuf t (lexbuf : Lexing.lexbuf) stack =
        let stack =
          feed_subbytes
            t
            lexbuf.lex_buffer
            stack
            ~pos:lexbuf.lex_curr_pos
            ~len:(lexbuf.lex_buffer_len - lexbuf.lex_curr_pos)
        in
        lexbuf.lex_curr_pos <- lexbuf.lex_buffer_len;
        lexbuf.lex_start_pos <- lexbuf.lex_buffer_len;
        if not lexbuf.lex_eof_reached
        then (
          lexbuf.refill_buff lexbuf;
          feed_lexbuf t lexbuf stack)
        else feed_eoi t stack
      ;;

      let parse_gen t (lexbuf : Lexing.lexbuf) =
        A.reset t ~pos:(pos_of_lexbuf lexbuf);
        match feed_lexbuf t lexbuf Stack.empty with
        | () ->
          update_lexbuf lexbuf (State.position t);
          None
        | exception Got_sexp (parsed_value, pos) ->
          update_lexbuf lexbuf pos;
          Some parsed_value
        | exception exn ->
          update_lexbuf lexbuf (State.position t);
          raise exn
      ;;

      let set_no_sexp_is_error t x =
        match A.mode t with
        | Eager e -> e.no_sexp_is_error <- x
        | _ -> assert false
      ;;

      let parse t lexbuf =
        set_no_sexp_is_error t true;
        match parse_gen t lexbuf with
        | Some x -> x
        | None -> failwith "Parsexp.parse_gen: None"
      ;;

      let parse_opt t lexbuf =
        set_no_sexp_is_error t false;
        parse_gen t lexbuf
      ;;
    end
  end)
;;
end
module Conv_intf = struct
open! Import

module type S = sig
  type 'a res
  type chunk_to_conv
  type parsed_sexp

  val parse_string : string -> (chunk_to_conv -> 'a) -> ('a res, Conv_error.t) result
  val parse_string_exn : string -> (chunk_to_conv -> 'a) -> 'a res

  val conv
    :  parsed_sexp * Positions.t
    -> (chunk_to_conv -> 'a)
    -> ('a res, Of_sexp_error.t) result

  val conv_exn : parsed_sexp * Positions.t -> (chunk_to_conv -> 'a) -> 'a res

  (** Convenience function for merging parsing and conversion errors.

      For instance if you have a [load] function as follow:

      {[
        val load : string -> (Sexp.t list * Positions.t, Parse_error.t) result
      ]}

      then you can create a [load_conv] function as follow:

      {[
        let load_conv : string -> (Sexp.t -> 'a) -> ('a list, Conv_error.t) result
          = fun filename f -> conv_combine (load filename) f
      ]}
  *)
  val conv_combine
    :  (parsed_sexp * Positions.t, Parse_error.t) result
    -> (chunk_to_conv -> 'a)
    -> ('a res, Conv_error.t) result
end

module type Mode = sig
  type parsed_sexp
  type 'a res
  type chunk_to_conv

  val apply_f : parsed_sexp -> f:(chunk_to_conv -> 'r) -> 'r res
  val find : Positions.t -> parsed_sexp -> sub:Sexp.t -> Positions.range option
end

module type Conv = sig
  module type Mode = Mode
  module type S = S

  module Make
    (Mode : Mode)
    (Sexp_parser : Parser.S with type parsed_value = Mode.parsed_sexp)
    (Positions_parser : Parser.S with type parsed_value = Positions.t) :
    S
      with type parsed_sexp := Mode.parsed_sexp
      with type chunk_to_conv := Mode.chunk_to_conv
      with type 'a res := 'a Mode.res
end
end
module Conv : sig
include Conv_intf.Conv (** @inline *)
end = struct
open! Import
include Conv_intf

module Make
  (Mode : Mode)
  (Sexp_parser : Parser.S with type parsed_value = Mode.parsed_sexp)
  (Positions_parser : Parser.S with type parsed_value = Positions.t) =
struct
  let reraise positions parsed_value ~sub user_exn =
    let location = Mode.find positions parsed_value ~sub in
    Of_sexp_error.raise ~user_exn ~sub_sexp:sub ~location
  ;;

  let parse_string_exn str f =
    let parsed_value = Sexp_parser.parse_string_exn str in
    match Mode.apply_f parsed_value ~f with
    | x -> x
    | exception Sexp.Of_sexp_error (exn, sub) ->
      let positions = Positions_parser.parse_string_exn str in
      reraise positions parsed_value exn ~sub
  ;;

  let parse_string str f : (_, Conv_error.t) result =
    match parse_string_exn str f with
    | x -> Ok x
    | exception Parse_error.Parse_error e -> Error (Parse_error e)
    | exception Of_sexp_error.Of_sexp_error e -> Error (Of_sexp_error e)
  ;;

  let conv_exn (parsed_value, positions) f =
    match Mode.apply_f parsed_value ~f with
    | x -> x
    | exception Sexp.Of_sexp_error (exn, sub) -> reraise positions parsed_value exn ~sub
  ;;

  let conv x f =
    match conv_exn x f with
    | x -> Ok x
    | exception Of_sexp_error.Of_sexp_error e -> Error e
  ;;

  let conv_combine result f : (_, Conv_error.t) result =
    match result with
    | Error e -> Error (Parse_error e)
    | Ok x ->
      (match conv x f with
       | Ok _ as r -> r
       | Error e -> Error (Of_sexp_error e))
  ;;
end
end
module Parsexp_intf = struct
(** Parsing of s-expression *)

open! Import

module type Parsexp = sig
  module Conv_error = Conv_error
  module Of_sexp_error = Of_sexp_error
  module Old_parser_cont_state = Old_parser_cont_state
  module Parse_error = Parse_error
  module Positions = Positions
  module Cst = Cst

  module type Conv = Conv.S
  module type Parser = Parser.S
  module type Eager_parser = Parser.S_eager

  (** Exception raised in case of a conversion error *)
  exception Of_sexp_error of Of_sexp_error.t

  (** Exception raised in case of a parsing error *)
  exception Parse_error of Parse_error.t

  module Single :
    Parser
      with type parsed_value = Sexp.t
       and type State.t = (unit, Automaton_stack.t) Automaton_state.t
       and type Stack.t = Automaton_stack.t

  module Many :
    Parser
      with type parsed_value = Sexp.t list
       and type State.t = (unit, Automaton_stack.t) Automaton_state.t
       and type Stack.t = Automaton_stack.t

  module Eager :
    Eager_parser
      with type parsed_value = Sexp.t
       and type State.t = (unit, Automaton_stack.t) Automaton_state.t
       and type Stack.t = Automaton_stack.t

  module Single_and_positions :
    Parser
      with type parsed_value = Sexp.t * Positions.t
       and type State.t = (Positions.Builder.t, Automaton_stack.t) Automaton_state.t
       and type Stack.t = Automaton_stack.t

  module Many_and_positions :
    Parser
      with type parsed_value = Sexp.t list * Positions.t
       and type State.t = (Positions.Builder.t, Automaton_stack.t) Automaton_state.t
       and type Stack.t = Automaton_stack.t

  module Eager_and_positions :
    Eager_parser
      with type parsed_value = Sexp.t * Positions.t
       and type State.t = (Positions.Builder.t, Automaton_stack.t) Automaton_state.t
       and type Stack.t = Automaton_stack.t

  module Single_just_positions :
    Parser
      with type parsed_value = Positions.t
       and type State.t = (Positions.Builder.t, unit) Automaton_state.t
       and type Stack.t = unit

  module Many_just_positions :
    Parser
      with type parsed_value = Positions.t
       and type State.t = (Positions.Builder.t, unit) Automaton_state.t
       and type Stack.t = unit

  module Eager_just_positions :
    Eager_parser
      with type parsed_value = Positions.t
       and type State.t = (Positions.Builder.t, unit) Automaton_state.t
       and type Stack.t = unit

  module Many_cst :
    Parser
      with type parsed_value = Cst.t_or_comment list
       and type State.t =
        (Automaton_state.For_cst.t, Automaton_stack.For_cst.t) Automaton_state.t
       and type Stack.t = Automaton_stack.For_cst.t

  module Eager_cst :
    Eager_parser
      with type parsed_value = Cst.t_or_comment
       and type State.t =
        (Automaton_state.For_cst.t, Automaton_stack.For_cst.t) Automaton_state.t
       and type Stack.t = Automaton_stack.For_cst.t

  (*_ These type synonyms are introduced because ocaml <4.06
    do not support destructive substitutions with `type 'a t1 = t2`
    or `type t1 = 'a t2`. *)
  type 'a id = 'a
  type sexp_list = Sexp.t list

  module Conv_single :
    Conv
      with type 'a res := 'a id
       and type parsed_sexp := Sexp.t
       and type chunk_to_conv := Sexp.t

  module Conv_many :
    Conv
      with type 'a res := 'a list
       and type parsed_sexp := sexp_list
       and type chunk_to_conv := Sexp.t

  module Conv_many_and_locations :
    Conv
      with type 'a res := 'a list
       and type parsed_sexp := sexp_list * Positions.t
       and type chunk_to_conv := Sexp.t * Positions.range

  module Conv_many_at_once :
    Conv
      with type 'a res := 'a id
       and type parsed_sexp := sexp_list
       and type chunk_to_conv := sexp_list

  (*_ For tests *)
  (*_ See the Jane Street Style Guide for an explanation of [Private] submodules:

    https://opensource.janestreet.com/standards/#private-submodules *)
  module Private : sig
    module Automaton = Automaton
    module Automaton_stack = Automaton_stack
    module Automaton_state = Automaton_state
    module Positions = Positions
  end
end
end
module Parsexp : sig
include Parsexp_intf.Parsexp (** @inline *)
end = struct
open! Import

module type Conv = Conv.S
module type Parser = Parser.S
module type Eager_parser = Parser.S_eager

module Conv_error = Conv_error
module Of_sexp_error = Of_sexp_error
module Old_parser_cont_state = Old_parser_cont_state
module Parse_error = Parse_error
module Positions = Positions
module Cst = Cst
module A = Automaton

exception Parse_error = Parse_error.Parse_error
exception Of_sexp_error = Of_sexp_error.Of_sexp_error

let const c _ = c

module Single = (val Parser.make Sexp Single (const Automaton_stack.get_single))
module Many = (val Parser.make Sexp Many (const Automaton_stack.get_many))
module Eager = (val Parser.make_eager Sexp (const Automaton_stack.get_single))

let and_get_positions get_sexp state stack = get_sexp stack, A.positions state

let and_positions mode get_sexp =
  Parser.make Sexp_with_positions mode (and_get_positions get_sexp)
;;

module Single_and_positions = (val and_positions Single Automaton_stack.get_single)
module Many_and_positions = (val and_positions Many Automaton_stack.get_many)

module Eager_and_positions =
  (val Parser.make_eager
         Sexp_with_positions
         (Automaton_stack.get_single |> and_get_positions))

let just_get_positions state () = A.positions state
let just_positions mode = Parser.make Positions mode just_get_positions

module Single_just_positions = (val just_positions Single)
module Many_just_positions = (val just_positions Many)
module Eager_just_positions = (val Parser.make_eager Positions just_get_positions)

let cst mode f = Parser.make Cst mode (const f)

module Many_cst = (val cst Many Automaton_stack.For_cst.get_many)

module Eager_cst =
  (val Parser.make_eager Cst (fun _ stack ->
         match Automaton_stack.For_cst.get_many stack with
         | [ sexp ] -> sexp
         | _ -> assert false))

type 'a id = 'a
type sexp_list = Sexp.t list

module Conv_single =
  Conv.Make
    (struct
      type 'a res = 'a
      type parsed_sexp = Sexp.t
      type chunk_to_conv = Sexp.t

      let apply_f x ~f = f x
      let find = Positions.find_sub_sexp_phys
    end)
    (Single)
    (Single_just_positions)

module Conv_many =
  Conv.Make
    (struct
      type 'a res = 'a list
      type parsed_sexp = Sexp.t list
      type chunk_to_conv = Sexp.t

      let apply_f x ~f = List.rev (List.rev_map x ~f)
      let find = Positions.find_sub_sexp_in_list_phys
    end)
    (Many)
    (Many_just_positions)

module Conv_many_and_locations =
  Conv.Make
    (struct
      type 'a res = 'a list
      type parsed_sexp = Sexp.t list * Positions.t
      type chunk_to_conv = Sexp.t * Positions.range

      let find positions (s, _) ~sub =
        Positions.find_sub_sexp_in_list_phys positions s ~sub
      ;;

      let apply_f (sexps, positions) ~f =
        let iter = Positions.Iterator.create positions in
        List.rev
          (List.rev_map sexps ~f:(fun sexp ->
             let location = Positions.Iterator.advance_sexp_exn iter sexp in
             f (sexp, location)))
      ;;
    end)
    (Many_and_positions)
    (Many_just_positions)

module Conv_many_at_once =
  Conv.Make
    (struct
      type 'a res = 'a
      type parsed_sexp = Sexp.t list
      type chunk_to_conv = Sexp.t list

      let apply_f x ~f = f x
      let find = Positions.find_sub_sexp_in_list_phys
    end)
    (Many)
    (Many_just_positions)

module Private = struct
  module Automaton = Automaton
  module Automaton_stack = Automaton_stack
  module Automaton_state = Automaton_state
  module Positions = Positions
end
end
open Parsexp
open Sexplib0.Sexp_conv
(* THIS FILE WAS AUTOMATICALLY GENERATED BY CAT'ING LIBRARY SOURCES *)
[@@@ocaml.warning "-27-32-35"]
module Mach_error = struct
[@@@ocaml.ppx.context
  {
    tool_name = "ppx_driver";
    include_dirs = [];
    hidden_include_dirs = [];
    load_path = ([], []);
    open_modules = [];
    for_package = None;
    debug = false;
    use_threads = false;
    use_vmthreads = false;
    recursive_types = false;
    principal = false;
    no_alias_deps = false;
    unboxed_types = false;
    unsafe_string = false;
    cookies = [("library-name", "mach_lib")]
  }]
exception Mach_user_error of string 
let user_errorf fmt =
  Printf.ksprintf (fun msg -> raise (Mach_user_error msg)) fmt
type t = [ `User_error of string ]
end
module Mach_std = struct
[@@@ocaml.ppx.context
  {
    tool_name = "ppx_driver";
    include_dirs = [];
    hidden_include_dirs = [];
    load_path = ([], []);
    open_modules = [];
    for_package = None;
    debug = false;
    use_threads = false;
    use_vmthreads = false;
    recursive_types = false;
    principal = false;
    no_alias_deps = false;
    unboxed_types = false;
    unsafe_string = false;
    cookies = [("library-name", "mach_lib")]
  }]
[@@@ocaml.text " Standard utility functions used across the Mach code. "]
open Printf
open Sexplib0.Sexp_conv
module Filename = struct include Filename
                         let (/) = concat end
module Buffer =
  struct
    include Buffer
    let output_line oc line = output_string oc line; output_char oc '\n'
  end
module SS = (Set.Make)(String)
module SM = (Map.Make)(String)
type 'a with_loc = {
  v: 'a ;
  filename: string ;
  line: int }[@@deriving sexp]
include
  struct
    let _ = fun (_ : 'a with_loc) -> ()
    let with_loc_of_sexp :
      'a . (Sexplib0.Sexp.t -> 'a) -> Sexplib0.Sexp.t -> 'a with_loc =
      let error_source__003_ = "lib/mach_std.ml.with_loc" in
      fun _of_a__001_ x__004_ ->
        Sexplib0.Sexp_conv_record.record_of_sexp ~caller:error_source__003_
          ~fields:(Field
                     {
                       name = "v";
                       kind = Required;
                       conv = _of_a__001_;
                       rest =
                         (Field
                            {
                              name = "filename";
                              kind = Required;
                              conv = string_of_sexp;
                              rest =
                                (Field
                                   {
                                     name = "line";
                                     kind = Required;
                                     conv = int_of_sexp;
                                     rest = Empty
                                   })
                            })
                     })
          ~index_of_field:(function
                           | "v" -> 0
                           | "filename" -> 1
                           | "line" -> 2
                           | _ -> (-1)) ~allow_extra_fields:false
          ~create:(fun (v, (filename, (line, ()))) ->
                     ({ v; filename; line } : _ with_loc)) x__004_
    let _ = with_loc_of_sexp
    let sexp_of_with_loc :
      'a . ('a -> Sexplib0.Sexp.t) -> 'a with_loc -> Sexplib0.Sexp.t =
      fun _of_a__005_
        { v = v__007_; filename = filename__009_; line = line__011_ } ->
        let bnds__006_ = ([] : _ Stdlib.List.t) in
        let bnds__006_ =
          let arg__012_ = sexp_of_int line__011_ in
          ((Sexplib0.Sexp.List [Sexplib0.Sexp.Atom "line"; arg__012_]) ::
            bnds__006_ : _ Stdlib.List.t) in
        let bnds__006_ =
          let arg__010_ = sexp_of_string filename__009_ in
          ((Sexplib0.Sexp.List [Sexplib0.Sexp.Atom "filename"; arg__010_]) ::
            bnds__006_ : _ Stdlib.List.t) in
        let bnds__006_ =
          let arg__008_ = _of_a__005_ v__007_ in
          ((Sexplib0.Sexp.List [Sexplib0.Sexp.Atom "v"; arg__008_]) ::
            bnds__006_ : _ Stdlib.List.t) in
        Sexplib0.Sexp.List bnds__006_
    let _ = sexp_of_with_loc
  end[@@ocaml.doc "@inline"][@@merlin.hide ]
let equal_without_loc a b = a.v = b.v
let failwithf fmt = ksprintf failwith fmt
let command_exists cmd =
  (Sys.command (sprintf "command -v %s >/dev/null 2>&1" (Filename.quote cmd)))
    = 0
let run_cmd cmd =
  let ic = Unix.open_process_in cmd in
  let output = try Some (input_line ic) with | End_of_file -> None in
  match Unix.close_process_in ic with | Unix.WEXITED 0 -> output | _ -> None
let run_cmd_lines cmd =
  let ic = Unix.open_process_in cmd in
  let lines = In_channel.input_lines ic in
  match Unix.close_process_in ic with | Unix.WEXITED 0 -> lines | _ -> []
let rec mkdir_p path =
  if Sys.file_exists path
  then ()
  else
    (mkdir_p (Filename.dirname path);
     (try Unix.mkdir path 0o755
      with | Unix.Unix_error (Unix.EEXIST, _, _) -> ()))
let rm_rf path =
  let cmd = sprintf "rm -rf %s" (Filename.quote path) in
  if (Sys.command cmd) <> 0 then failwithf "Command failed: %s" cmd
let write_file path content =
  Out_channel.with_open_text path (fun oc -> output_string oc content)
end
module Ninja : sig
[@@@ocaml.ppx.context
  {
    tool_name = "ppx_driver";
    include_dirs = [];
    hidden_include_dirs = [];
    load_path = ([], []);
    open_modules = [];
    for_package = None;
    debug = false;
    use_threads = false;
    use_vmthreads = false;
    recursive_types = false;
    principal = false;
    no_alias_deps = false;
    unboxed_types = false;
    unsafe_string = false;
    cookies = [("library-name", "mach_lib")]
  }]
type t
val create : unit -> t
val contents : t -> string
val var : t -> string -> string -> unit
val subninja : t -> string -> unit
val rule : t -> target:string -> deps:string list -> string list -> unit
val rulef :
  t ->
    target:string ->
      deps:string list -> ('a, unit, string, unit) format4 -> 'a
val rule_phony : t -> target:string -> deps:string list -> unit
end = struct
[@@@ocaml.ppx.context
  {
    tool_name = "ppx_driver";
    include_dirs = [];
    hidden_include_dirs = [];
    load_path = ([], []);
    open_modules = [];
    for_package = None;
    debug = false;
    use_threads = false;
    use_vmthreads = false;
    recursive_types = false;
    principal = false;
    no_alias_deps = false;
    unboxed_types = false;
    unsafe_string = false;
    cookies = [("library-name", "mach_lib")]
  }]
open Printf
type t = Buffer.t
let create () =
  let buf = Buffer.create 1024 in
  bprintf buf "rule cmd\n  command = $cmd\n\n"; buf
let var buf name value = bprintf buf "%s = %s\n\n" name value
let contents = Buffer.contents
let subninja buf path = bprintf buf "subninja %s\n" path
let rule buf ~target ~deps recipe =
  bprintf buf "build %s:" target;
  (match recipe with
   | [] ->
       (bprintf buf " phony";
        List.iter (bprintf buf " %s") deps;
        Buffer.add_char buf '\n')
   | _ ->
       (bprintf buf " cmd";
        List.iter (bprintf buf " %s") deps;
        Buffer.add_char buf '\n';
        bprintf buf "  cmd = %s\n" (String.concat " && " recipe)));
  Buffer.add_char buf '\n'
let rulef buf ~target ~deps fmt =
  ksprintf (fun recipe -> rule buf ~target ~deps [recipe]) fmt
let rule_phony buf ~target ~deps =
  bprintf buf "build %s: phony" target;
  List.iter (bprintf buf " %s") deps;
  Buffer.add_char buf '\n';
  Buffer.add_char buf '\n'
end
module Mach_module : sig
[@@@ocaml.ppx.context
  {
    tool_name = "ppx_driver";
    include_dirs = [];
    hidden_include_dirs = [];
    load_path = ([], []);
    open_modules = [];
    for_package = None;
    debug = false;
    use_threads = false;
    use_vmthreads = false;
    recursive_types = false;
    principal = false;
    no_alias_deps = false;
    unboxed_types = false;
    unsafe_string = false;
    cookies = [("library-name", "mach_lib")]
  }]
[@@@ocaml.text
  " Modules which are build with mach are .ml files with mach directives. This\n    module helps processing those. "]
open! Mach_std
val extract_requires :
  string ->
    ((string with_loc list * string with_loc list), Mach_error.t) result
[@@ocaml.doc " Extract #require directives from a source file "]
val extract_requires_exn :
  string -> (string with_loc list * string with_loc list)[@@ocaml.doc
                                                           " Extract #require directives from a source file, raises on error "]
val preprocess_source :
  source_path:string -> out_channel -> in_channel -> unit[@@ocaml.doc
                                                           " Preprocess source file, stripping directives while preserving line numbers "]
end = struct
[@@@ocaml.ppx.context
  {
    tool_name = "ppx_driver";
    include_dirs = [];
    hidden_include_dirs = [];
    load_path = ([], []);
    open_modules = [];
    for_package = None;
    debug = false;
    use_threads = false;
    use_vmthreads = false;
    recursive_types = false;
    principal = false;
    no_alias_deps = false;
    unboxed_types = false;
    unsafe_string = false;
    cookies = [("library-name", "mach_lib")]
  }]
open! Mach_std
open Printf
let is_empty_line line =
  String.for_all (function | ' ' | '\t' -> true | _ -> false) line
let is_shebang line =
  ((String.length line) >= 2) && (((line.[0]) = '#') && ((line.[1]) = '!'))
let is_directive line = ((String.length line) >= 1) && ((line.[0]) = '#')
let preprocess_source ~source_path oc ic =
  fprintf oc "# 1 %S\n" source_path;
  (let rec loop in_header =
     match In_channel.input_line ic with
     | None -> ()
     | Some line when is_empty_line line ->
         (Buffer.output_line oc line; loop in_header)
     | Some line when in_header && (is_directive line) ->
         (Buffer.output_line oc ""; loop true)
     | Some line -> (Buffer.output_line oc line; loop false) in
   loop true)
let is_require_path s = String.contains s '/'
let resolve_require ~source_path ~line path =
  let base_path =
    if Filename.is_relative path
    then Filename.concat (Filename.dirname source_path) path
    else path in
  let candidates = [base_path ^ ".ml"; base_path ^ ".mlx"] in
  let rec find_file =
    function
    | [] ->
        Mach_error.user_errorf "%s:%d: %s: No such file or directory"
          source_path line path
    | candidate::rest ->
        if Sys.file_exists candidate
        then
          (try Unix.realpath candidate
           with
           | Unix.Unix_error (err, _, _) ->
               Mach_error.user_errorf "%s:%d: %s: %s" source_path line path
                 (Unix.error_message err))
        else find_file rest in
  find_file candidates
let extract_requires_exn source_path :
  (string with_loc list * string with_loc list)=
  let rec parse line_num (requires, libs) ic =
    match In_channel.input_line ic with
    | Some line when is_shebang line ->
        parse (line_num + 1) (requires, libs) ic
    | Some line when is_directive line ->
        let req =
          try Scanf.sscanf line "#require %S%_s" Fun.id
          with
          | Scanf.Scan_failure _ | End_of_file ->
              Mach_error.user_errorf "%s:%d: invalid #require directive"
                source_path line_num in
        if is_require_path req
        then
          let resolved = resolve_require ~source_path ~line:line_num req in
          let requires =
            { v = resolved; filename = source_path; line = line_num } ::
            requires in
          parse (line_num + 1) (requires, libs) ic
        else
          (let lib = { v = req; filename = source_path; line = line_num } in
           parse (line_num + 1) (requires, (lib :: libs)) ic)
    | Some line when is_empty_line line ->
        parse (line_num + 1) (requires, libs) ic
    | None | Some _ -> ((List.rev requires), (List.rev libs)) in
  In_channel.with_open_text source_path (parse 1 ([], []))
let extract_requires source_path =
  try Ok (extract_requires_exn source_path)
  with | Mach_error.Mach_user_error msg -> Error (`User_error msg)
end
module Mach_log : sig
[@@@ocaml.ppx.context
  {
    tool_name = "ppx_driver";
    include_dirs = [];
    hidden_include_dirs = [];
    load_path = ([], []);
    open_modules = [];
    for_package = None;
    debug = false;
    use_threads = false;
    use_vmthreads = false;
    recursive_types = false;
    principal = false;
    no_alias_deps = false;
    unboxed_types = false;
    unsafe_string = false;
    cookies = [("library-name", "mach_lib")]
  }]
type verbose =
  | Quiet 
  | Verbose 
  | Very_verbose 
  | Very_very_verbose 
val verbose : verbose ref
val log_verbose : ('a, unit, string, unit) format4 -> 'a
val log_very_verbose : ('a, unit, string, unit) format4 -> 'a
end = struct
[@@@ocaml.ppx.context
  {
    tool_name = "ppx_driver";
    include_dirs = [];
    hidden_include_dirs = [];
    load_path = ([], []);
    open_modules = [];
    for_package = None;
    debug = false;
    use_threads = false;
    use_vmthreads = false;
    recursive_types = false;
    principal = false;
    no_alias_deps = false;
    unboxed_types = false;
    unsafe_string = false;
    cookies = [("library-name", "mach_lib")]
  }]
type verbose =
  | Quiet 
  | Verbose 
  | Very_verbose 
  | Very_very_verbose 
let verbose = ref Quiet
let log_at level fmt =
  Printf.ksprintf
    (fun msg -> if (!verbose) >= level then Printf.eprintf "%s\n%!" msg) fmt
let log_verbose fmt = log_at Verbose fmt
let log_very_verbose fmt = log_at Very_verbose fmt
end
module Mach_config : sig
[@@@ocaml.ppx.context
  {
    tool_name = "ppx_driver";
    include_dirs = [];
    hidden_include_dirs = [];
    load_path = ([], []);
    open_modules = [];
    for_package = None;
    debug = false;
    use_threads = false;
    use_vmthreads = false;
    recursive_types = false;
    principal = false;
    no_alias_deps = false;
    unboxed_types = false;
    unsafe_string = false;
    cookies = [("library-name", "mach_lib")]
  }]
[@@@ocaml.text " Mach configuration discovery and parsing "]
open! Mach_std
type ocamlfind_info =
  {
  ocamlfind_version: string option ;
  ocamlfind_libs: string SM.t [@ocaml.doc " package name -> version "]}
[@@ocaml.doc " Ocamlfind information "]
type toolchain =
  {
  ocaml_version: string ;
  ocamlfind: ocamlfind_info Lazy.t
    [@ocaml.doc " lazily discovered on first #require \"lib\" "]}[@@ocaml.doc
                                                                   " Detected toolchain versions "]
type t = {
  home: string ;
  mach_executable_path: string ;
  toolchain: toolchain }[@@ocaml.doc " Mach configuration "]
val get : unit -> (t, Mach_error.t) result[@@ocaml.doc
                                            " Get the current configuration.\n    Resolution order:\n    1. $MACH_HOME env var if set\n    2. Walk up from cwd to find Mach file\n    3. Fall back to $XDG_STATE_HOME/mach (or ~/.local/state/mach) "]
val build_dir_of : t -> string -> string[@@ocaml.doc
                                          " Get build directory for a script path "]
end = struct
[@@@ocaml.ppx.context
  {
    tool_name = "ppx_driver";
    include_dirs = [];
    hidden_include_dirs = [];
    load_path = ([], []);
    open_modules = [];
    for_package = None;
    debug = false;
    use_threads = false;
    use_vmthreads = false;
    recursive_types = false;
    principal = false;
    no_alias_deps = false;
    unboxed_types = false;
    unsafe_string = false;
    cookies = [("library-name", "mach_lib")]
  }]
open! Mach_std
open Sexplib0.Sexp_conv
open Printf
type ocamlfind_info =
  {
  ocamlfind_version: string option ;
  ocamlfind_libs: string SM.t }
type toolchain = {
  ocaml_version: string ;
  ocamlfind: ocamlfind_info Lazy.t }
let detect_ocamlfind () =
  if command_exists "ocamlfind"
  then
    let version = run_cmd "ocamlfind query -format '%v' findlib" in
    let libs =
      (run_cmd_lines "ocamlfind list") |>
        (List.fold_left
           (fun acc line ->
              match Scanf.sscanf_opt line "%s %_s@(version: %[^)])"
                      (fun n v -> (n, v))
              with
              | Some (name, ver) -> SM.add name ver acc
              | None ->
                  failwithf "unable to parse `ocamlfind list` line: %s" line)
           SM.empty) in
    { ocamlfind_version = version; ocamlfind_libs = libs }
  else { ocamlfind_version = None; ocamlfind_libs = SM.empty }
let detect_toolchain () =
  let ocaml_version =
    match run_cmd "ocamlopt -version" with
    | Some v -> v
    | None -> Mach_error.user_errorf "ocamlopt not found" in
  { ocaml_version; ocamlfind = (lazy (detect_ocamlfind ())) }
type t = {
  home: string ;
  mach_executable_path: string ;
  toolchain: toolchain }
type config_file = unit[@@deriving sexp]
include
  struct
    let _ = fun (_ : config_file) -> ()
    let config_file_of_sexp = (unit_of_sexp : Sexplib0.Sexp.t -> config_file)
    let _ = config_file_of_sexp
    let sexp_of_config_file = (sexp_of_unit : config_file -> Sexplib0.Sexp.t)
    let _ = sexp_of_config_file
  end[@@ocaml.doc "@inline"][@@merlin.hide ]
let mach_executable_path =
  lazy
    (match Sys.backend_type with
     | Sys.Native -> Unix.realpath Sys.executable_name
     | Sys.Bytecode ->
         let script =
           let path = Sys.argv.(0) in
           if Filename.is_relative path
           then let open Filename in (Sys.getcwd ()) / path
           else path in
         sprintf "%s -I +unix unix.cma %s"
           (Filename.quote Sys.executable_name)
           (Filename.quote (Unix.realpath script))
     | Sys.Other _ ->
         failwith "mach must be run as a native/bytecode executable")
let parse_file path =
  try
    let content = In_channel.with_open_text path In_channel.input_all in
    let sexp = Parsexp.Single.parse_string_exn content in
    Ok (config_file_of_sexp sexp)
  with
  | exn ->
      Error (`User_error (sprintf "%s: %s" path (Printexc.to_string exn)))
let find_mach_config () =
  let rec search dir =
    let mach_path = let open Filename in dir / "Mach" in
    if Sys.file_exists mach_path
    then Some (dir, mach_path)
    else
      (let parent = Filename.dirname dir in
       if parent = dir then None else search parent) in
  search (Sys.getcwd ())
let make_config ?mach_path home =
  let mach_executable_path = Lazy.force mach_executable_path in
  let toolchain = detect_toolchain () in
  let mach_path =
    Option.value mach_path ~default:(let open Filename in home / "Mach") in
  if Sys.file_exists mach_path
  then
    match parse_file mach_path with
    | Ok () -> Ok { home; mach_executable_path; toolchain }
    | Error _ as err -> err
  else Ok { home; mach_executable_path; toolchain }
let config =
  lazy
    (match Sys.getenv_opt "MACH_HOME" with
     | Some home -> make_config home
     | None ->
         (match find_mach_config () with
          | Some (home, mach_path) -> make_config ~mach_path home
          | None ->
              let home =
                match Sys.getenv_opt "XDG_STATE_HOME" with
                | Some xdg -> let open Filename in xdg / "mach"
                | None ->
                    let open Filename in
                      (((Sys.getenv "HOME") / ".local") / "state") / "mach" in
              make_config home))
let get () = Lazy.force config
let build_dir_of config script_path =
  let normalized =
    (String.split_on_char '/' script_path) |> (String.concat "__") in
  let open Filename in ((config.home / "_mach") / "build") / normalized
end
module Mach_state : sig
[@@@ocaml.ppx.context
  {
    tool_name = "ppx_driver";
    include_dirs = [];
    hidden_include_dirs = [];
    load_path = ([], []);
    open_modules = [];
    for_package = None;
    debug = false;
    use_threads = false;
    use_vmthreads = false;
    recursive_types = false;
    principal = false;
    no_alias_deps = false;
    unboxed_types = false;
    unsafe_string = false;
    cookies = [("library-name", "mach_lib")]
  }]
[@@@ocaml.text " Mach state keep stats of a dependency graph of modules. "]
open! Mach_std
type file_stat = {
  mtime: int ;
  size: int }
type lib = {
  name: string ;
  version: string }
type entry =
  {
  ml_path: string ;
  mli_path: string option ;
  ml_stat: file_stat ;
  mli_stat: file_stat option ;
  requires: string with_loc list
    [@ocaml.doc " absolute paths to required modules with source location "];
  libs: lib with_loc list
    [@ocaml.doc " ocamlfind libraries with version and source location "]}
type header =
  {
  mach_executable_path: string ;
  ocaml_version: string ;
  ocamlfind_version: string option }[@@ocaml.doc
                                      " State metadata for detecting configuration changes "]
type t = {
  header: header ;
  root: entry ;
  entries: entry list }
val read : string -> t option[@@ocaml.doc
                               " Read state from a file, returns None if file doesn't exist or is invalid "]
val write : string -> t -> unit[@@ocaml.doc " Write state to a file "]
type reconfigure_reason =
  | Env_changed [@ocaml.doc " Mach path or toolchain version changed "]
  | Modules_changed of SS.t
  [@ocaml.doc " Set of ml_path that need reconfiguration "][@@ocaml.doc
                                                             " Reason for reconfiguration "]
val check_reconfigure_exn : Mach_config.t -> t -> reconfigure_reason option
[@@ocaml.doc " Check if state needs reconfiguration, and if so, what kind "]
val collect_exn : Mach_config.t -> string -> t[@@ocaml.doc
                                                " Collect dependency state starting from an entry point module "]
val collect : Mach_config.t -> string -> (t, Mach_error.t) result[@@ocaml.doc
                                                                   " Collect dependency state starting from an entry point module "]
val exe_path : Mach_config.t -> t -> string[@@ocaml.doc
                                             " Get the executable path for a state "]
val source_dirs : t -> string list[@@ocaml.doc
                                    " Get all unique source directories from entries "]
val all_libs : t -> string list[@@ocaml.doc
                                 " Get all unique ocamlfind library names from entries "]
end = struct
[@@@ocaml.ppx.context
  {
    tool_name = "ppx_driver";
    include_dirs = [];
    hidden_include_dirs = [];
    load_path = ([], []);
    open_modules = [];
    for_package = None;
    debug = false;
    use_threads = false;
    use_vmthreads = false;
    recursive_types = false;
    principal = false;
    no_alias_deps = false;
    unboxed_types = false;
    unsafe_string = false;
    cookies = [("library-name", "mach_lib")]
  }]
open! Mach_std
open Sexplib0.Sexp_conv
type file_stat = {
  mtime: int ;
  size: int }[@@deriving sexp]
include
  struct
    let _ = fun (_ : file_stat) -> ()
    let file_stat_of_sexp =
      (let error_source__002_ = "lib/mach_state.ml.file_stat" in
       fun x__003_ ->
         Sexplib0.Sexp_conv_record.record_of_sexp ~caller:error_source__002_
           ~fields:(Field
                      {
                        name = "mtime";
                        kind = Required;
                        conv = int_of_sexp;
                        rest =
                          (Field
                             {
                               name = "size";
                               kind = Required;
                               conv = int_of_sexp;
                               rest = Empty
                             })
                      })
           ~index_of_field:(function | "mtime" -> 0 | "size" -> 1 | _ -> (-1))
           ~allow_extra_fields:false
           ~create:(fun (mtime, (size, ())) -> ({ mtime; size } : file_stat))
           x__003_ : Sexplib0.Sexp.t -> file_stat)
    let _ = file_stat_of_sexp
    let sexp_of_file_stat =
      (fun { mtime = mtime__005_; size = size__007_ } ->
         let bnds__004_ = ([] : _ Stdlib.List.t) in
         let bnds__004_ =
           let arg__008_ = sexp_of_int size__007_ in
           ((Sexplib0.Sexp.List [Sexplib0.Sexp.Atom "size"; arg__008_]) ::
             bnds__004_ : _ Stdlib.List.t) in
         let bnds__004_ =
           let arg__006_ = sexp_of_int mtime__005_ in
           ((Sexplib0.Sexp.List [Sexplib0.Sexp.Atom "mtime"; arg__006_]) ::
             bnds__004_ : _ Stdlib.List.t) in
         Sexplib0.Sexp.List bnds__004_ : file_stat -> Sexplib0.Sexp.t)
    let _ = sexp_of_file_stat
  end[@@ocaml.doc "@inline"][@@merlin.hide ]
let equal_file_stat x y = (x.mtime = y.mtime) && (x.size = y.size)
type lib = {
  name: string ;
  version: string }[@@deriving sexp]
include
  struct
    let _ = fun (_ : lib) -> ()
    let lib_of_sexp =
      (let error_source__010_ = "lib/mach_state.ml.lib" in
       fun x__011_ ->
         Sexplib0.Sexp_conv_record.record_of_sexp ~caller:error_source__010_
           ~fields:(Field
                      {
                        name = "name";
                        kind = Required;
                        conv = string_of_sexp;
                        rest =
                          (Field
                             {
                               name = "version";
                               kind = Required;
                               conv = string_of_sexp;
                               rest = Empty
                             })
                      })
           ~index_of_field:(function
                            | "name" -> 0
                            | "version" -> 1
                            | _ -> (-1)) ~allow_extra_fields:false
           ~create:(fun (name, (version, ())) -> ({ name; version } : lib))
           x__011_ : Sexplib0.Sexp.t -> lib)
    let _ = lib_of_sexp
    let sexp_of_lib =
      (fun { name = name__013_; version = version__015_ } ->
         let bnds__012_ = ([] : _ Stdlib.List.t) in
         let bnds__012_ =
           let arg__016_ = sexp_of_string version__015_ in
           ((Sexplib0.Sexp.List [Sexplib0.Sexp.Atom "version"; arg__016_]) ::
             bnds__012_ : _ Stdlib.List.t) in
         let bnds__012_ =
           let arg__014_ = sexp_of_string name__013_ in
           ((Sexplib0.Sexp.List [Sexplib0.Sexp.Atom "name"; arg__014_]) ::
             bnds__012_ : _ Stdlib.List.t) in
         Sexplib0.Sexp.List bnds__012_ : lib -> Sexplib0.Sexp.t)
    let _ = sexp_of_lib
  end[@@ocaml.doc "@inline"][@@merlin.hide ]
type entry =
  {
  ml_path: string ;
  mli_path: string option ;
  ml_stat: file_stat ;
  mli_stat: file_stat option ;
  requires: string with_loc list ;
  libs: lib with_loc list }[@@deriving sexp]
include
  struct
    let _ = fun (_ : entry) -> ()
    let entry_of_sexp =
      (let error_source__018_ = "lib/mach_state.ml.entry" in
       fun x__019_ ->
         Sexplib0.Sexp_conv_record.record_of_sexp ~caller:error_source__018_
           ~fields:(Field
                      {
                        name = "ml_path";
                        kind = Required;
                        conv = string_of_sexp;
                        rest =
                          (Field
                             {
                               name = "mli_path";
                               kind = Required;
                               conv = (option_of_sexp string_of_sexp);
                               rest =
                                 (Field
                                    {
                                      name = "ml_stat";
                                      kind = Required;
                                      conv = file_stat_of_sexp;
                                      rest =
                                        (Field
                                           {
                                             name = "mli_stat";
                                             kind = Required;
                                             conv =
                                               (option_of_sexp
                                                  file_stat_of_sexp);
                                             rest =
                                               (Field
                                                  {
                                                    name = "requires";
                                                    kind = Required;
                                                    conv =
                                                      (list_of_sexp
                                                         (with_loc_of_sexp
                                                            string_of_sexp));
                                                    rest =
                                                      (Field
                                                         {
                                                           name = "libs";
                                                           kind = Required;
                                                           conv =
                                                             (list_of_sexp
                                                                (with_loc_of_sexp
                                                                   lib_of_sexp));
                                                           rest = Empty
                                                         })
                                                  })
                                           })
                                    })
                             })
                      })
           ~index_of_field:(function
                            | "ml_path" -> 0
                            | "mli_path" -> 1
                            | "ml_stat" -> 2
                            | "mli_stat" -> 3
                            | "requires" -> 4
                            | "libs" -> 5
                            | _ -> (-1)) ~allow_extra_fields:false
           ~create:(fun
                      (ml_path,
                       (mli_path,
                        (ml_stat, (mli_stat, (requires, (libs, ()))))))
                      ->
                      ({ ml_path; mli_path; ml_stat; mli_stat; requires; libs
                       } : entry)) x__019_ : Sexplib0.Sexp.t -> entry)
    let _ = entry_of_sexp
    let sexp_of_entry =
      (fun
         { ml_path = ml_path__021_; mli_path = mli_path__023_;
           ml_stat = ml_stat__025_; mli_stat = mli_stat__027_;
           requires = requires__029_; libs = libs__031_ }
         ->
         let bnds__020_ = ([] : _ Stdlib.List.t) in
         let bnds__020_ =
           let arg__032_ =
             sexp_of_list (sexp_of_with_loc sexp_of_lib) libs__031_ in
           ((Sexplib0.Sexp.List [Sexplib0.Sexp.Atom "libs"; arg__032_]) ::
             bnds__020_ : _ Stdlib.List.t) in
         let bnds__020_ =
           let arg__030_ =
             sexp_of_list (sexp_of_with_loc sexp_of_string) requires__029_ in
           ((Sexplib0.Sexp.List [Sexplib0.Sexp.Atom "requires"; arg__030_])
             :: bnds__020_ : _ Stdlib.List.t) in
         let bnds__020_ =
           let arg__028_ = sexp_of_option sexp_of_file_stat mli_stat__027_ in
           ((Sexplib0.Sexp.List [Sexplib0.Sexp.Atom "mli_stat"; arg__028_])
             :: bnds__020_ : _ Stdlib.List.t) in
         let bnds__020_ =
           let arg__026_ = sexp_of_file_stat ml_stat__025_ in
           ((Sexplib0.Sexp.List [Sexplib0.Sexp.Atom "ml_stat"; arg__026_]) ::
             bnds__020_ : _ Stdlib.List.t) in
         let bnds__020_ =
           let arg__024_ = sexp_of_option sexp_of_string mli_path__023_ in
           ((Sexplib0.Sexp.List [Sexplib0.Sexp.Atom "mli_path"; arg__024_])
             :: bnds__020_ : _ Stdlib.List.t) in
         let bnds__020_ =
           let arg__022_ = sexp_of_string ml_path__021_ in
           ((Sexplib0.Sexp.List [Sexplib0.Sexp.Atom "ml_path"; arg__022_]) ::
             bnds__020_ : _ Stdlib.List.t) in
         Sexplib0.Sexp.List bnds__020_ : entry -> Sexplib0.Sexp.t)
    let _ = sexp_of_entry
  end[@@ocaml.doc "@inline"][@@merlin.hide ]
type header =
  {
  mach_executable_path: string ;
  ocaml_version: string ;
  ocamlfind_version: string option }[@@deriving sexp]
include
  struct
    let _ = fun (_ : header) -> ()
    let header_of_sexp =
      (let error_source__034_ = "lib/mach_state.ml.header" in
       fun x__035_ ->
         Sexplib0.Sexp_conv_record.record_of_sexp ~caller:error_source__034_
           ~fields:(Field
                      {
                        name = "mach_executable_path";
                        kind = Required;
                        conv = string_of_sexp;
                        rest =
                          (Field
                             {
                               name = "ocaml_version";
                               kind = Required;
                               conv = string_of_sexp;
                               rest =
                                 (Field
                                    {
                                      name = "ocamlfind_version";
                                      kind = Required;
                                      conv = (option_of_sexp string_of_sexp);
                                      rest = Empty
                                    })
                             })
                      })
           ~index_of_field:(function
                            | "mach_executable_path" -> 0
                            | "ocaml_version" -> 1
                            | "ocamlfind_version" -> 2
                            | _ -> (-1)) ~allow_extra_fields:false
           ~create:(fun
                      (mach_executable_path,
                       (ocaml_version, (ocamlfind_version, ())))
                      ->
                      ({
                         mach_executable_path;
                         ocaml_version;
                         ocamlfind_version
                       } : header)) x__035_ : Sexplib0.Sexp.t -> header)
    let _ = header_of_sexp
    let sexp_of_header =
      (fun
         { mach_executable_path = mach_executable_path__037_;
           ocaml_version = ocaml_version__039_;
           ocamlfind_version = ocamlfind_version__041_ }
         ->
         let bnds__036_ = ([] : _ Stdlib.List.t) in
         let bnds__036_ =
           let arg__042_ =
             sexp_of_option sexp_of_string ocamlfind_version__041_ in
           ((Sexplib0.Sexp.List
               [Sexplib0.Sexp.Atom "ocamlfind_version"; arg__042_])
             :: bnds__036_ : _ Stdlib.List.t) in
         let bnds__036_ =
           let arg__040_ = sexp_of_string ocaml_version__039_ in
           ((Sexplib0.Sexp.List
               [Sexplib0.Sexp.Atom "ocaml_version"; arg__040_])
             :: bnds__036_ : _ Stdlib.List.t) in
         let bnds__036_ =
           let arg__038_ = sexp_of_string mach_executable_path__037_ in
           ((Sexplib0.Sexp.List
               [Sexplib0.Sexp.Atom "mach_executable_path"; arg__038_])
             :: bnds__036_ : _ Stdlib.List.t) in
         Sexplib0.Sexp.List bnds__036_ : header -> Sexplib0.Sexp.t)
    let _ = sexp_of_header
  end[@@ocaml.doc "@inline"][@@merlin.hide ]
type t = {
  header: header ;
  root: entry ;
  entries: entry list }[@@deriving sexp]
include
  struct
    let _ = fun (_ : t) -> ()
    let t_of_sexp =
      (let error_source__044_ = "lib/mach_state.ml.t" in
       fun x__045_ ->
         Sexplib0.Sexp_conv_record.record_of_sexp ~caller:error_source__044_
           ~fields:(Field
                      {
                        name = "header";
                        kind = Required;
                        conv = header_of_sexp;
                        rest =
                          (Field
                             {
                               name = "root";
                               kind = Required;
                               conv = entry_of_sexp;
                               rest =
                                 (Field
                                    {
                                      name = "entries";
                                      kind = Required;
                                      conv = (list_of_sexp entry_of_sexp);
                                      rest = Empty
                                    })
                             })
                      })
           ~index_of_field:(function
                            | "header" -> 0
                            | "root" -> 1
                            | "entries" -> 2
                            | _ -> (-1)) ~allow_extra_fields:false
           ~create:(fun (header, (root, (entries, ()))) ->
                      ({ header; root; entries } : t)) x__045_ : Sexplib0.Sexp.t
                                                                   -> 
                                                                   t)
    let _ = t_of_sexp
    let sexp_of_t =
      (fun
         { header = header__047_; root = root__049_; entries = entries__051_
           }
         ->
         let bnds__046_ = ([] : _ Stdlib.List.t) in
         let bnds__046_ =
           let arg__052_ = sexp_of_list sexp_of_entry entries__051_ in
           ((Sexplib0.Sexp.List [Sexplib0.Sexp.Atom "entries"; arg__052_]) ::
             bnds__046_ : _ Stdlib.List.t) in
         let bnds__046_ =
           let arg__050_ = sexp_of_entry root__049_ in
           ((Sexplib0.Sexp.List [Sexplib0.Sexp.Atom "root"; arg__050_]) ::
             bnds__046_ : _ Stdlib.List.t) in
         let bnds__046_ =
           let arg__048_ = sexp_of_header header__047_ in
           ((Sexplib0.Sexp.List [Sexplib0.Sexp.Atom "header"; arg__048_]) ::
             bnds__046_ : _ Stdlib.List.t) in
         Sexplib0.Sexp.List bnds__046_ : t -> Sexplib0.Sexp.t)
    let _ = sexp_of_t
  end[@@ocaml.doc "@inline"][@@merlin.hide ]
let mli_path_of_ml_if_exists path =
  let base = Filename.remove_extension path in
  let mli = base ^ ".mli" in if Sys.file_exists mli then Some mli else None
let file_stat path =
  let st = Unix.stat path in
  { mtime = (Int.of_float st.Unix.st_mtime); size = (st.Unix.st_size) }
let exe_path config t =
  Filename.concat (Mach_config.build_dir_of config (t.root).ml_path) "a.out"
let source_dirs state =
  let seen = Hashtbl.create 16 in
  let add_dir path = Hashtbl.replace seen (Filename.dirname path) () in
  List.iter (fun entry -> add_dir entry.ml_path) state.entries;
  (Hashtbl.fold (fun dir () acc -> dir :: acc) seen []) |>
    (List.sort String.compare)
let all_libs state =
  let seen = Hashtbl.create 16 in
  List.iter
    (fun e ->
       List.iter
         (fun (l : lib with_loc) -> Hashtbl.replace seen (l.v).name ())
         e.libs) state.entries;
  (Hashtbl.fold (fun l () acc -> l :: acc) seen []) |>
    (List.sort String.compare)
let read path =
  if not (Sys.file_exists path)
  then None
  else
    (try
       let content = In_channel.with_open_text path In_channel.input_all in
       let sexp = Parsexp.Single.parse_string_exn content in
       Some (t_of_sexp sexp)
     with | _ -> None)
let write path state =
  let sexp = sexp_of_t state in
  Out_channel.with_open_text path
    (fun oc ->
       output_string oc (Sexplib0.Sexp.to_string_hum sexp);
       output_char oc '\n')
type reconfigure_reason =
  | Env_changed 
  | Modules_changed of SS.t 
let check_reconfigure_exn config state =
  let mach_path = config.Mach_config.mach_executable_path in
  let toolchain = config.Mach_config.toolchain in
  let env_changed =
    ((state.header).mach_executable_path <> mach_path) ||
      (((state.header).ocaml_version <> toolchain.ocaml_version) ||
         (((state.header).ocamlfind_version <> None) &&
            ((state.header).ocamlfind_version <>
               (Lazy.force toolchain.ocamlfind).ocamlfind_version))) in
  if env_changed
  then
    (Mach_log.log_very_verbose
       "mach:state: environment changed, need reconfigure";
     Some Env_changed)
  else
    (let changed_modules =
       SS.of_list @@
         (List.filter_map
            (fun entry ->
               if not (Sys.file_exists entry.ml_path)
               then None
               else
                 if
                   (mli_path_of_ml_if_exists entry.ml_path) <> entry.mli_path
                 then
                   (Mach_log.log_very_verbose
                      "mach:state: .mli added/removed, need reconfigure";
                    Some (entry.ml_path))
                 else
                   if
                     not
                       (equal_file_stat (file_stat entry.ml_path)
                          entry.ml_stat)
                   then
                     (let (requires, libs) =
                        Mach_module.extract_requires_exn entry.ml_path in
                      let libs_names_equal =
                        ((List.length libs) = (List.length entry.libs)) &&
                          (List.for_all2
                             (fun a b ->
                                (a.v = (b.v).name) &&
                                  ((a.filename = b.filename) &&
                                     (a.line = b.line))) libs entry.libs) in
                      if
                        (not
                           (List.equal equal_without_loc requires
                              entry.requires))
                          || (not libs_names_equal)
                      then
                        (Mach_log.log_very_verbose
                           "mach:state: requires/libs changed, need reconfigure";
                         Some (entry.ml_path))
                      else None)
                   else None) state.entries) in
     if SS.is_empty changed_modules
     then None
     else Some (Modules_changed changed_modules))
let collect_exn config entry_path =
  let mach_executable_path = config.Mach_config.mach_executable_path in
  let toolchain = config.Mach_config.toolchain in
  let entry_path = Unix.realpath entry_path in
  let visited = Hashtbl.create 16 in
  let entries = ref [] in
  let rec dfs ml_path =
    if Hashtbl.mem visited ml_path
    then ()
    else
      (Hashtbl.add visited ml_path ();
       (let (requires, libs) = Mach_module.extract_requires_exn ml_path in
        let libs =
          List.map
            (fun lib ->
               let info = Lazy.force toolchain.ocamlfind in
               if info.ocamlfind_version = None
               then
                 Mach_error.user_errorf
                   "%s:%d: library %S requires ocamlfind but ocamlfind is not installed"
                   lib.filename lib.line lib.v
               else
                 (match SM.find_opt lib.v info.ocamlfind_libs with
                  | None ->
                      Mach_error.user_errorf "%s:%d: library %S not found"
                        lib.filename lib.line lib.v
                  | Some version ->
                      { lib with v = { name = (lib.v); version } })) libs in
        List.iter (fun r -> dfs r.v) requires;
        (let mli_path = mli_path_of_ml_if_exists ml_path in
         let mli_stat = Option.map file_stat mli_path in
         entries :=
           ({
              ml_path;
              mli_path;
              ml_stat = (file_stat ml_path);
              mli_stat;
              requires;
              libs
            }
           :: (!entries))))) in
  dfs entry_path;
  (let ocamlfind_version =
     if Lazy.is_val toolchain.ocamlfind
     then (Lazy.force toolchain.ocamlfind).ocamlfind_version
     else None in
   let header =
     {
       mach_executable_path;
       ocaml_version = (toolchain.ocaml_version);
       ocamlfind_version
     } in
   match !entries with
   | [] -> failwith "Internal error: no entries collected"
   | root::_ as entries -> { header; root; entries = (List.rev entries) })
let collect config entry_path =
  try Ok (collect_exn config entry_path)
  with | Mach_error.Mach_user_error msg -> Error (`User_error msg)
end
module Mach_lib : sig
[@@@ocaml.ppx.context
  {
    tool_name = "ppx_driver";
    include_dirs = [];
    hidden_include_dirs = [];
    load_path = ([], []);
    open_modules = [];
    for_package = None;
    debug = false;
    use_threads = false;
    use_vmthreads = false;
    recursive_types = false;
    principal = false;
    no_alias_deps = false;
    unboxed_types = false;
    unsafe_string = false;
    cookies = [("library-name", "mach_lib")]
  }]
type verbose = Mach_log.verbose =
  | Quiet 
  | Verbose 
  | Very_verbose 
  | Very_very_verbose 
val pp : string -> unit
val configure :
  Mach_config.t -> string -> ((Mach_state.t * bool), Mach_error.t) result
val build :
  Mach_config.t -> string -> ((Mach_state.t * bool), Mach_error.t) result
end = struct
[@@@ocaml.ppx.context
  {
    tool_name = "ppx_driver";
    include_dirs = [];
    hidden_include_dirs = [];
    load_path = ([], []);
    open_modules = [];
    for_package = None;
    debug = false;
    use_threads = false;
    use_vmthreads = false;
    recursive_types = false;
    principal = false;
    no_alias_deps = false;
    unboxed_types = false;
    unsafe_string = false;
    cookies = [("library-name", "mach_lib")]
  }]
open! Mach_std
open Printf
type verbose = Mach_log.verbose =
  | Quiet 
  | Verbose 
  | Very_verbose 
  | Very_very_verbose 
let log_verbose = Mach_log.log_verbose
let log_very_verbose = Mach_log.log_very_verbose
let module_name_of_path path =
  let open Filename in (basename path) |> remove_extension
type module_kind =
  | ML 
  | MLX 
let module_kind_of_path path =
  if (Filename.extension path) = ".mlx" then MLX else ML
let src_ext_of_kind = function | ML -> ".ml" | MLX -> ".mlx"
let pp source_path =
  In_channel.with_open_text source_path
    (fun ic -> Mach_module.preprocess_source ~source_path stdout ic);
  flush stdout
type ocaml_module =
  {
  ml_path: string ;
  mli_path: string option ;
  cmx: string ;
  cmi: string ;
  cmt: string ;
  module_name: string ;
  build_dir: string ;
  resolved_requires: string with_loc list ;
  libs: Mach_state.lib with_loc list ;
  kind: module_kind }
let configure_backend config ~state ~prev_state ~changed_modules =
  let build_dir_of = Mach_config.build_dir_of config in
  let module_file = "mach.ninja" in
  let root_file = "build.ninja" in
  let cmd = (state.Mach_state.header).mach_executable_path in
  let capture_outf fmt =
    ksprintf (sprintf "${MACH} run-build-command -- %s") fmt in
  let capture_stderrf fmt =
    ksprintf (sprintf "${MACH} run-build-command --stderr-only -- %s") fmt in
  let configure_ocaml_module b (m : ocaml_module) =
    let src_ext = src_ext_of_kind m.kind in
    let src = let open Filename in (m.build_dir / m.module_name) ^ src_ext in
    let mli = let open Filename in (m.build_dir / m.module_name) ^ ".mli" in
    Ninja.rulef b ~target:src ~deps:[m.ml_path] "%s pp %s > %s" cmd m.ml_path
      src;
    Option.iter
      (fun mli_path ->
         Ninja.rulef b ~target:mli ~deps:[mli_path] "%s pp %s > %s" cmd
           mli_path mli) m.mli_path;
    (let args = let open Filename in m.build_dir / "includes.args" in
     let recipe =
       match m.resolved_requires with
       | [] -> [sprintf "touch %s" args]
       | requires ->
           List.map
             (fun (r : _ with_loc) ->
                sprintf "echo '-I=%s' >> %s" (build_dir_of r.v) args)
             requires in
     Ninja.rule b ~target:args ~deps:[src] ((sprintf "rm -f %s" args) ::
       recipe);
     (match m.libs with
      | [] -> ()
      | libs ->
          let lib_args =
            let open Filename in m.build_dir / "lib_includes.args" in
          let libs =
            String.concat " "
              (List.map (fun (l : Mach_state.lib with_loc) -> (l.v).name)
                 libs) in
          Ninja.rule b ~target:lib_args ~deps:[]
            [capture_stderrf
               "ocamlfind query -format '-I=%%d' -recursive %s > %s" libs
               lib_args])) in
  let compile_ocaml_module b (m : ocaml_module) =
    let src_ext = src_ext_of_kind m.kind in
    let src = let open Filename in (m.build_dir / m.module_name) ^ src_ext in
    let mli = let open Filename in (m.build_dir / m.module_name) ^ ".mli" in
    let args = let open Filename in m.build_dir / "includes.args" in
    let pp_flag = match m.kind with | ML -> "" | MLX -> " -pp mlx-pp" in
    let cmi_deps =
      List.map
        (fun (r : _ with_loc) ->
           let open Filename in
             ((build_dir_of r.v) / (module_name_of_path r.v)) ^ ".cmi")
        m.resolved_requires in
    let (lib_args_dep, lib_args_cmd) =
      match m.libs with
      | [] -> ([], "")
      | _ ->
          ([(let open Filename in m.build_dir / "lib_includes.args")],
            (sprintf " -args %s"
               (let open Filename in m.build_dir / "lib_includes.args"))) in
    match m.mli_path with
    | Some _ ->
        (Ninja.rule b ~target:(m.cmi)
           ~deps:((mli :: args :: lib_args_dep) @ cmi_deps)
           [capture_outf "ocamlc%s -bin-annot -c -opaque -args %s%s -o %s %s"
              pp_flag args lib_args_cmd m.cmi mli];
         Ninja.rule b ~target:(m.cmx)
           ~deps:([src; m.cmi; args] @ lib_args_dep)
           [capture_outf
              "ocamlopt%s -bin-annot -c -args %s%s -cmi-file %s -o %s -impl %s"
              pp_flag args lib_args_cmd m.cmi m.cmx src];
         Ninja.rule b ~target:(m.cmt) ~deps:[m.cmx] [])
    | None ->
        (Ninja.rule b ~target:(m.cmx)
           ~deps:((src :: args :: lib_args_dep) @ cmi_deps)
           [capture_outf "ocamlopt%s -bin-annot -c -args %s%s -o %s -impl %s"
              pp_flag args lib_args_cmd m.cmx src];
         Ninja.rule b ~target:(m.cmi) ~deps:[m.cmx] [];
         Ninja.rule b ~target:(m.cmt) ~deps:[m.cmx] []) in
  let link_ocaml_module b (all_objs : string list) (all_libs : string list)
    ~exe_path =
    let root_build_dir = Filename.dirname exe_path in
    let args = let open Filename in root_build_dir / "all_objects.args" in
    let objs_str = String.concat " " all_objs in
    Ninja.rulef b ~target:args ~deps:all_objs "printf '%%s\\n' %s > %s"
      objs_str args;
    (match all_libs with
     | [] ->
         Ninja.rule b ~target:exe_path ~deps:(args :: all_objs)
           [capture_outf "ocamlopt -o %s -args %s" exe_path args]
     | libs ->
         let lib_args =
           let open Filename in root_build_dir / "lib_objects.args" in
         let libs = String.concat " " libs in
         (Ninja.rule b ~target:lib_args ~deps:[]
            [capture_stderrf
               "ocamlfind query -a-format -recursive -predicates native %s > %s"
               libs lib_args];
          Ninja.rule b ~target:exe_path ~deps:(args :: lib_args :: all_objs)
            [capture_outf "ocamlopt -o %s -args %s -args %s" exe_path
               lib_args args])) in
  let modules =
    List.map
      (fun
         ({ ml_path; mli_path; requires = resolved_requires; libs;_} :
           Mach_state.entry)
         ->
         let module_name = module_name_of_path ml_path in
         let build_dir = build_dir_of ml_path in
         let kind = module_kind_of_path ml_path in
         let cmx = let open Filename in (build_dir / module_name) ^ ".cmx" in
         let cmi = let open Filename in (build_dir / module_name) ^ ".cmi" in
         let cmt = let open Filename in (build_dir / module_name) ^ ".cmt" in
         {
           ml_path;
           mli_path;
           module_name;
           build_dir;
           resolved_requires;
           cmx;
           cmi;
           cmt;
           libs;
           kind
         }) state.Mach_state.entries in
  let old_modules =
    match prev_state with
    | None -> SS.empty
    | Some old ->
        SS.of_list
          (List.map (fun e -> e.Mach_state.ml_path) old.Mach_state.entries) in
  List.iter
    (fun (m : ocaml_module) ->
       let needs_configure =
         match changed_modules with
         | None -> true
         | Some changed_modules ->
             (SS.mem m.ml_path changed_modules) ||
               (not (SS.mem m.ml_path old_modules)) in
       if needs_configure
       then
         (log_verbose "mach: configuring %s" m.ml_path;
          mkdir_p m.build_dir;
          (let file_path = let open Filename in m.build_dir / module_file in
           write_file file_path
             (let b = Ninja.create () in
              configure_ocaml_module b m;
              compile_ocaml_module b m;
              Ninja.contents b)))) modules;
  (let exe_path = Mach_state.exe_path config state in
   let all_objs = List.map (fun m -> m.cmx) modules in
   let all_libs = Mach_state.all_libs state in
   write_file
     (let open Filename in (build_dir_of (state.root).ml_path) / root_file)
     (log_verbose "mach: configuring %s (root)" (state.root).ml_path;
      (let b = Ninja.create () in
       Ninja.var b "MACH" cmd;
       List.iter
         (fun entry ->
            Ninja.subninja b
              (let open Filename in
                 (build_dir_of entry.Mach_state.ml_path) / module_file))
         state.entries;
       Ninja.rule_phony b ~target:"all" ~deps:[exe_path];
       link_ocaml_module b all_objs all_libs ~exe_path;
       Ninja.contents b)))
let configure_exn config source_path =
  let build_dir_of = Mach_config.build_dir_of config in
  let source_path = Unix.realpath source_path in
  let build_dir = build_dir_of source_path in
  let state_path = let open Filename in build_dir / "Mach.state" in
  let (prev_state, state, reconfigure_reason) =
    match Mach_state.read state_path with
    | None ->
        (log_very_verbose
           "mach:configure: no previous state found, creating one...";
         (let state = Mach_state.collect_exn config source_path in
          (None, state, (Some Mach_state.Env_changed))))
    | Some state as prev_state ->
        (match Mach_state.check_reconfigure_exn config state with
         | None -> (prev_state, state, None)
         | Some reason ->
             (log_very_verbose "mach:configure: need reconfigure";
              (let state = Mach_state.collect_exn config source_path in
               (prev_state, state, (Some reason))))) in
  (match reconfigure_reason with
   | None -> ()
   | Some reconfigure_reason ->
       (log_verbose "mach: configuring...";
        (let changed_modules =
           match reconfigure_reason with
           | Mach_state.Env_changed -> None
           | Mach_state.Modules_changed set -> Some set in
         (match reconfigure_reason with
          | Env_changed ->
              List.iter
                (fun entry -> rm_rf (build_dir_of entry.Mach_state.ml_path))
                state.entries
          | Modules_changed _ -> ());
         mkdir_p build_dir;
         configure_backend config ~state ~prev_state ~changed_modules;
         (let cmd =
            sprintf "ninja -C %s -t cleandead > /dev/null"
              (Filename.quote (build_dir_of (state.root).ml_path)) in
          if (!Mach_log.verbose) = Very_very_verbose
          then eprintf "+ %s\n%!" cmd;
          if (Sys.command cmd) <> 0
          then Mach_error.user_errorf "ninja cleandead failed";
          Mach_state.write state_path state))));
  (state, (Option.is_some reconfigure_reason))
let configure config source_path =
  try Ok (configure_exn config source_path)
  with | Mach_error.Mach_user_error msg -> Error (`User_error msg)
let run_build cmd =
  let open Unix in
    let cmd = sprintf "%s 2>&1" cmd in
    let ic = open_process_in cmd in
    (try
       while true do
         let line = input_line ic in
         if ((String.length line) >= 3) && ((String.sub line 0 3) = ">>>")
         then prerr_endline (String.sub line 3 ((String.length line) - 3))
         done
     with | End_of_file -> ());
    (match close_process_in ic with
     | WEXITED code -> code
     | WSIGNALED _ | WSTOPPED _ -> 1)
let build_exn config script_path =
  let build_dir_of = Mach_config.build_dir_of config in
  let (state, reconfigured) = configure_exn config script_path in
  log_verbose "mach: building...";
  (let cmd =
     if (!Mach_log.verbose) = Very_very_verbose
     then "ninja -v"
     else "ninja --quiet" in
   let cmd =
     sprintf "%s -C %s" cmd
       (Filename.quote (build_dir_of (state.root).ml_path)) in
   if (!Mach_log.verbose) = Very_very_verbose then eprintf "+ %s\n%!" cmd;
   if (run_build cmd) <> 0 then Mach_error.user_errorf "build failed";
   (state, reconfigured))
let build config script_path =
  try Ok (build_exn config script_path)
  with | Mach_error.Mach_user_error msg -> Error (`User_error msg)
end
include Mach_lib
(* THIS FILE WAS AUTOMATICALLY GENERATED BY CAT'ING LIBRARY SOURCES *)
[@@@ocaml.warning "-27-32-35"]
module Cmdliner_trie : sig
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

(** Tries.

    This implementation also maps any non ambiguous prefix of a
    key to its value. *)

type 'a t

val empty : 'a t
val is_empty : 'a t -> bool
val add : 'a t -> string -> 'a -> [ `New of 'a t | `Replaced of 'a * 'a t ]
val find :
  legacy_prefixes:bool -> 'a t -> string ->
  ('a, [`Ambiguous | `Not_found ]) result
val ambiguities : 'a t -> string -> string list
val of_list : (string * 'a) list -> 'a t

val legacy_prefixes : env:(string -> string option) -> bool
end = struct
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

module Cmap = Map.Make (Char) (* character maps. *)

type 'a value = (* type for holding a bound value. *)
| Pre of 'a (* value is bound by the prefix of a key. *)
| Key of 'a (* value is bound by an entire key. *)
| Amb (* no value bound because of ambiguous prefix. *)
| Nil (* not bound (only for the empty trie). *)

type 'a t = { v : 'a value; succs : 'a t Cmap.t }
let empty = { v = Nil; succs = Cmap.empty }
let is_empty t = t = empty

(* N.B. If we replace a non-ambiguous key, it becomes ambiguous but it's
   not important for our use. Also the following is not tail recursive but
   the stack is bounded by key length. *)
let add t k d =
  let rec loop t k len i d pre_d = match i = len with
  | true ->
      let t' = { v = Key d; succs = t.succs } in
      begin match t.v with
      | Key old -> `Replaced (old, t')
      | _ -> `New t'
      end
  | false ->
      let v = match t.v with
      | Amb | Pre _ -> Amb | Key _ as v -> v | Nil -> pre_d
      in
      let t' = try Cmap.find k.[i] t.succs with Not_found -> empty in
      match loop t' k len (i + 1) d pre_d with
      | `New n -> `New { v; succs = Cmap.add k.[i] n t.succs }
      | `Replaced (o, n) ->
          `Replaced (o, { v; succs = Cmap.add k.[i] n t.succs })
  in
  loop t k (String.length k) 0 d (Pre d (* allocate less *))

let find_node t k =
  let rec aux t k len i =
    if i = len then t else
    aux (Cmap.find k.[i] t.succs) k len (i + 1)
  in
  aux t k (String.length k) 0

let find ~legacy_prefixes t k = match (find_node t k).v with
| Key v -> Ok v
| Pre v when legacy_prefixes -> Ok v
| Pre v -> Error `Not_found
| Amb when legacy_prefixes -> Error `Ambiguous
| Amb -> Error `Not_found
| Nil -> Error `Not_found
| exception Not_found -> Error `Not_found

let ambiguities t p =                        (* ambiguities of [p] in [t]. *)
  try
    let t = find_node t p in
    match t.v with
    | Key _ | Pre _ | Nil -> []
    | Amb ->
        let add_char s c = s ^ (String.make 1 c) in
        let rem_char s = String.sub s 0 ((String.length s) - 1) in
        let to_list m = Cmap.fold (fun k t acc -> (k,t) :: acc) m [] in
        let rec aux acc p = function
        | ((c, t) :: succs) :: rest ->
            let p' = add_char p c in
            let acc' = match t.v with
            | Pre _ | Amb -> acc
            | Key _ -> (p' :: acc)
            | Nil -> assert false
            in
            aux acc' p' ((to_list t.succs) :: succs :: rest)
        | [] :: [] -> acc
        | [] :: rest -> aux acc (rem_char p) rest
        | [] -> assert false
        in
        aux [] p (to_list t.succs :: [])
  with Not_found -> []

let of_list l =
  let add t (s, v) = match add t s v with `New t -> t | `Replaced (_, t) -> t in
  List.fold_left add empty l

let legacy_prefixes ~env = match env "CMDLINER_LEGACY_PREFIXES" with
| None -> false
| Some s ->
    match String.lowercase_ascii s with
    | "true" | "yes" | "y" | "1" -> true
    | _ -> false
end
module Cmdliner_base : sig
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

(** A few helpful base definitions. *)

val uid : unit -> int
(** [uid ()] is new unique for the program run. *)

val suggest : string -> string list -> string list
(** [suggest near candidates]  suggest values from [candidates]
    not too far from [near]. *)

val is_space : char -> bool
val string_starts_with : prefix:string -> string -> bool
val string_drop_first : int -> string -> string

(* Formatters *)

module Fmt : sig
  type 'a t = Format.formatter -> 'a -> unit
  val str : ('a, Format.formatter, unit, string) format4 -> 'a
  val pf : Format.formatter -> ('a, Format.formatter, unit) format -> 'a
  val nop : 'a t
  val sp : unit t
  val comma : unit t
  val cut : unit t
  val char : char t
  val string : string t
  val indent : int t
  val list : ?sep:unit t -> 'a t -> 'a list t
  val styled_text : string t
  val lines : string t
  val tokens : spaces:bool -> string t
  val text : string t
  val code : string t
  val code_var : string t
  val code_or_quote : string t
  val ereason : string t
  val missing : unit t
  val invalid : unit t
  val deprecated : unit t
  val puterr : unit t

  type styler = Ansi | Plain
  val styler : unit -> styler
end

(* Error message helpers *)

val quote : string -> string
val pp_alts : string list Fmt.t
val alts_str : ?quoted:bool -> string list -> string
val err_empty_list : string
val err_ambiguous : kind:string -> string -> ambs:string list -> string
val err_unknown :
  ?dom:string list -> ?hints:string list -> kind:string -> string -> string
val err_multi_def :
  kind:string -> string -> ('b -> string) -> 'b -> 'b -> string
end = struct
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

let strf = Printf.sprintf

(* Unique ids *)

let uid =
  (* Thread-safe UIDs, Oo.id (object end) was used before.
     Note this won't be thread-safe in multicore, we should use
     Atomic but this is >= 4.12 and we have 4.08 for now. *)
  let c = ref 0 in
  fun () ->
    let id = !c in
    incr c; if id > !c then assert false (* too many ids *) else id

(* Edit distance

   The stdlib has much better in but this will be only >= 5.4, maybe
   in twenty years. *)

let edit_distance s0 s1 =
  let minimum (a : int) (b : int) (c : int) : int = min a (min b c) in
  let s0,s1 = if String.length s0 <= String.length s1 then s0,s1 else s1,s0 in
  let m = String.length s0 and n = String.length s1 in
  let rec rows row0 row i = match i > n with
  | true -> row0.(m)
  | false ->
      row.(0) <- i;
      for j = 1 to m do
        if s0.[j - 1] = s1.[i - 1] then row.(j) <- row0.(j - 1) else
        row.(j) <- minimum (row0.(j - 1) + 1) (row0.(j) + 1) (row.(j - 1) + 1)
      done;
      rows row row0 (i + 1)
  in
  rows (Array.init (m + 1) (fun x -> x)) (Array.make (m + 1) 0) 1

let suggest s candidates =
  let add (min, acc) name =
    let d = edit_distance s name in
    if d = min then min, (name :: acc) else
    if d < min then d, [name] else
    min, acc
  in
  let dist, suggs = List.fold_left add (max_int, []) candidates in
  if dist < 3 (* suggest only if not too far *) then suggs else []

(* Stdlib compatibility *)

let is_space = function ' ' | '\n' | '\r' | '\t' -> true | _ -> false

let string_starts_with ~prefix s = (* available in 4.13 *)
  let prefix_len = String.length prefix in
  let s_len = String.length s in
  if prefix_len > s_len then false else
  let rec loop i =
    if i = prefix_len then true
    else if String.get prefix i = String.get s i then loop (i + 1)
    else false
  in
  loop 0

let string_drop_first n s =
  if n <= 0 then s else
  if n >= String.length s then "" else
  String.sub s n (String.length s - n)

(* Invalid argument strings *)

let err_empty_list = "empty list"

(* Formatting tools *)

module Fmt = struct
  type 'a t = Format.formatter -> 'a -> unit
  let str = Format.asprintf
  let pf = Format.fprintf
  let nop ppf _ = ()
  let sp = Format.pp_print_space
  let cut = Format.pp_print_cut
  let string = Format.pp_print_string
  let char = Format.pp_print_char
  let comma ppf () = char ppf ','; sp ppf ()
  let indent ppf c = for i = 1 to c do char ppf ' ' done
  let list ?sep pp_v ppf l = Format.pp_print_list ?pp_sep:sep pp_v ppf l
  let text = Format.pp_print_text
  let lines ppf s =
    let rec stop_at sat ~start ~max s =
      if start > max then start else
      if sat s.[start] then start else
      stop_at sat ~start:(start + 1) ~max s
    in
    let sub s start stop ~max =
      if start = stop then "" else
      if start = 0 && stop > max then s else
      String.sub s start (stop - start)
    in
    let is_nl c = c = '\n' in
    let max = String.length s - 1 in
    let rec loop start s = match stop_at is_nl ~start ~max s with
    | stop when stop > max -> Format.pp_print_string ppf (sub s start stop ~max)
    | stop ->
        Format.pp_print_string ppf (sub s start stop ~max);
        Format.pp_force_newline ppf ();
        loop (stop + 1) s
    in
    loop 0 s

  let tokens ~spaces ppf s = (* collapse white and hint spaces (maybe) *)
    let i_max = String.length s - 1 in
    let flush start stop = string ppf (String.sub s start (stop - start + 1)) in
    let rec skip_white i =
      if i > i_max then i else
      if is_space s.[i] then skip_white (i + 1) else i
    in
    let rec loop start i =
      if i > i_max then flush start i_max else
      if not (is_space s.[i]) then loop start (i + 1) else
      let next_start = skip_white i in
      (flush start (i - 1); if spaces then sp ppf () else char ppf ' ';
       if next_start > i_max then () else loop next_start next_start)
    in
    loop 0 0

  (* Text styling *)

  type styler = Ansi | Plain
  let styler' =
    ref begin match Sys.getenv_opt "NO_COLOR" with
    | Some s when s <> "" -> Plain
    | _ ->
        match Sys.getenv_opt "TERM" with
        | Some "dumb" -> Plain
        | None when Sys.backend_type <> Other "js_of_ocaml" -> Plain
        | _ -> Ansi
    end

  let set_styler styler = styler' := styler
  let styler () = !styler'

  let sgr_of_style = function
  | `Bold -> "01"
  | `Underline -> "04"
  | `Fg `Red -> string_of_int (30 + 1)
  | `Fg `Yellow -> string_of_int (30 + 3)

  let sgrs_of_styles styles = String.concat ";" (List.map sgr_of_style styles)
  let ansi_esc = "\x1B["
  let sgr_reset = "\x1B[m"

  let ansi styles ppf s =
    let sgrs = String.concat "" [ansi_esc; sgrs_of_styles styles; "m"] in
    Format.pp_print_as ppf 0 sgrs;
    string ppf s;
    Format.pp_print_as ppf 0 sgr_reset

  let st styles ppf s = match !styler' with
  | Plain -> string ppf s
  | Ansi -> ansi styles ppf s

  let code ppf v = st [`Bold] ppf v
  let code_var ppf v = st [`Underline] ppf v
  let code_or_quote ppf v = match !styler' with
  | Plain -> char ppf '\''; string ppf v; char ppf '\''
  | Ansi -> ansi [`Bold] ppf v

  let ereason ppf s = match !styler' with
  | Plain -> string ppf s
  | Ansi -> ansi [`Fg `Red] ppf s

  let wreason ppf s = match !styler' with
  | Plain -> string ppf s
  | Ansi -> ansi [`Fg `Yellow] ppf s

  let missing ppf () = ereason ppf "missing"
  let invalid ppf () = ereason ppf "invalid"
  let unknown ppf () = ereason ppf "unknown"
  let deprecated ppf () = wreason ppf "deprecated"

  let puterr ppf () = st [`Bold; `Fg `Red] ppf "Error"; char ppf ':'

  let styled_text ppf s =
    (* Detects ANSI escapes and prints them as 0 width. Collapses spaces
       and newlines to single space except for blank lines which are
       preserved. *)
    let rec loop ppf s i max =
      if i > max then () else
      let ansi = s.[i] = '\x1B' && i + 1 < max && s.[i+1] = '[' in
      if not ansi then match s.[i] with
      | ' ' when i = max || s.[i+1] = ' ' || s.[i+1] = '\n' ->
          loop ppf s (i + 1) max
      | ' ' -> sp ppf (); loop ppf s (i + 1) max
      | '\n' when i = max || s.[i+1] = ' ' -> loop ppf s (i + 1) max
      | '\n' when s.[i+1] = '\n' ->
          Format.pp_force_newline ppf ();
          if i > 0 && s.[i-1] <> '\n' then Format.pp_force_newline ppf ();
          loop ppf s (i + 1) max
      | '\n' -> sp ppf (); loop ppf s (i + 1) max
      | c -> char ppf s.[i]; loop ppf s (i + 1) max
      else begin
        let k = ref (i + 2) in
        while (!k <= max && s.[!k] <> 'm') do incr k done;
        let esc = String.sub s i (!k - i + 1) in
        Format.pp_print_as ppf 0 esc;
        loop ppf s (!k + 1) max
      end
    in
    loop ppf s 0 (String.length s - 1)
end

(* Converter (end-user) error messages *)

let err_multi_def ~kind name doc v v' = (* programming error *)
  strf "%s %s defined twice (doc strings are '%s' and '%s')"
    kind name (doc v) (doc v')

let quote s = strf "'%s'" s (* Exposed in the API do not change *)
let _alts_str ~styled ?quoted ppf alts =
  let quote = match quoted with
  | None -> fun ppf s -> Fmt.pf ppf "$(b,%s)" s
  | Some quoted ->
      if not quoted then Fmt.string else
      if styled then Fmt.code_or_quote else
      fun ppf s -> Fmt.pf ppf "'%s'" s
  in
  match alts with
  | [] -> invalid_arg err_empty_list
  | [a] -> quote ppf a
  | [a; b] -> Fmt.pf ppf "either@ %a@ or@ %a" quote a quote b
  | alts ->
      let rev_alts = List.rev alts in
      Fmt.pf ppf "one@ of@ %a@ or@ %a"
        Fmt.(list ~sep:comma quote) (List.rev (List.tl rev_alts))
        quote (List.hd rev_alts)

let alts_str ?quoted alts = (* Exposed in the API do not change *)
  Fmt.str "@[%a@]" (_alts_str ~styled:false ?quoted) alts

let pp_alts ppf alts =
  _alts_str ~styled:true ~quoted:true ppf alts

let err_ambiguous ~kind s ~ambs =
  Fmt.str "@[%s %a %a@ and@ could@ be@ %a@]"
    kind Fmt.code_or_quote s Fmt.ereason "ambiguous" pp_alts ambs

let err_unknown ?(dom = []) ?(hints = []) ~kind v =
  let hints ppf () = match hints, dom with
  | [], [] -> ()
  | [], dom -> Fmt.pf ppf ". Must@ be@ %a" pp_alts dom
  | hints, _ -> Fmt.pf ppf ". Did@ you@ mean@ %a?" pp_alts hints
  in
  Fmt.str "@[%a %s@ %a%a@]" Fmt.unknown () kind Fmt.code_or_quote v hints ()
end
module Cmdliner_manpage : sig
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

(** Manpages.

    See {!Cmdliner.Manpage}. *)

type section_name = string

type block =
  [ `S of section_name | `P of string | `Pre of string | `I of string * string
  | `Noblank | `Blocks of block list ]

val escape : string -> string
(** [escape s] escapes [s] from the doc language. *)

type title = string * int * string * string * string

type t = title * block list

type xref =
  [ `Main | `Cmd of string | `Tool of string | `Page of string * int ]

(** {1 Standard section names} *)

val s_name : section_name
val s_synopsis : section_name
val s_description : section_name
val s_commands : section_name
val s_arguments : section_name
val s_options : section_name
val s_common_options : section_name
val s_exit_status : section_name
val s_environment : section_name
val s_files : section_name
val s_bugs : section_name
val s_examples : section_name
val s_authors : section_name
val s_see_also : section_name
val s_none : section_name

(** {1 Section maps}

    Used for handling the merging of metadata doc strings. *)

type smap
val smap_of_blocks : block list -> smap
val smap_to_blocks : smap -> block list
val smap_has_section : smap -> sec:section_name -> bool
val smap_append_block : smap -> sec:section_name -> block -> smap
(** [smap_append_block smap sec b] appends [b] at the end of section
    [sec] creating it at the right place if needed. *)

(** {1 Content boilerplate} *)

val s_exit_status_intro : block
val s_environment_intro : block

(** {1 Output} *)

type subst = string -> string option
(** The type for variable substitution functions. *)

type format = [ `Auto | `Pager | `Plain | `Groff ]
val print :
  ?env:(string -> string option) ->
  ?errs:Format.formatter -> ?subst:subst -> format ->
  Format.formatter -> t -> unit

(** {1 Printers and escapes used by Cmdliner module} *)

val subst_vars :
  errs:Format.formatter -> subst:subst -> Buffer.t -> string -> string
(** [subst b ~subst s], using [b], substitutes in [s] variables of the form
    "$(doc)" by their [subst] definition. This leaves escapes and markup
    directives $(markup,) intact.

    @raise Invalid_argument in case of illegal syntax. *)

val doc_to_plain :
  errs:Format.formatter -> subst:subst -> Buffer.t -> string -> string
(** [doc_to_plain b ~subst s] using [b], substitutes in [s] variables by
    their [subst] definition and renders cmdliner directives to plain
    text.

    Raises Invalid_argument in case of illegal syntax. *)

val doc_to_styled :
  ?buffer:Buffer.t -> errs:Format.formatter -> subst:subst -> string -> string
(** [doc_to_styled] is like {!doc_to_plain} but uses ANSI escapes. *)
end = struct
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

(* Manpages *)

type section_name = string

type block =
  [ `S of section_name | `P of string | `Pre of string | `I of string * string
  | `Noblank | `Blocks of block list ]

type title = string * int * string * string * string

type t = title * block list

type xref =
  [ `Main | `Cmd of string | `Tool of string | `Page of string * int ]

(* Standard sections *)

let s_name = "NAME"
let s_synopsis = "SYNOPSIS"
let s_description = "DESCRIPTION"
let s_commands = "COMMANDS"
let s_arguments = "ARGUMENTS"
let s_options = "OPTIONS"
let s_common_options = "COMMON OPTIONS"
let s_exit_status = "EXIT STATUS"
let s_exit_status_intro = `P "$(cmd) exits with:"

let s_environment = "ENVIRONMENT"
let s_environment_intro =
  `P "These environment variables affect the execution of $(cmd):"

let s_files = "FILES"
let s_examples = "EXAMPLES"
let s_bugs = "BUGS"
let s_authors = "AUTHORS"
let s_see_also = "SEE ALSO"
let s_none = "cmdliner-none"

(* Section order *)

let s_created = ""
let order =
  [| s_name; s_synopsis; s_description; s_created; s_commands;
     s_arguments; s_options; s_common_options; s_exit_status;
     s_environment; s_files; s_examples; s_bugs; s_authors; s_see_also;
     s_none; |]

let order_synopsis = 1
let order_created = 3

let section_of_order i = order.(i)
let section_to_order ~on_unknown s =
  let max = Array.length order - 1 in
  let rec loop i = match i > max with
  | true -> on_unknown
  | false -> if order.(i) = s then i else loop (i + 1)
  in
  loop 0

(* Section maps

   Section maps, maps section names to their section order and reversed
   content blocks (content is not reversed in `Block blocks). The sections
   are listed in reversed order. Unknown sections get the order of the last
   known section. *)

type smap = (string * (int * block list)) list

let smap_of_blocks bs = (* N.B. this flattens `Blocks, not t.r. *)
  let rec loop s s_o rbs smap = function
  | [] -> s, s_o, rbs, smap
  | `S new_sec :: bs ->
      let new_o = section_to_order ~on_unknown:s_o new_sec in
      loop new_sec new_o [] ((s, (s_o, rbs)):: smap) bs
  | `Blocks blist :: bs ->
      let s, s_o, rbs, rmap = loop s s_o rbs smap blist (* not t.r. *) in
      loop s s_o rbs rmap bs
  | (`P _ | `Pre _ | `I _ | `Noblank as c) :: bs ->
      loop s s_o (c :: rbs) smap bs
  in
  let first, (bs : block list) = match bs with
  | `S s :: bs -> s, bs
  | `Blocks (`S s :: blist) :: bs -> s, (`Blocks blist) :: bs
  | _ -> "", bs
  in
  let first_o = section_to_order ~on_unknown:order_synopsis first in
  let s, s_o, rc, smap = loop first first_o [] [] bs in
  (s, (s_o, rc)) :: smap

let smap_to_blocks smap = (* N.B. this leaves `Blocks content untouched. *)
  let rec loop acc smap s = function
  | b :: rbs -> loop (b :: acc) smap s rbs
  | [] ->
      let acc = if s = "" then acc else `S s :: acc in
      match smap with
      | [] -> acc
      | (_, (_, [])) :: smap -> loop acc smap "" [] (* skip empty section *)
      | (s, (_, rbs)) :: smap ->
          if s = s_none
          then loop acc smap "" [] (* skip *)
          else loop acc smap s rbs
  in
  loop [] smap "" []

let smap_has_section smap ~sec = List.exists (fun (s, _) -> sec = s) smap
let smap_append_block smap ~sec b =
  let o = section_to_order ~on_unknown:order_created sec in
  let try_insert =
    let rec loop max_lt_o left = function
    | (s', (o, rbs)) :: right when s' = sec ->
        Ok (List.rev_append ((sec, (o, b :: rbs)) :: left) right)
    | (_, (o', _) as s) :: right ->
        let max_lt_o = if o' < o then max o' max_lt_o else max_lt_o in
        loop max_lt_o (s :: left) right
    | [] ->
        if max_lt_o <> -1 then Error max_lt_o else
        Ok (List.rev ((sec, (o, [b])) :: left))
    in
    loop (-1) [] smap
  in
  match try_insert with
  | Ok smap -> smap
  | Error insert_before ->
      let rec loop left = function
      | (s', (o', _)) :: _ as right when o' = insert_before ->
          List.rev_append ((sec, (o, [b])) :: left) right
      | s :: ss -> loop (s :: left) ss
      | [] -> assert false
      in
      loop [] smap

(* Formatting tools *)

let strf = Printf.sprintf
module Fmt = Cmdliner_base.Fmt

(* Cmdliner markup handling *)

let err e fmt = Fmt.pf e ("cmdliner error: " ^^ fmt ^^ "@.")
let err_unescaped ~errs c s = err errs "unescaped %C in %S" c s
let err_malformed ~errs s = err errs "Malformed $() in %S" s
let err_unclosed ~errs s = err errs "Unclosed $() in %S" s
let err_undef ~errs id s = err errs "Undefined variable $(%s) in %S" id s
let err_illegal_esc ~errs c s = err errs "Illegal escape char %C in %S" c s
let err_markup ~errs dir s =
  err errs "Unknown cmdliner markup $(%c,) in %S" dir s

let is_markup_dir = function 'i' | 'b' -> true | _ -> false
let is_markup_esc = function '$' | '\\' | '(' | ')' -> true | _ -> false
let markup_need_esc = function '\\' | '$' -> true | _ -> false
let markup_text_need_esc = function '\\' | '$' | ')' -> true | _ -> false

let escape s = (* escapes [s] from doc language. *)
  let max_i = String.length s - 1 in
  let rec escaped_len i l =
    if i > max_i then l else
    if markup_text_need_esc s.[i] then escaped_len (i + 1) (l + 2) else
    escaped_len (i + 1) (l + 1)
  in
  let escaped_len = escaped_len 0 0 in
  if escaped_len = String.length s then s else
  let b = Bytes.create escaped_len in
  let rec loop i k =
    if i > max_i then Bytes.unsafe_to_string b else
    let c = String.unsafe_get s i in
    if not (markup_text_need_esc c)
    then (Bytes.unsafe_set b k c; loop (i + 1) (k + 1))
    else (Bytes.unsafe_set b k '\\'; Bytes.unsafe_set b (k + 1) c;
          loop (i + 1) (k + 2))
  in
  loop 0 0

let subst_vars ~errs ~subst b s =
  let max_i = String.length s - 1 in
  let flush start stop = match start > max_i with
  | true -> ()
  | false -> Buffer.add_substring b s start (stop - start + 1)
  in
  let skip_escape k start i =
    if i > max_i then err_unescaped ~errs '\\' s else k start (i + 1)
  in
  let rec skip_markup k start i =
    if i > max_i then (err_unclosed ~errs s; k start i) else
    match s.[i] with
    | '\\' -> skip_escape (skip_markup k) start (i + 1)
    | ')' -> k start (i + 1)
    | c -> skip_markup k start (i + 1)
  in
  let rec add_subst start i =
    if i > max_i then (err_unclosed ~errs s; loop start i) else
    if s.[i] <> ')' then add_subst start (i + 1) else
    let id = String.sub s start (i - start) in
    let next = i + 1 in
    begin match subst id with
    | None -> err_undef ~errs id s; Buffer.add_string b "undefined";
    | Some v -> Buffer.add_string b v
    end;
    loop next next
  and loop start i =
    if i > max_i then flush start max_i else
    let next = i + 1 in
    match s.[i] with
    | '\\' -> skip_escape loop start next
    | '$' ->
        if next > max_i then err_unescaped ~errs '$' s else
        begin match s.[next] with
        | '(' ->
            let min = next + 2 in
            if min > max_i then (err_unclosed ~errs s; loop start next) else
            begin match s.[min] with
            | ',' -> skip_markup loop start (min + 1)
            | _ ->
                let start_id = next + 1 in
                flush start (i - 1); add_subst start_id start_id
            end
        | _ -> err_unescaped ~errs '$' s; loop start next
        end;
    | c -> loop start next
  in
  (Buffer.clear b; loop 0 0; Buffer.contents b)

let add_markup_esc ~errs k b s start next target_need_escape target_escape =
  let max_i = String.length s - 1 in
  if next > max_i then err_unescaped ~errs '\\' s else
  match s.[next] with
  | c when not (is_markup_esc s.[next]) ->
      err_illegal_esc ~errs c s;
      k (next + 1) (next + 1)
  | c ->
      (if target_need_escape c then target_escape b c else Buffer.add_char b c);
      k (next + 1) (next + 1)

let add_markup_text ~errs k b s start target_need_escape target_escape =
  let max_i = String.length s - 1 in
  let flush start stop = match start > max_i with
  | true -> ()
  | false -> Buffer.add_substring b s start (stop - start + 1)
  in
  let rec loop start i =
    if i > max_i then (err_unclosed ~errs s; flush start max_i) else
    let next = i + 1 in
    match s.[i] with
    | '\\' -> (* unescape *)
        flush start (i - 1);
        add_markup_esc ~errs loop b s start next
          target_need_escape target_escape
    | ')' -> flush start (i - 1); k next next
    | c when markup_text_need_esc c ->
        err_unescaped ~errs c s; flush start (i - 1); loop next next
    | c when target_need_escape c ->
        flush start (i - 1); target_escape b c; loop next next
    | c -> loop start next
  in
  loop start start

(* Plain text output *)

let markup_to_plain ~styled ~errs b s =
  let max_i = String.length s - 1 in
  let flush start stop = match start > max_i with
  | true -> ()
  | false -> Buffer.add_substring b s start (stop - start + 1)
  in
  let need_escape _ = false in
  let escape _ _ = assert false in
  let rec end_text start i = Buffer.add_string b "\x1B[m"; loop start i
  and loop start i =
    if i > max_i then flush start max_i else
    let next = i + 1 in
    match s.[i] with
    | '\\' ->
        flush start (i - 1);
        add_markup_esc ~errs loop b s start next need_escape escape
    | '$' ->
        if next > max_i then err_unescaped ~errs '$' s else
        begin match s.[next] with
        | '(' ->
            let min = next + 2 in
            if min > max_i then (err_unclosed ~errs s; loop start next) else
            begin match s.[min] with
            | ',' ->
                let markup = s.[min - 1] in
                let start_data = min + 1 in
                if not (is_markup_dir markup)
                then (err_markup ~errs markup s; loop start next) else begin
                  flush start (i - 1);
                  if not styled then
                    add_markup_text ~errs loop b s start_data need_escape escape
                  else
                  begin
                    begin match markup with
                    | 'i' -> Buffer.add_string b "\x1B[04m";
                    | 'b' -> Buffer.add_string b "\x1B[01m"
                    | _ -> assert false
                    end;
                    add_markup_text ~errs end_text b s start_data
                      need_escape escape
                  end
                end
            | _ ->
                err_malformed ~errs s; loop start next
            end
        | _ -> err_unescaped ~errs '$' s; loop start next
        end
    | c when markup_need_esc c ->
        err_unescaped ~errs c s; flush start (i - 1); loop next next
    | c -> loop start next
  in
  (Buffer.clear b; loop 0 0; Buffer.contents b)

let doc_to_plain ~errs ~subst b s =
  markup_to_plain ~styled:false ~errs b (subst_vars ~errs ~subst b s)

let doc_to_styled ?buffer:(b = Buffer.create 255) ~errs ~subst s =
  let styled = Cmdliner_base.Fmt.styler () = Cmdliner_base.Fmt.Ansi in
  markup_to_plain ~styled ~errs b (subst_vars ~errs ~subst b s)



let p_indent = 7                                  (* paragraph indentation. *)
let l_indent = 4                                      (* label indentation. *)

let pp_plain_blocks ~errs subst ppf ts =
  let b = Buffer.create 1024 in
  let markup t = doc_to_plain ~errs b ~subst t in
  let pp_tokens ppf t = Fmt.tokens ~spaces:true ppf t in
  let rec blank_line = function
  | `Noblank :: ts -> loop ts
  | ts -> Format.pp_print_cut ppf (); loop ts
  and loop = function
  | [] -> ()
  | t :: ts ->
      match t with
      | `Noblank -> loop ts
      | `Blocks bs -> loop (bs @ ts)
      | `P s ->
          Fmt.pf ppf "%a@[%a@]@," Fmt.indent p_indent pp_tokens (markup s);
          blank_line ts
      | `S s -> Fmt.pf ppf "@[%a@]@," pp_tokens (markup s); loop ts
      | `Pre s ->
          Fmt.pf ppf "%a@[%a@]@," Fmt.indent p_indent Fmt.lines (markup s);
          blank_line ts
      | `I (label, s) ->
          let label = markup label and s = markup s in
          Fmt.pf ppf "@[%a@[%a@]" Fmt.indent p_indent pp_tokens label;
          begin match s with
          | "" -> Fmt.pf ppf "@]@,"
          | s ->
              let ll = String.length label in
              if ll < l_indent
              then (Fmt.pf ppf "%a@[%a@]@]@,"
                      Fmt.indent (l_indent - ll) pp_tokens s)
              else (Fmt.pf ppf "@\n%a@[%a@]@]@,"
                      Fmt.indent (p_indent + l_indent) pp_tokens s)
          end;
          blank_line ts
  in
  loop ts

let pp_plain_page ~errs subst ppf (_, text) =
  Fmt.pf ppf "@[<v>%a@]" (pp_plain_blocks ~errs subst) text

(* Groff output *)

let markup_to_groff ~errs b s =
  let max_i = String.length s - 1 in
  let flush start stop = match start > max_i with
  | true -> ()
  | false -> Buffer.add_substring b s start (stop - start + 1)
  in
  let need_escape = function '.' | '\'' | '-' | '\\' -> true | _ -> false in
  let escape b c = Printf.bprintf b "\\N'%d'" (Char.code c) in
  let rec end_text start i = Buffer.add_string b "\\fR"; loop start i
  and loop start i =
    if i > max_i then flush start max_i else
    let next = i + 1 in
    match s.[i] with
    | '\\' ->
        flush start (i - 1);
        add_markup_esc ~errs loop b s start next need_escape escape
    | '$' ->
        if next > max_i then err_unescaped ~errs '$' s else
        begin match s.[next] with
        | '(' ->
            let min = next + 2 in
            if min > max_i then (err_unclosed ~errs s; loop start next) else
            begin match s.[min] with
            | ','  ->
                let start_data = min + 1 in
                flush start (i - 1);
                begin match s.[min - 1] with
                | 'i' -> Buffer.add_string b "\\fI"
                | 'b' -> Buffer.add_string b "\\fB"
                | markup -> err_markup ~errs markup s
                end;
                add_markup_text ~errs end_text b s start_data need_escape escape
            | _ -> err_malformed ~errs s; loop start next
            end
        | _ -> err_unescaped ~errs '$' s; flush start (i - 1); loop next next
        end
    | c when markup_need_esc c ->
        err_unescaped ~errs c s; flush start (i - 1); loop next next
    | c when need_escape c ->
        flush start (i - 1); escape b c; loop next next
    | c -> loop start next
  in
  (Buffer.clear b; loop 0 0; Buffer.contents b)

let doc_to_groff ~errs ~subst b s =
  markup_to_groff ~errs b (subst_vars ~errs ~subst b s)

let pp_groff_blocks ~errs subst ppf text =
  let buf = Buffer.create 1024 in
  let markup t = doc_to_groff ~errs ~subst buf t in
  let pp_tokens ppf t = Fmt.tokens ~spaces:false ppf t in
  let rec pp_block = function
  | `Blocks bs -> List.iter pp_block bs (* not T.R. *)
  | `P s -> Fmt.pf ppf "@\n.P@\n%a" pp_tokens (markup s)
  | `Pre s -> Fmt.pf ppf "@\n.P@\n.nf@\n%a@\n.fi" Fmt.lines (markup s)
  | `S s -> Fmt.pf ppf "@\n.SH %a" pp_tokens (markup s)
  | `Noblank -> Fmt.pf ppf "@\n.sp -1"
  | `I (l, s) ->
      Fmt.pf ppf "@\n.TP 4@\n%a@\n%a" pp_tokens (markup l) pp_tokens (markup s)
  in
  List.iter pp_block text

let pp_groff_page ~errs subst ppf ((n, s, a1, a2, a3), t) =
  Fmt.pf ppf
         ".\\\" Pipe this output to groff -m man -K utf8 -T utf8 | less -R@\n\
          .\\\"@\n\
          .mso an.tmac@\n\
          .TH \"%s\" %d \"%s\" \"%s\" \"%s\"@\n\
          .\\\" Disable hyphenation and ragged-right@\n\
          .nh@\n\
          .ad l\
          %a@?"
    n s a1 a2 a3 (pp_groff_blocks ~errs subst) t

(* Printing to a pager *)

let pp_to_temp_file pp_v v =
  try
    let exec = Filename.basename Sys.argv.(0) in
    let file, oc = Filename.open_temp_file exec "out" in
    let ppf = Format.formatter_of_out_channel oc in
    pp_v ppf v; Format.pp_print_flush ppf (); close_out oc;
    at_exit (fun () -> try Sys.remove file with Sys_error e -> ());
    Some file
  with Sys_error _ -> None

let tmp_file_for_pager () =
  try
    let exec = Filename.basename Sys.argv.(0) in
    let file = Filename.temp_file exec "tty" in
    at_exit (fun () -> try Sys.remove file with Sys_error e -> ());
    Some file
  with Sys_error _ -> None

let find_cmd cmds =
  let find_win32 (cmd, _args) =
    (* `where` does not support full path lookups *)
    if String.equal (Filename.basename cmd) cmd
    then (Sys.command (strf "where %s 1> NUL 2> NUL" cmd) = 0)
    else Sys.file_exists cmd
  in
  let find_posix (cmd, _args) =
    Sys.command (strf "command -v %s 1>/dev/null 2>/dev/null" cmd) = 0
  in
  let find = if Sys.win32 then find_win32 else find_posix in
  try Some (List.find find cmds) with Not_found -> None

let getenv_empty_is_none env var = match env var with
| None | Some "" -> None | Some _ as v -> v

let find_pager env =
  let cmds = ["less", ""; "more", ""] in
  let cmds = match getenv_empty_is_none env "PAGER" with
  | Some pager -> (pager, "") :: cmds | None -> cmds
  in
  let cmds = match getenv_empty_is_none env "MANPAGER" with
  | Some manpager -> (manpager, "") :: cmds | None -> cmds
  in
  find_cmd cmds

let pp_to_pager env print ppf v =
  let run cmd = Sys.command cmd = 0 in
  let plain_pager pager = match pp_to_temp_file (print `Plain) v with
  | None -> false
  | Some f -> run (strf "%s < %s" pager f)
  in
  let groffed_pager pager =
    let groffer =
      let cmds =
        ["mandoc", " -m man -K utf-8 -T utf8";
         "groff", " -m man -K utf8 -T utf8";
         "nroff", ""]
      in
      find_cmd cmds
    in
    match groffer with
    | None -> false
    | Some (groffer, opts) ->
        let groffer = groffer ^ opts in
        match pp_to_temp_file (print `Groff) v with
        | None -> false
        | Some f ->
            (* This used to go through a pipe on non-Windows
               platforms, but this would hide errors with the groffer
               and inhibit the graceful degradation to plain text
               since POSIX shells do not "pipefail" *)
            match tmp_file_for_pager () with
            | None -> false
            | Some tmp ->
                run (strf "%s <%s >%s && %s <%s" groffer f tmp pager tmp)
  in
  match find_pager env with
  | None -> print `Plain ppf v
  | Some (pager, opts) ->
      let pager =
        let set_less_env = match env "LESS" with
        | None -> if Sys.win32 then "set LESS=FRX && " else "LESS=FRX "
        | Some _ -> "" (* Sys.command will pass it *)
        in
        set_less_env ^ pager ^ opts
      in
      if groffed_pager pager then () else
      if plain_pager pager then () else
      print `Plain ppf v

(* Output *)

type subst = string -> string option

type format = [ `Auto | `Pager | `Plain | `Groff ]

let rec print
    ?(env = Sys.getenv_opt)  ?(errs = Format.err_formatter)
    ?(subst = fun x -> None) fmt ppf page
  =
  match fmt with
  | `Pager -> pp_to_pager env (print ~env ~errs ~subst) ppf page
  | `Plain -> pp_plain_page ~errs subst ppf page
  | `Groff -> pp_groff_page ~errs subst ppf page
  | `Auto ->
      let fmt =
        match env "TERM" with
        | None when Sys.win32 -> `Pager
        | None -> `Plain
        | Some "dumb" -> `Plain
        | _ -> `Pager
      in
      print ~env ~errs ~subst fmt ppf page
end
module Cmdliner_def : sig
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

(** Core definitions. *)

(** Exit codes. *)
module Exit : sig
  type code = int
  val ok : code
  val some_error : code
  val cli_error : code
  val internal_error : code

  type info
  val info : ?docs:string -> ?doc:string -> ?max:code -> code -> info
  val info_code : info -> code
  val info_codes : info -> code * code
  val info_doc : info -> string
  val info_docs : info  -> string
  val info_order : info -> info -> int
  val defaults : info list
  val doclang_subst :
    subst:Cmdliner_manpage.subst -> info -> Cmdliner_manpage.subst
  (** [doclang_subst ~subst info] adds the substitution of [info] to
      [subst]. *)
end

(** Environment variables. *)
module Env : sig
  type var = string
  type info
  val info : ?deprecated:string -> ?docs:string -> ?doc:string -> var -> info
  val info_var : info -> string
  val info_doc : info -> string
  val info_docs : info -> string
  val info_deprecated : info -> string option
  val doclang_subst :
    subst:Cmdliner_manpage.subst -> info -> Cmdliner_manpage.subst
  (** [doclang_subst ~subst info] adds the substitution of [info] to
      [subst]. *)

  val styled_deprecated :
    errs:Format.formatter -> subst:Cmdliner_manpage.subst -> info -> string

  val styled_doc :
    errs:Format.formatter -> subst:Cmdliner_manpage.subst -> info -> string

  module Set : Set.S with type elt = info
end

(** Argument information. *)
module Arg_info : sig
  type absence =
  | Err  (** an error is reported. *)
  | Val of string Lazy.t (** if <> "", takes the given default value. *)
  | Doc of string
    (** if <> "", a doc string interpreted in the doc markup language. *)
  (** The type for what happens if the argument is absent from the cli. *)

  type opt_kind =
  | Flag (** without value, just a flag. *)
  | Opt  (** with required value. *)
  | Opt_vopt of string (** with optional value, takes given default. *)
  (** The type for optional argument kinds. *)

  type pos_kind
  val pos : rev:bool -> start:int -> len:int option -> pos_kind
  val pos_rev : pos_kind -> bool
  val pos_start : pos_kind -> int
  val pos_len : pos_kind -> int option

  type t
  val make :
    ?deprecated:string -> ?absent:string -> ?docs:string ->
    ?doc_envs:Env.info list -> ?docv:string -> ?doc:string ->
    ?env:Env.info -> string list -> t

  val id : t -> int
  val deprecated : t -> string option
  val absent : t -> absence
  val env : t -> Env.info option
  val doc : t -> string
  val docv : t -> string
  val doc_envs : t -> Env.info list
  val docs : t -> string
  val opt_names : t -> string list (* has dashes *)
  val opt_name_sample : t -> string (* warning must be an opt arg *)
  val opt_kind : t -> opt_kind
  val pos_kind : t -> pos_kind

  val make_req : t -> t
  val make_all_opts : t -> t
  val make_opt : docv:string -> absent:absence -> kind:opt_kind -> t -> t
  val make_opt_all : docv:string -> absent:absence -> kind:opt_kind -> t -> t
  val make_pos : docv:string -> pos:pos_kind -> t -> t
  val make_pos_abs : docv:string -> absent:absence -> pos:pos_kind -> t -> t

  val is_opt : t -> bool
  val is_pos : t -> bool
  val is_req : t -> bool

  val pos_cli_order : t -> t -> int
  val rev_pos_cli_order : t -> t -> int

  val compare : t -> t -> int

  val doclang_subst :
    subst:Cmdliner_manpage.subst -> t -> Cmdliner_manpage.subst
  (** [doclang_subst ~subst info] adds the substitution of [info] to
      [subst]. Note this includes the substitutions for [env] if present. *)

  val styled_deprecated :
    errs:Format.formatter -> subst:Cmdliner_manpage.subst -> t -> string

  val styled_doc :
    errs:Format.formatter -> subst:Cmdliner_manpage.subst -> t -> string

  type 'a conv
  type e_conv = Conv : 'a conv -> e_conv

  module Set : sig
    type arg := t
    type t
    val is_empty : t -> bool
    val empty : t
    val add : arg -> e_conv -> t -> t
    val choose : t -> arg * e_conv
    val partition : (arg -> e_conv -> bool) -> t -> t * t
    val filter : (arg -> e_conv -> bool) -> t -> t
    val iter : (arg -> e_conv -> unit) -> t -> unit
    val singleton : arg -> e_conv -> t
    val fold : (arg -> e_conv -> 'acc -> 'acc) -> t -> 'acc -> 'acc
    val elements : t -> arg list
    val union : t -> t -> t
    val find_opt : arg -> t -> e_conv option
  end
end

(** Command information. *)
module Cmd_info : sig
  type t
  val make :
    ?deprecated:string -> ?man_xrefs:Cmdliner_manpage.xref list ->
    ?man:Cmdliner_manpage.block list -> ?envs:Env.info list ->
    ?exits:Exit.info list -> ?sdocs:string -> ?docs:string -> ?doc:string ->
    ?version:string -> string -> t

  val name : t -> string
  val version : t -> string option
  val deprecated : t -> string option
  val doc : t -> string
  val docs : t -> string
  val stdopts_docs : t -> string
  val exits : t -> Exit.info list
  val envs : t -> Env.info list
  val man : t -> Cmdliner_manpage.block list
  val man_xrefs : t -> Cmdliner_manpage.xref list
  val args : t -> Arg_info.Set.t
  val has_args : t -> bool
  val children : t -> t list
  val add_args : t -> Arg_info.Set.t -> t
  val with_children : t -> args:Arg_info.Set.t option -> children:t list -> t
  val styled_deprecated :
    errs:Format.formatter -> subst:Cmdliner_manpage.subst -> t -> string

  val styled_doc :
    errs:Format.formatter -> subst:Cmdliner_manpage.subst -> t -> string
end

(** Untyped command line parses. *)
module Cline : sig
  type arg =
  | O of (int * string * (string option)) list (* (pos, name, value) of opt. *)
  | P of string list (** *)
  (** Unconverted argument data as found on the command line. *)

  type t (* command line, maps arg_infos to arg value. *)
  val empty : t
  val add : Arg_info.t -> arg -> t -> t
  val get_arg : t -> Arg_info.t -> arg
  val get_opt_arg : t -> Arg_info.t -> (int * string * (string option)) list
  val get_pos_arg : t -> Arg_info.t -> string list
  val actual_args : t -> Arg_info.t -> string list
  (** Actual command line arguments from the command line *)

  val fold : (Arg_info.t -> arg -> 'b -> 'b) -> t -> 'b -> 'b

  (** {1:deprecations Deprecations} *)

  type deprecated
  (** The type for deprecation invocations. This include both environment
      variable deprecations and argument deprecations. *)

  val deprecated :
    env:(string -> string option) -> t -> deprecated list
  (** [deprecated ~env cli] are the deprecated invocations that occur
      when parsing [cli]. *)

  val pp_deprecated :
    subst:Cmdliner_manpage.subst -> deprecated Cmdliner_base.Fmt.t
    (** [pp_deprecated] formats deprecations. *)
end

(** Evaluation. *)
module Eval : sig
  type t
  val make :
    ancestors:Cmd_info.t list -> cmd:Cmd_info.t -> subcmds:Cmd_info.t list ->
    env:(string -> string option) -> err_ppf:Format.formatter -> t

  val cmd : t -> Cmd_info.t
  val main : t -> Cmd_info.t
  val ancestors : t -> Cmd_info.t list (* root is last *)
  val subcmds : t -> Cmd_info.t list
  val env_var : t -> string -> string option
  val err_ppf : t -> Format.formatter
  val with_cmd : t -> Cmd_info.t -> t
  val doclang_subst : t -> Cmdliner_manpage.subst
end

(** Terms, typed cli fragment definitions. *)
module Term : sig
  type escape =
  [ `Error of bool * string
  | `Help of Cmdliner_manpage.format * string option ]

  type 'a parser =
    Eval.t -> Cline.t -> ('a, [ `Parse of string | escape ]) result

  type 'a t = Arg_info.Set.t * 'a parser
end

(** Completion strategies *)
module Arg_completion : sig
  type 'a directive =
  | Message of string | String of string * string | Value of 'a * string
  | Files | Dirs | Restart | Raw of string

  val value : ?doc:string -> 'a -> 'a directive
  val string : ?doc:string -> string -> 'a directive
  val files : 'a directive
  val dirs : 'a directive
  val restart : 'a directive
  val message : string -> 'a directive
  val raw : string -> 'a directive

  type ('ctx, 'a) func =
    'ctx option -> token:string -> ('a directive list, string) result

  type 'a complete =
  | Complete : 'ctx Term.t option * ('ctx, 'a) func -> 'a complete

  type 'a t

  val make : ?context:'ctx Term.t -> ('ctx, 'a) func -> 'a t
  val complete : 'a t -> 'a complete
  val complete_none : 'a t
  val complete_files : 'a t
  val complete_dirs : 'a t
  val complete_paths : 'a t
  val complete_restart : 'a t
end

(** Textual OCaml value converters *)
module Arg_conv : sig
  type 'a parser = string -> ('a, string) result
  type 'a fmt = 'a Cmdliner_base.Fmt.t
  type 'a t = 'a Arg_info.conv
  val make :
    ?completion:'a Arg_completion.t -> docv:string -> parser:'a parser ->
    pp:'a fmt -> unit -> 'a t

  val of_conv :
    ?completion:'a Arg_completion.t -> ?docv:string ->
    ?parser:'a parser -> ?pp:'a fmt -> 'a t -> 'a t

  val docv : 'a t -> string
  val parser : 'a t -> 'a parser
  val pp : 'a t -> 'a fmt
  val completion : 'a t -> 'a Arg_completion.t

  val some : ?none:string -> 'a t -> 'a option t
  val some' : ?none:'a -> 'a t -> 'a option t

  val none : 'a t
end

(** Complete instruction. *)
module Complete : sig
  type kind =
  | Opt_value of Arg_info.t
  | Opt_name_or_pos_value of Arg_info.t
  | Opt_name

  type t
  val make : ?after_dashdash:bool -> ?subcmds:bool -> token:string -> kind -> t
  val token : t -> string
  val after_dashdash : t -> bool
  val subcmds : t -> bool
  val kind : t -> kind
  val add_subcmds : t -> t
end
end = struct
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

let strf = Printf.sprintf

(* Exit codes *)

module Exit = struct
  type code = int

  let ok = 0
  let some_error = 123
  let cli_error = 124
  let internal_error = 125

  type info =
    { codes : code * code; (* min, max *)
      doc : string; (* help. *)
      docs : string; } (* title of help section where listed. *)

  let info
      ?(docs = Cmdliner_manpage.s_exit_status) ?(doc = "undocumented") ?max min
    =
    let max = match max with None -> min | Some max -> max in
    { codes = (min, max); doc; docs }

  let info_codes i = i.codes
  let info_code i = fst i.codes
  let info_doc i = i.doc
  let info_docs i = i.docs
  let info_order i0 i1 = compare i0.codes i1.codes
  let defaults =
    [ info ok ~doc:"on success.";
      info some_error
        ~doc:"on indiscriminate errors reported on standard error.";
      info cli_error ~doc:"on command line parsing errors.";
      info internal_error ~doc:"on unexpected internal errors (bugs)."; ]

  let doclang_subst ~subst i = function
  | "status" -> Some (string_of_int (info_code i))
  | "status_max" -> Some (string_of_int (snd i.codes))
  | id -> subst id
end

(* Environment variables *)

module Env = struct
  type var = string
  type info = (* information about an environment variable. *)
    { id : int; (* unique id for the env var. *)
      deprecated : string option;
      var : string; (* the variable. *)
      doc : string; (* help. *)
      docs : string; } (* title of help section where listed. *)

  let info
      ?deprecated
      ?(docs = Cmdliner_manpage.s_environment) ?(doc = "See option $(opt).") var
    =
    { id = Cmdliner_base.uid (); deprecated; var; doc; docs }

  let info_deprecated i = i.deprecated
  let info_var i = i.var
  let info_doc i = i.doc
  let info_docs i = i.docs
  let info_compare i0 i1 = Int.compare i0.id i1.id

  let doclang_subst ~subst i = function
  | "env" -> Some (strf "$(b,%s)" (Cmdliner_manpage.escape i.var))
  | id -> subst id

  let styled_deprecated ~errs ~subst i = match i.deprecated with
  | None -> "" | Some msg -> Cmdliner_manpage.doc_to_styled ~errs ~subst msg

  let styled_doc ~errs ~subst i =
    Cmdliner_manpage.doc_to_styled ~errs ~subst i.doc

  module Set = Set.Make (struct type t = info let compare = info_compare end)
end

(* Argument information *)

module Arg_info = struct
  type absence = Err | Val of string Lazy.t | Doc of string
  type opt_kind = Flag | Opt | Opt_vopt of string
  type pos_kind = (* information about a positional argument. *)
    { pos_rev : bool; (* if [true] positions are counted from the end. *)
      pos_start : int; (* start positional argument. *)
      pos_len : int option } (* number of arguments or [None] if unbounded. *)

  let pos ~rev:pos_rev ~start:pos_start ~len:pos_len =
    { pos_rev; pos_start; pos_len}

  let pos_rev p = p.pos_rev
  let pos_start p = p.pos_start
  let pos_len p = p.pos_len
  let dumb_pos = pos ~rev:false ~start:(-1) ~len:None

  type t = (* information about a command line argument. *)
    { id : int; (* unique id for the argument. *)
      deprecated : string option; (* deprecation message *)
      absent : absence; (* behaviour if absent. *)
      env : Env.info option; (* environment variable for default value. *)
      doc : string; (* help. *)
      docv : string; (* variable name for the argument in help. *)
      doc_envs : Env.info list; (* environment that needs to be added to docs *)
      docs : string; (* title of help section where listed. *)
      pos : pos_kind; (* positional arg kind. *)
      opt_kind : opt_kind; (* optional arg kind. *)
      opt_names : string list; (* names (for opt args). *)
      opt_all : bool; } (* repeatable (for opt args). *)

  let make
      ?deprecated ?(absent = "") ?docs ?(doc_envs = []) ?(docv = "")
      ?(doc = "") ?env names
    =
    let dash n = if String.length n = 1 then "-" ^ n else "--" ^ n in
    let opt_names = List.map dash names in
    let docs = match docs with
    | Some s -> s
    | None ->
        match names with
        | [] -> Cmdliner_manpage.s_arguments
        | _ -> Cmdliner_manpage.s_options
    in
    { id = Cmdliner_base.uid (); deprecated; absent = Doc absent;
      env; doc; docv; doc_envs; docs; pos = dumb_pos;
      opt_kind = Flag; opt_names; opt_all = false; }

  let id i = i.id
  let deprecated i = i.deprecated
  let absent i = i.absent
  let env i = i.env
  let doc i = i.doc
  let docv i = i.docv
  let doc_envs i = i.doc_envs
  let docs i = i.docs
  let pos_kind i = i.pos
  let opt_kind i = i.opt_kind
  let opt_names i = i.opt_names
  let opt_all i = i.opt_all
  let opt_name_sample i =
    (* First long or short name (in that order) in the list; this
       allows the client to control which name is shown *)
    let rec find = function
    | [] -> List.hd i.opt_names
    | n :: ns -> if (String.length n) > 2 then n else find ns
    in
    find i.opt_names

  let make_req i = { i with absent = Err }
  let make_all_opts i = { i with opt_all = true }
  let make_opt ~docv ~absent ~kind:opt_kind i =
    { i with absent; opt_kind; docv }

  let make_opt_all ~docv ~absent ~kind:opt_kind i =
    { i with absent; opt_kind; opt_all = true; docv  }

  let make_pos ~docv ~pos i = { i with pos; docv }
  let make_pos_abs ~docv ~absent ~pos i = { i with absent; pos; docv }

  let is_opt i = i.opt_names <> []
  let is_pos i = i.opt_names = []
  let is_req i = i.absent = Err

  let pos_cli_order (a0 : t) (a1 : t) = (* best-effort order on the cli. *)
    let c = Bool.compare (a0.pos.pos_rev) (a1.pos.pos_rev) in
    if c <> 0 then c else
    if a0.pos.pos_rev
    then Int.compare a1.pos.pos_start a0.pos.pos_start
    else Int.compare a0.pos.pos_start a1.pos.pos_start

  let rev_pos_cli_order a0 a1 = pos_cli_order a1 a0

  let doclang_subst ~subst (i : t) = function
  | "docv" ->
      let docv = if i.docv = "" then "VAL" else i.docv in
      Some (strf "$(i,%s)" (Cmdliner_manpage.escape docv))
  | "opt" when is_opt i ->
      Some (strf "$(b,%s)" (Cmdliner_manpage.escape (opt_name_sample i)))
  | id ->
      match env i with
      | Some e -> Env.doclang_subst ~subst e id
      | None -> subst id

  let styled_deprecated ~errs ~subst (i : t) = match i.deprecated with
  | None -> "" | Some msg -> Cmdliner_manpage.doc_to_styled ~errs ~subst msg

  let styled_doc ~errs ~subst (i : t) =
    Cmdliner_manpage.doc_to_styled ~errs ~subst i.doc

  let compare (a0 : t) (a1 : t) = Int.compare a0.id a1.id
  module Map = Map.Make (struct type nonrec t = t let compare = compare end)

  (* Due to terms appearing in the completion API, we have an annoying
     recursive type definition which we resolve here. Most of these
     types do not belong this module. *)

  type term_escape =
  [ `Error of bool * string
  | `Help of Cmdliner_manpage.format * string option ]

  type 'a completion_directive =
  | Message of string | String of string * string | Value of 'a * string
  | Files | Dirs | Restart | Raw of string

  type ('ctx, 'a) completion_func =
    'ctx option -> token:string -> ('a completion_directive list, string) result

  type 'a parser = string -> ('a, string) result
  type 'a complete =
  | Complete : 'ctx term option * ('ctx, 'a) completion_func -> 'a complete

  and 'a completion = { complete : 'a complete }

  and 'a conv =
    { docv : string;
      parser : 'a parser;
      pp : 'a Cmdliner_base.Fmt.t;
      completion : 'a completion; }

  and e_conv = Conv : 'a conv -> e_conv
  and arg_set = e_conv Map.t
  and cmd =
    { name : string; (* name of the cmd. *)
      version : string option; (* version (for --version). *)
      deprecated : string option; (* deprecation message *)
      doc : string; (* one line description of cmd. *)
      docs : string; (* title of man section where listed (commands). *)
      sdocs : string; (* standard options, title of section where listed. *)
      exits : Exit.info list; (* exit codes for the cmd. *)
      envs : Env.info list; (* env vars that influence the cmd. *)
      man : Cmdliner_manpage.block list; (* man page text. *)
      man_xrefs : Cmdliner_manpage.xref list; (* man cross-refs. *)
      args : arg_set; (* Command arguments. *)
      has_args : bool; (* [true] if has own parsing term. *)
      children : cmd list; } (* Children, if any. *)

  and eval = (* information about the evaluation context. *)
    { cmd : cmd; (* cmd being evaluated. *)
      ancestors : cmd list; (* ancestors of cmd, root is last. *)
      subcmds : cmd list; (* subcommands (if any) *)
      env : string -> string option; (* environment variable lookup. *)
      err_ppf : Format.formatter (* error formatter *) }

  and cline = cline_arg Map.t
  and cline_arg = (* unconverted argument data as found on the command line. *)
  | O of (int * string * (string option)) list (* (pos, name, value) of opt. *)
  | P of string list

  and 'a term_parser =
    eval -> cline -> ('a, [ `Parse of string | term_escape ]) result

  and 'a term = arg_set * 'a term_parser

  (* Sets of arguments stored as maps to their completion *)

  module Set = struct
    include Map
    type t = e_conv Map.t
    let find_opt k m = try Some (Map.find k m) with Not_found -> None
    let elements m = List.map fst (bindings m)
    let union a b =
      Map.merge (fun k v v' ->
        match v, v' with
        | Some v, _ | _, Some v -> Some v
        | None, None -> assert false) a b
  end
end

(* Commands *)

module Cmd_info = struct
  type t = Arg_info.cmd
  let make
      ?deprecated ?(man_xrefs = [`Main]) ?(man = []) ?(envs = [])
      ?(exits = Exit.defaults) ?(sdocs = Cmdliner_manpage.s_common_options)
      ?(docs = Cmdliner_manpage.s_commands) ?(doc = "") ?version name : t
    =
    { name; version; deprecated; doc; docs; sdocs; exits;
      envs; man; man_xrefs; args = Arg_info.Set.empty;
      has_args = true; children = [] }

  let name (i : t) = i.name
  let version (i : t) = i.version
  let deprecated (i : t) = i.deprecated
  let doc (i : t) = i.doc
  let docs (i : t) = i.docs
  let stdopts_docs (i : t) = i.sdocs
  let exits (i : t) = i.exits
  let envs (i : t) = i.envs
  let man (i : t) = i.man
  let man_xrefs (i : t) = i.man_xrefs
  let args (i : t) = i.args
  let has_args (i : t) = i.has_args
  let children (i : t) = i.children
  let add_args (i : t) args = { i with args = Arg_info.Set.union args i.args }
  let with_children (i : t) ~args ~children =
    let has_args, args = match args with
    | None -> false, i.args
    | Some args -> true, Arg_info.Set.union args i.args
    in
    { i with has_args; args; children }

  let styled_deprecated ~errs ~subst (i : t) = match i.deprecated with
  | None -> "" | Some msg -> Cmdliner_manpage.doc_to_styled ~errs ~subst msg

  let styled_doc ~errs ~subst (i : t) =
    Cmdliner_manpage.doc_to_styled ~errs ~subst i.doc

  let escaped_name (i : t) = Cmdliner_manpage.escape i.name
end

(* Command lines *)

module Cline = struct
  type arg = Arg_info.cline_arg =
  | O of (int * string * (string option)) list
  | P of string list

  type t = Arg_info.cline

  let empty = Arg_info.Map.empty
  let add = Arg_info.Map.add
  let fold = Arg_info.Map.fold
  let get_arg cline a : arg =
    try Arg_info.Map.find a cline with Not_found -> assert false

  let get_opt_arg cline a =
    match get_arg cline a with O l -> l | _ -> assert false

  let get_pos_arg cline a =
    match get_arg cline a with P l -> l | _ -> assert false

  let actual_args cline a = match get_arg cline a with
  | P args -> args
  | O l ->
      let extract_args (_pos, name, value) =
        name :: (match value with None -> [] | Some v -> [v])
      in
      List.concat (List.map extract_args l)

  (* Deprecations *)

  type deprecated = Arg_info.t * arg

  let deprecated ~env cline =
    let add ~env info arg acc =
      let deprecation_invoked = match (arg : arg) with
      | O [] | P [] -> (* nothing on the cli for the argument *)
          begin match Arg_info.env info with
          | None -> false
          | Some ienv ->
              (* the parse uses the env var if defined which may be
                 deprecated  *)
              Option.is_some (Env.info_deprecated ienv) &&
              Option.is_some (env (Env.info_var ienv))
          end
      | _ -> Option.is_some (Arg_info.deprecated info)
      in
      if deprecation_invoked then (info, arg) :: acc else acc
    in
    List.rev (fold (add ~env) cline [])

  let pp_deprecated ~subst ppf (info, arg) =
    let open Cmdliner_base in
  let plural l = if List.length l > 1 then "s" else "" in
    let subst = Arg_info.doclang_subst ~subst info in
    match (arg : arg) with
    | O [] | P [] ->
        let env = Option.get (Arg_info.env info) in
        let msg = Env.styled_deprecated ~errs:ppf ~subst env in
        Fmt.pf ppf "@[%a @[environment variable %a: %a@]@]"
          Fmt.deprecated () Fmt.code (Env.info_var env)
          Fmt.styled_text msg
    | O os ->
        let plural = plural os in
        let names = List.map (fun (_, n, _) -> n) os in
        let msg = Arg_info.styled_deprecated ~errs:ppf ~subst info in
        Fmt.pf ppf "@[%a @[option%s %a: %a@]@]"
          Fmt.deprecated () plural Fmt.(list ~sep:sp code_or_quote) names
          Fmt.styled_text msg
    | P args ->
        let plural = plural args in
        let msg =
          Arg_info.styled_deprecated ~errs:ppf ~subst info
        in
        Fmt.pf ppf "@[%a @[argument%s %a: %a@]@]"
          Fmt.deprecated () plural Fmt.(list ~sep:sp code_or_quote) args
          Fmt.styled_text msg
end

(* Evaluation *)

module Eval = struct
  type t = Arg_info.eval

  let make ~ancestors ~cmd ~subcmds ~env ~err_ppf : t =
    { ancestors; cmd; subcmds; env; err_ppf }

  let cmd (i : t) = i.cmd
  let ancestors (i : t) = i.ancestors
  let subcmds (i : t) = i.subcmds
  let env_var (i : t) v = i.env v
  let err_ppf (i : t) = i.err_ppf
  let main (i : t) = match List.rev i.ancestors with [] -> i.cmd | m :: _ -> m
  let with_cmd (i : t) cmd = { i with cmd }

  let doclang_name n = strf "$(b,%s)" (Cmd_info.escaped_name n)
  let doclang_names names =
    strf "$(b,%s)" (Cmdliner_manpage.escape (String.concat " " names))

  let doclang_subst (i : t) = function
  | "tname" | "cmd.name" -> Some (doclang_name i.cmd)
  | "mname" | "tool" -> Some (doclang_name (main i))
  | "cmd.parent" ->
      let ancestors = ancestors i in
      if ancestors = [] then Some (doclang_name (main i)) else
      Some (doclang_names (List.rev_map Cmd_info.name ancestors))
  | "iname" | "cmd" ->
      Some (doclang_names (List.rev_map Cmd_info.name (cmd i :: ancestors i)))
  | _ -> None
end

(* Terms *)

module Term = struct
  type escape = Arg_info.term_escape
  type 'a parser = 'a Arg_info.term_parser
  type 'a t = 'a Arg_info.term
  let some (aset, parser) =
    aset, (fun eval cline -> Result.map Option.some (parser eval cline))
end

module Arg_completion = struct
  type 'a directive = 'a Arg_info.completion_directive =
  | Message of string | String of string * string | Value of 'a * string
  | Files | Dirs | Restart | Raw of string

  let value ?(doc = "") v = Value (v, doc)
  let string ?(doc = "") s = String (s, doc)
  let files = Files
  let dirs = Dirs
  let restart = Restart
  let message msg = Message msg
  let raw s = Raw s

  type ('ctx, 'a) func =
    'ctx option -> token:string -> ('a directive list, string) result

  type 'a complete = 'a Arg_info.complete =
  | Complete : 'ctx Term.t option * ('ctx, 'a) func -> 'a complete

  type 'a t = 'a Arg_info.completion

  let make ?context func : 'a t = { complete = Complete (context, func) }
  let complete (c : 'a t) = c.complete

  let complete_files : 'a t =
    { complete = Complete (None, fun _ ~token:_ -> Ok [Files]) }

  let complete_dirs : 'a t =
    { complete = Complete (None, fun _ ~token:_ -> Ok [Dirs]) }

  let complete_paths : 'a t =
    { complete = Complete (None, fun _ ~token:_ -> Ok [Files; Dirs]) }

  let complete_restart : 'a t =
    { complete = Complete (None, fun _ ~token:_ -> Ok [Restart]) }

  let complete_none : 'a t =
    { complete = Complete (None, fun _ ~token:_ -> Ok []) }

  let directive_some : 'a directive -> 'a option directive = function
  | Value (v, doc) -> Value (Some v, doc)
  | (Message _ | String _ | Files | Dirs | Restart | Raw _ as v) -> v

  let complete_some (c : 'a t) : 'a option t = match c.complete with
  | Complete (ctx, func) ->
      let func ctx ~token =
        let some_result directives = List.map directive_some directives in
        Result.map some_result (func ctx ~token)
      in
      { complete = Complete (ctx, func) }
end

(* Converters *)

module Arg_conv = struct
  type 'a parser = 'a Arg_info.parser
  type 'a fmt = 'a Cmdliner_base.Fmt.t
  type 'a t = 'a Arg_info.conv

  let make
      ?(completion = Arg_completion.complete_none) ~docv ~parser ~pp () : 'a t =
    { docv; parser; pp; completion }

  let of_conv ?completion ?docv ?parser ?pp (conv : 'a t) : 'a t
    =
    let completion = Option.value ~default:conv.completion completion in
    let docv = Option.value ~default:conv.docv docv in
    let parser = Option.value ~default:conv.parser parser in
    let pp = Option.value ~default:conv.pp pp in
    { docv; parser; pp; completion }

  let docv (c : 'a t) = c.docv
  let parser (c : 'a t) = c.parser
  let pp (c : 'a t) = c.pp
  let completion (c : 'a t) = c.completion

  let none : 'a t =
    { docv = "";
      parser = (fun _ -> assert false);
      pp = (fun _ _ -> assert false);
      completion = Arg_completion.complete_none }

  let some ?(none = "") conv =
    let parser s = Result.map Option.some (parser conv s) in
    let pp ppf v = match v with
    | None -> Format.pp_print_string ppf none
    | Some v -> pp conv ppf v
    in
    let completion = Arg_completion.complete_some (completion conv) in
    { conv with parser; pp; completion }

  let some' ?none conv =
    let parser s = Result.map Option.some (parser conv s) in
    let pp ppf = function
    | None -> (match none with None -> () | Some v -> (pp conv) ppf v)
    | Some v -> pp conv ppf v
    in
    let completion = Arg_completion.complete_some conv.completion in
    { conv with parser; pp; completion }
end

(* Completion *)

module Complete = struct
  type kind =
  | Opt_value of Arg_info.t
  | Opt_name_or_pos_value of Arg_info.t
  | Opt_name

  type t =
    { token : string;
      after_dashdash : bool;
      subcmds : bool; (* Note this is adjusted in Cmdliner_eval *)
      kind : kind }

  let make ?(after_dashdash = false) ?(subcmds = false) ~token kind =
    { token; after_dashdash; subcmds; kind; }

  let token c = c.token
  let after_dashdash c = c.after_dashdash
  let subcmds c = c.subcmds
  let kind c = c.kind
  let add_subcmds c = { c with subcmds = true }
end
end
module Cmdliner_docgen : sig
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

val pp_man :
  env:(string -> string option) ->
  errs:Format.formatter -> Cmdliner_manpage.format -> Format.formatter ->
  Cmdliner_def.Eval.t -> unit

val styled_usage_synopsis :
  errs:Format.formatter -> Cmdliner_def.Eval.t -> string
end = struct
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

let rev_compare n0 n1 = compare n1 n0
let strf = Printf.sprintf

let order_args a0 a1 =
  match Cmdliner_def.Arg_info.is_opt a0, Cmdliner_def.Arg_info.is_opt a1 with
  | true, true -> (* optional by name *)
      let key names =
        let k = List.hd (List.sort rev_compare names) in
        let k = String.lowercase_ascii k in
        if k.[1] = '-' then String.sub k 1 (String.length k - 1) else k
      in
      compare
        (key @@ Cmdliner_def.Arg_info.opt_names a0)
        (key @@ Cmdliner_def.Arg_info.opt_names a1)
  | false, false -> (* positional by variable *)
      compare
        (String.lowercase_ascii @@ Cmdliner_def.Arg_info.docv a0)
        (String.lowercase_ascii @@ Cmdliner_def.Arg_info.docv a1)
  | true, false -> -1 (* positional first *)
  | false, true -> 1  (* optional after *)

let esc = Cmdliner_manpage.escape

let sorted_items_to_blocks ~boilerplate:b items =
  (* Items are sorted by section and then rev. sorted by appearance.
     We gather them by section in correct order in a `Block and prefix
     them with optional boilerplate *)
  let boilerplate = match b with None -> (fun _ -> None) | Some b -> b in
  let mk_block sec acc = match boilerplate sec with
  | None -> (sec, `Blocks acc)
  | Some b -> (sec, `Blocks (b :: acc))
  in
  let rec loop secs sec acc = function
  | (sec', it) :: its when sec' = sec -> loop secs sec (it :: acc) its
  | (sec', it) :: its -> loop (mk_block sec acc :: secs) sec' [it] its
  | [] -> (mk_block sec acc) :: secs
  in
  match items with
  | [] -> []
  | (sec, it) :: its -> loop [] sec [it] its

(* Command docs *)

let invocation ?(sep = " ") ?(ancestors = []) cmd =
  let names = List.rev_map Cmdliner_def.Cmd_info.name (cmd :: ancestors) in
  esc @@ String.concat sep names

let synopsis_pos_arg a =
  let v = match Cmdliner_def.Arg_info.docv a with "" -> "ARG" | v -> v in
  let v = strf "$(i,%s)" (esc v) in
  let v =
    (if Cmdliner_def.Arg_info.is_req a then strf "%s" else strf "[%s]") v
  in
  match Cmdliner_def.Arg_info.(pos_len @@ pos_kind a) with
  | None -> v ^ ""
  | Some 1 -> v
  | Some n ->
      let rec loop n acc = if n <= 0 then acc else loop (n - 1) (v :: acc) in
      String.concat " " (loop n [])

let synopsis_opt_arg a n =
  let var = match Cmdliner_def.Arg_info.docv a with "" -> "VAL" | v -> v in
  match Cmdliner_def.Arg_info.opt_kind a with
  | Cmdliner_def.Arg_info.Flag -> strf "$(b,%s)" (esc n)
  | Cmdliner_def.Arg_info.Opt ->
        if String.length n > 2
        then strf "$(b,%s)=$(i,%s)" (esc n) (esc var)
        else strf "$(b,%s) $(i,%s)" (esc n) (esc var)
  | Cmdliner_def.Arg_info.Opt_vopt _ ->
      if String.length n > 2
      then strf "$(b,%s)[=$(i,%s)]" (esc n) (esc var)
      else strf "$(b,%s) [$(i,%s)]" (esc n) (esc var)

let deprecated cmd = match Cmdliner_def.Cmd_info.deprecated cmd with
| None -> "" | Some _ -> "(Deprecated) "

let synopsis ?(show_help = false) ?ancestors cmd =
  let show_help = if show_help then " [$(b,--help)]" else "" in
  match Cmdliner_def.Cmd_info.children cmd with
  | [] ->
      let rev_cli_order (a0, _) (a1, _) =
        Cmdliner_def.Arg_info.rev_pos_cli_order a0 a1
      in
      let args = Cmdliner_def.Cmd_info.args cmd in
      let oargs, pargs =
        Cmdliner_def.Arg_info.(Set.partition (fun a _ -> is_opt a) args)
      in
      let oargs =
        (* Keep only those that are listed in the s_options section and
           that are not [--version] or [--help]. * *)
        let keep a _ =
          let drop_names n = n = "--help" || n = "--version" in
          Cmdliner_def.Arg_info.docs a = Cmdliner_manpage.s_options &&
          not (List.exists drop_names (Cmdliner_def.Arg_info.opt_names a))
        in
        let oargs = Cmdliner_def.Arg_info.Set.(elements (filter keep oargs)) in
        let count = List.length oargs in
        let any_option = "[$(i,OPTION)]" in
        if count = 0 || count > 3 then any_option else
        let syn a =
          let syn =
            synopsis_opt_arg a (Cmdliner_def.Arg_info.opt_name_sample a)
          in
          if Cmdliner_def.Arg_info.is_req a
          then syn
          else strf "[%s]" syn
        in
        let oargs = List.sort order_args oargs in
        let oargs = String.concat " " (List.map syn oargs) in
        String.concat " " [oargs; any_option]
      in
      let pargs =
        let pargs = Cmdliner_def.Arg_info.Set.elements pargs in
        if pargs = [] then "" else
        let pargs = List.map (fun a -> a, synopsis_pos_arg a) pargs in
        let pargs = List.sort rev_cli_order pargs in
        String.concat " " ("" (* add a space *) :: List.rev_map snd pargs)
      in
      strf "%s$(b,%s)%s %s%s"
        (deprecated cmd) (invocation ?ancestors cmd) show_help oargs pargs
  | _cmds ->
      let subcmd = match Cmdliner_def.Cmd_info.has_args cmd with
      | false -> "$(i,COMMAND)" | true -> "[$(i,COMMAND)]"
      in
      strf "%s$(b,%s)%s %s " (deprecated cmd) (invocation ?ancestors cmd)
        show_help subcmd

let cmd_doc cmd =
  let depr = match Cmdliner_def.Cmd_info.deprecated cmd with
  | None -> "" | Some msg -> msg ^ " "
  in
  depr ^ Cmdliner_def.Cmd_info.doc cmd

let cmd_docs ei = match Cmdliner_def.(Cmd_info.children (Eval.cmd ei)) with
| [] -> []
| cmds ->
    let add_cmd acc cmd =
      let syn = synopsis cmd in
      (Cmdliner_def.Cmd_info.docs cmd, `I (syn, cmd_doc cmd)) :: acc
    in
    let by_sec_by_rev_name (s0, `I (c0, _)) (s1, `I (c1, _)) =
      let c = compare s0 s1 in
      if c <> 0 then c else compare c1 c0 (* N.B. reverse *)
    in
    let cmds = List.fold_left add_cmd [] cmds in
    let cmds = List.sort by_sec_by_rev_name cmds in
    let cmds = (cmds :> (string * Cmdliner_manpage.block) list) in
    sorted_items_to_blocks ~boilerplate:None cmds

(* Argument docs *)

let arg_man_item_label a =
  let s = match Cmdliner_def.Arg_info.is_pos a with
  | true -> strf "$(i,%s)" (esc @@ Cmdliner_def.Arg_info.docv a)
  | false ->
      let names = List.sort compare (Cmdliner_def.Arg_info.opt_names a) in
      String.concat ", " (List.rev_map (synopsis_opt_arg a) names)
  in
  match Cmdliner_def.Arg_info.deprecated a with
  | None -> s | Some _ -> "(Deprecated) " ^ s

let arg_to_man_item ~errs ~subst ~buf a =
  let subst = Cmdliner_def.Arg_info.doclang_subst ~subst a in
  let or_env ~value a = match Cmdliner_def.Arg_info.env a with
  | None -> ""
  | Some e ->
      let value = if value then " or" else "absent " in
      strf "%s $(b,%s) env" value (esc @@ Cmdliner_def.Env.info_var e)
  in
  let absent = match Cmdliner_def.Arg_info.absent a with
  | Cmdliner_def.Arg_info.Err -> "required"
  | Cmdliner_def.Arg_info.Doc "" -> strf "%s" (or_env ~value:false a)
  | Cmdliner_def.Arg_info.Doc s ->
      let s = Cmdliner_manpage.subst_vars ~errs ~subst buf s in
      strf "absent=%s%s" s (or_env ~value:true a)
  | Cmdliner_def.Arg_info.Val v ->
      match Lazy.force v with
      | "" -> strf "%s" (or_env ~value:false a)
      | v -> strf "absent=$(b,%s)%s" (esc v) (or_env ~value:true a)
  in
  let optvopt = match Cmdliner_def.Arg_info.opt_kind a with
  | Cmdliner_def.Arg_info.Opt_vopt v -> strf "default=$(b,%s)" (esc v)
  | _ -> ""
  in
  let argvdoc = match optvopt, absent with
  | "", "" -> ""
  | s, "" | "", s -> strf " (%s)" s
  | s, s' -> strf " (%s) (%s)" s s'
  in
  let deprecated = match Cmdliner_def.Arg_info.deprecated a with
  | None -> "" | Some msg -> msg ^ " "
  in
  let doc = deprecated ^ Cmdliner_def.Arg_info.doc a in
  let doc = Cmdliner_manpage.subst_vars ~errs ~subst buf doc in
  (Cmdliner_def.Arg_info.docs a, `I (arg_man_item_label a ^ argvdoc, doc))

let arg_docs ~errs ~subst ~buf ei =
  let by_sec_by_arg a0 a1 =
    let c = compare
        (Cmdliner_def.Arg_info.docs a0)
        (Cmdliner_def.Arg_info.docs a1)
    in
    if c <> 0 then c else
    let c =
      match
        Cmdliner_def.Arg_info.deprecated a0,
        Cmdliner_def.Arg_info.deprecated a1
      with
      | None, None | Some _, Some _ -> 0
      | None, Some _ -> -1 | Some _, None -> 1
    in
    if c <> 0 then c else order_args a0 a1
  in
  let keep_arg a _ acc =
    if not Cmdliner_def.Arg_info.(is_pos a && (docv a = "" || doc a = ""))
    then (a :: acc) else acc
  in
  let args = Cmdliner_def.Cmd_info.args @@ Cmdliner_def.Eval.cmd ei in
  let args = Cmdliner_def.Arg_info.Set.fold keep_arg args [] in
  let args = List.sort by_sec_by_arg args in
  let args = List.rev_map (arg_to_man_item ~errs ~subst ~buf) args in
  sorted_items_to_blocks ~boilerplate:None args

(* Exit statuses doc *)

let exit_boilerplate sec = match sec = Cmdliner_manpage.s_exit_status with
| false -> None
| true -> Some (Cmdliner_manpage.s_exit_status_intro)

let exit_docs ~errs ~subst ~buf ~has_sexit ei =
  let by_sec (s0, _) (s1, _) = compare s0 s1 in
  let add_exit_item acc einfo =
    let subst = Cmdliner_def.Exit.doclang_subst ~subst einfo in
    let min, max = Cmdliner_def.Exit.info_codes einfo in
    let doc = Cmdliner_def.Exit.info_doc einfo in
    let label = if min = max then strf "%d" min else strf "%d-%d" min max in
    let item = `I (label, Cmdliner_manpage.subst_vars ~errs ~subst buf doc) in
    (Cmdliner_def.Exit.info_docs einfo, item) :: acc
  in
  let exits = Cmdliner_def.Cmd_info.exits @@ Cmdliner_def.Eval.cmd ei in
  let exits = List.sort Cmdliner_def.Exit.info_order exits in
  let exits = List.fold_left add_exit_item [] exits in
  let exits = List.stable_sort by_sec (* sort by section *) exits in
  let boilerplate = if has_sexit then None else Some exit_boilerplate in
  sorted_items_to_blocks ~boilerplate exits

(* Environment doc *)

let env_boilerplate sec = match sec = Cmdliner_manpage.s_environment with
| false -> None
| true -> Some (Cmdliner_manpage.s_environment_intro)

let env_docs ~errs ~subst ~buf ~has_senv ei =
  let add_env_item ~subst (seen, envs as acc) e =
    if Cmdliner_def.Env.Set.mem e seen then acc else
    let seen = Cmdliner_def.Env.Set.add e seen in
    let var = strf "$(b,%s)" @@ esc (Cmdliner_def.Env.info_var e) in
    let var, deprecated = match Cmdliner_def.Env.info_deprecated e with
    | None -> var, "" | Some msg -> "(Deprecated) " ^ var, msg ^ " " in
    let doc = deprecated ^ Cmdliner_def.Env.info_doc e in
    let doc = Cmdliner_manpage.subst_vars ~errs ~subst buf doc in
    let envs = (Cmdliner_def.Env.info_docs e, `I (var, doc)) :: envs in
    seen, envs
  in
  let add_arg_envs a _ acc =
    let envs = Cmdliner_def.Arg_info.doc_envs a in
    let envs = match Cmdliner_def.Arg_info.env a with
    | None -> envs | Some e -> e :: envs
    in
    let subst = Cmdliner_def.Arg_info.doclang_subst ~subst a in
    List.fold_left (add_env_item ~subst) acc envs
  in
  let add_env acc e =
    let subst = Cmdliner_def.Env.doclang_subst ~subst e in
    add_env_item ~subst acc e
  in
  let by_sec_by_rev_name (s0, `I (v0, _)) (s1, `I (v1, _)) =
    let c = compare s0 s1 in
    if c <> 0 then c else compare v1 v0 (* N.B. reverse *)
  in
  (* Arg envs before term envs is important here: if the same is mentioned
     both in an arg and in a term the substs of the arg are allowed. *)
  let args = Cmdliner_def.Cmd_info.args @@ Cmdliner_def.Eval.cmd ei in
  let tenvs = Cmdliner_def.Cmd_info.envs @@ Cmdliner_def.Eval.cmd ei in
  let init = Cmdliner_def.Env.Set.empty, [] in
  let acc = Cmdliner_def.Arg_info.Set.fold add_arg_envs args init in
  let _, envs = List.fold_left add_env acc tenvs in
  let envs = List.sort by_sec_by_rev_name envs in
  let envs = (envs :> (string * Cmdliner_manpage.block) list) in
  let boilerplate = if has_senv then None else Some env_boilerplate in
  sorted_items_to_blocks ~boilerplate envs

(* xref doc *)

let xref_docs ~errs ei =
  let main = Cmdliner_def.Eval.main ei in
  let to_xref = function
  | `Main -> Cmdliner_def.Cmd_info.name main, 1
  | `Tool tool -> tool, 1
  | `Page (name, sec) -> name, sec
  | `Cmd c ->
      (* N.B. we are handling only the first subcommand level here *)
      let cmds = Cmdliner_def.Cmd_info.children main in
      let mname = Cmdliner_def.Cmd_info.name main in
      let is_cmd cmd = Cmdliner_def.Cmd_info.name cmd = c in
      if List.exists is_cmd cmds then strf "%s-%s" mname c, 1 else
      (Format.fprintf errs "xref %s: no such command name@." c; "doc-err", 0)
  in
  let xref_str (name, sec) = strf "%s(%d)" (esc name) sec in
  let xrefs = Cmdliner_def.Cmd_info.man_xrefs @@ Cmdliner_def.Eval.cmd ei in
  let xrefs = match main == Cmdliner_def.Eval.cmd ei with
  | true -> List.filter (fun x -> x <> `Main) xrefs  (* filter out default *)
  | false -> xrefs
  in
  let xrefs = List.fold_left (fun acc x -> to_xref x :: acc) [] xrefs in
  let xrefs = List.(rev_map xref_str (sort rev_compare xrefs)) in
  if xrefs = [] then [] else
  [Cmdliner_manpage.s_see_also, `P (String.concat ", " xrefs)]

(* Man page construction *)

let ensure_s_name ei sm =
  if Cmdliner_manpage.(smap_has_section sm ~sec:s_name) then sm else
  let cmd = Cmdliner_def.Eval.cmd ei in
  let ancestors = Cmdliner_def.Eval.ancestors ei in
  let tname = (deprecated cmd) ^ invocation ~sep:"-" ~ancestors cmd in
  let tdoc = cmd_doc cmd in
  let tagline = if tdoc = "" then "" else strf " - %s" tdoc in
  let tagline = `P (strf "%s%s" tname tagline) in
  Cmdliner_manpage.(smap_append_block sm ~sec:s_name tagline)

let ensure_s_synopsis ei sm =
  if Cmdliner_manpage.(smap_has_section sm ~sec:s_synopsis) then sm else
  let cmd = Cmdliner_def.Eval.cmd ei in
  let ancestors = Cmdliner_def.Eval.ancestors ei in
  let synopsis = `P (synopsis ~ancestors cmd) in
  Cmdliner_manpage.(smap_append_block sm ~sec:s_synopsis synopsis)

let insert_cmd_man_docs ~errs ei sm =
  let buf = Buffer.create 200 in
  let subst = Cmdliner_def.Eval.doclang_subst ei in
  let ins sm (sec, b) = Cmdliner_manpage.smap_append_block sm ~sec b in
  let has_senv = Cmdliner_manpage.(smap_has_section sm ~sec:s_environment) in
  let has_sexit = Cmdliner_manpage.(smap_has_section sm ~sec:s_exit_status) in
  let sm = List.fold_left ins sm (cmd_docs ei) in
  let sm = List.fold_left ins sm (arg_docs ~errs ~subst ~buf ei) in
  let sm = List.fold_left ins sm (exit_docs ~errs ~subst ~buf ~has_sexit ei)in
  let sm = List.fold_left ins sm (env_docs ~errs ~subst ~buf ~has_senv ei) in
  let sm = List.fold_left ins sm (xref_docs ~errs ei) in
  sm

let text ~errs ei =
  let man = Cmdliner_def.Cmd_info.man @@ Cmdliner_def.Eval.cmd ei in
  let sm = Cmdliner_manpage.smap_of_blocks man in
  let sm = ensure_s_name ei sm in
  let sm = ensure_s_synopsis ei sm in
  let sm = insert_cmd_man_docs ei ~errs sm in
  Cmdliner_manpage.smap_to_blocks sm

let title ei =
  let main = Cmdliner_def.Eval.main ei in
  let exec = String.capitalize_ascii (Cmdliner_def.Cmd_info.name main) in
  let cmd = Cmdliner_def.Eval.cmd ei in
  let ancestors = Cmdliner_def.Eval.ancestors ei in
  let name = String.uppercase_ascii (invocation ~sep:"-" ~ancestors cmd) in
  let center_header = esc @@ strf "%s Manual" exec in
  let left_footer =
    let version = match Cmdliner_def.Cmd_info.version main with
    | None -> "" | Some v -> " " ^ v
    in
    esc @@ strf "%s%s" exec version
  in
  name, 1, "", left_footer, center_header

let man ~errs ei = title ei, text ~errs ei

let pp_man ~env ~errs fmt ppf ei =
  let subst = Cmdliner_def.Eval.doclang_subst ei in
  Cmdliner_manpage.print ~env ~errs ~subst fmt ppf (man ~errs ei)

(* Plain synopsis for usage *)

let styled_usage_synopsis ~errs ei =
  let subst = Cmdliner_def.Eval.doclang_subst ei in
  let cmd = Cmdliner_def.Eval.cmd ei in
  let ancestors = Cmdliner_def.Eval.ancestors ei in
  let synopsis = synopsis ~show_help:true ~ancestors cmd in
  Cmdliner_manpage.doc_to_styled ~errs ~subst synopsis
end
module Cmdliner_msg : sig
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

(** Messages for the end-user. *)

(** {1:env_err Environment variable errors} *)

val err_env_parse : Cmdliner_def.Env.info -> err:string -> string

(** {1:pos_err Positional argument errors} *)

val err_pos_excess : string list -> string
val err_pos_misses : Cmdliner_def.Arg_info.t list -> string
val err_pos_parse : Cmdliner_def.Arg_info.t -> err:string -> string

(** {1:opt_err Optional argument errors} *)

val err_flag_value : string -> string -> string
val err_opt_value_missing : string -> string
val err_opt_parse : string -> err:string -> string
val err_opt_repeated : string -> string -> string

(** {1:arg_err Argument errors} *)

val err_arg_missing : Cmdliner_def.Arg_info.t -> string
val err_cmd_missing : dom:string list -> string

(** {1:msgs Other messages} *)

val pp_version : Cmdliner_def.Eval.t Cmdliner_base.Fmt.t


val pp_exec_msg : Cmdliner_def.Eval.t Cmdliner_base.Fmt.t

val pp_err :
  Format.formatter -> Cmdliner_def.Eval.t -> err:string -> unit

val pp_usage_and_err :
  Format.formatter -> Cmdliner_def.Eval.t -> err:string -> unit

val pp_backtrace :
  Format.formatter -> Cmdliner_def.Eval.t -> exn -> Printexc.raw_backtrace ->
  unit
end = struct
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

module Fmt = Cmdliner_base.Fmt

(* Environment variable errors *)

let err_env_parse env ~err =
  let var = Cmdliner_def.Env.info_var env in
  Fmt.str "@[environment variable %a: %s@]" Fmt.code_or_quote var err

(* Positional argument errors *)

let err_pos_excess excess =
  Fmt.str "@[%a, don't know what to do with %a@]"
    Fmt.ereason "too many arguments"
    Fmt.(list ~sep:comma code_or_quote) excess

let err_pos_miss a = match Cmdliner_def.Arg_info.docv a with
| "" -> Fmt.str "@[a required argument is %a@]" Fmt.missing ()
| v -> Fmt.str "@[required argument %a is %a@]" Fmt.code_var v Fmt.missing ()

let err_pos_misses = function
| [] -> assert false
| [a] -> err_pos_miss a
| args ->
    let add_arg acc a = match Cmdliner_def.Arg_info.docv a with
    | "" -> "ARG" :: acc
    | argv -> argv :: acc
    in
    let rev_args = List.sort Cmdliner_def.Arg_info.rev_pos_cli_order args in
    let args = List.fold_left add_arg [] rev_args in
    Fmt.str "@[required arguments %a@ are@ %a@]"
      Fmt.(list ~sep:comma code_var) args Fmt.missing ()

let err_pos_parse a ~err = match Cmdliner_def.Arg_info.docv a with
| "" -> err
| argv ->
    match Cmdliner_def.Arg_info.(pos_len @@ pos_kind a) with
    | Some 1 -> Fmt.str "@[%a argument: %s@]" Fmt.code_var argv err
    | None | Some _ -> Fmt.str "@[%a arguments: %s@]" Fmt.code_var argv err

(* Optional argument errors *)

let err_flag_value flag v =
  Fmt.str "@[option %a is a flag, it@ %a@ %a@]"
    Fmt.code_or_quote flag Fmt.ereason "cannot take the argument"
    Fmt.code_or_quote v

let err_opt_value_missing f =
  Fmt.str "@[option %a %a@]" Fmt.code_or_quote f Fmt.ereason "needs an argument"

let err_opt_parse f ~err =
  Fmt.str "@[option %a: %a@]" Fmt.code_or_quote f Fmt.styled_text err

let err_opt_repeated f f' =
  if f = f' then
    Fmt.str "@[option %a %a@]"
      Fmt.code_or_quote f Fmt.ereason "cannot be repeated"
  else
  Fmt.str "@[options %a and %a@ %a@]"
    Fmt.code_or_quote f Fmt.code_or_quote f'
    Fmt.ereason "cannot be present at the same time"

(* Argument errors *)

let err_arg_missing a =
  if Cmdliner_def.Arg_info.is_pos a then err_pos_miss a else
  Fmt.str "@[required option %a is %a@]"
    Fmt.code (Cmdliner_def.Arg_info.opt_name_sample a) Fmt.missing ()

let err_cmd_missing ~dom =
  Fmt.str "@[required %a name is %a,@ must@ be@ %a@]"
    Fmt.code_var "COMMAND" Fmt.missing () Cmdliner_base.pp_alts dom

(* Other messages *)

let pp_version ppf ei =
  match Cmdliner_def.Cmd_info.version (Cmdliner_def.Eval.main ei) with
  | None -> assert false
  | Some v -> Fmt.pf ppf "@[%s@]@." v

let exec_name ei = Cmdliner_def.Cmd_info.name (Cmdliner_def.Eval.main ei)

let pp_exec_msg ppf ei = Fmt.pf ppf "%s:" (exec_name ei)

let pp_err ppf ei ~err =
  Fmt.pf ppf "@[%a @[%a@]@]@." pp_exec_msg ei Fmt.styled_text err

let pp_usage_and_err ppf ei ~err =
  Fmt.pf ppf "@[Usage: @[%a@]@]@."
    Fmt.styled_text (Cmdliner_docgen.styled_usage_synopsis ~errs:ppf ei);
  pp_err ppf ei ~err

let pp_backtrace ppf ei e bt =
  let bt = Printexc.raw_backtrace_to_string bt in
  let bt =
    let len = String.length bt in
    if len > 0 then String.sub bt 0 (len - 1) (* remove final '\n' *) else bt
  in
  Fmt.pf ppf "@[%a @[internal error, %a:@\n%a@]@]@."
    pp_exec_msg ei
    Fmt.ereason "uncaught exception"
    Fmt.lines (String.concat "\n" [Printexc.to_string e; bt])
end
module Cmdliner_term : sig
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

(** Terms *)

type term_escape =
  [ `Error of bool * string
  | `Help of Cmdliner_manpage.format * string option ]

type 'a parser =
  Cmdliner_def.Eval.t -> Cmdliner_def.Cline.t ->
  ('a, [ `Parse of string | term_escape ]) result
(** Type type for command line parser. given static information about
    the command line and a command line to parse returns an OCaml value. *)

type +'a t = 'a Cmdliner_def.Term.t
(** The type for terms. The list of arguments it can parse and the parsing
    function that does so. *)

val make : Cmdliner_def.Arg_info.Set.t -> 'a parser -> 'a t
val argset : 'a t -> Cmdliner_def.Arg_info.Set.t
val parser : 'a t -> 'a parser

val const : 'a -> 'a t
val app : ('a -> 'b) t -> 'a t -> 'b t
val map : ('a -> 'b) -> 'a t -> 'b t
val product : 'a t -> 'b t  -> ('a * 'b) t

module Syntax : sig
  val ( let+ ) : 'a t -> ('a -> 'b) -> 'b t
  val ( and+ ) : 'a t -> 'b t -> ('a * 'b) t
end

val ( $ ) : ('a -> 'b) t -> 'a t -> 'b t

type 'a ret = [ `Ok of 'a | term_escape ]

val ret : 'a ret t -> 'a t
val term_result : ?usage:bool -> ('a, [`Msg of string]) result t -> 'a t
val term_result' : ?usage:bool -> ('a, string) result t -> 'a t
val cli_parse_result : ('a, [`Msg of string]) result t -> 'a t
val cli_parse_result' : ('a, string) result t -> 'a t
val main_name : string t
val choice_names : string list t
val with_used_args : 'a t -> ('a * string list) t
val env : (string -> string option) t
end = struct
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

type term_escape = Cmdliner_def.Term.escape
type 'a parser = 'a Cmdliner_def.Term.parser
type +'a t = 'a Cmdliner_def.Term.t

let make args p = (args, p)
let argset (args, _) = args
let parser (_, parser) = parser

let const v = Cmdliner_def.Arg_info.Set.empty, (fun _ _ -> Ok v)
let app (args_f, f) (args_v, v) =
  Cmdliner_def.Arg_info.Set.union args_f args_v,
  fun ei cl -> match (f ei cl) with
  | Error _ as e -> e
  | Ok f ->
      match v ei cl with
      | Error _ as e -> e
      | Ok v -> Ok (f v)

let map f v = app (const f) v
let product v0 v1 = app (app (const (fun x y -> (x, y))) v0) v1

module Syntax = struct
  let ( let+ ) v f = map f v
  let ( and+ ) = product
end

(* Terms *)

let ( $ ) = app

type 'a ret = [ `Ok of 'a | term_escape ]

let ret (al, v) =
  al, fun ei cl -> match v ei cl with
  | Ok (`Ok v) -> Ok v
  | Ok (`Error _ as err) -> Error err
  | Ok (`Help _ as help) -> Error help
  | Error _ as e -> e

let term_result ?(usage = false) (al, v) =
  al, fun ei cl -> match v ei cl with
  | Ok (Ok _ as ok) -> ok
  | Ok (Error (`Msg e)) -> Error (`Error (usage, e))
  | Error _ as e -> e

let term_result' ?usage t =
  let wrap = app (const (Result.map_error (fun e -> `Msg e))) t in
  term_result ?usage wrap

let cli_parse_result (al, v) =
  al, fun ei cl -> match v ei cl with
  | Ok (Ok _ as ok) -> ok
  | Ok (Error (`Msg e)) -> Error (`Parse e)
  | Error _ as e -> e

let cli_parse_result' t =
  let wrap = app (const (Result.map_error (fun e -> `Msg e))) t in
  cli_parse_result wrap

let main_name =
  Cmdliner_def.Arg_info.Set.empty,
  (fun ei _ -> Ok (Cmdliner_def.Cmd_info.name @@ Cmdliner_def.Eval.main ei))

let choice_names =
  Cmdliner_def.Arg_info.Set.empty,
  (fun ei _ ->
     (* N.B. this keeps everything backward compatible. We return the command
        names of main's children *)
     let name t = Cmdliner_def.Cmd_info.name t in
     let choices =
       Cmdliner_def.Cmd_info.children (Cmdliner_def.Eval.main ei)
     in
     Ok (List.rev_map name choices))

let with_used_args (al, v) : (_ * string list) t =
  al, fun ei cl ->
    match v ei cl with
    | Ok x ->
        let actual_args arg_info _ acc =
          let args = Cmdliner_def.Cline.actual_args cl arg_info in
          List.rev_append args acc
        in
        let used =
          List.rev (Cmdliner_def.Arg_info.Set.fold actual_args al [])
        in
        Ok (x, used)
    | Error _ as e -> e


let env =
  Cmdliner_def.Arg_info.Set.empty,
  (fun ei _ -> Ok (Cmdliner_def.Eval.env_var ei))
end
module Cmdliner_completion : sig
(*---------------------------------------------------------------------------
   Copyright (c) 2025 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

val output :
  out_ppf:Format.formatter -> err_ppf:Format.formatter ->
  Cmdliner_def.Eval.t -> Cmdliner_def.Complete.t -> Cmdliner_def.Cline.t ->
  unit
end = struct
(*---------------------------------------------------------------------------
   Copyright (c) 2025 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

(* Output protocol  *)

let cons_if b v l = if b then v :: l else l

type directive =
| Dirs | Files | Group of string * (string * string) list
| Restart | Message of string

let pp_protocol ppf dirs =
  let pp_line ppf s = Cmdliner_base.Fmt.(string ppf s; cut ppf ()) in
  let pp_text ppf s = Cmdliner_base.Fmt.(pf ppf "@[%a@]@," styled_text s) in
  let vnum = 1 (* Protocol version number *) in
  let pp_item ppf (name, doc) =
    pp_line ppf "item";
    pp_line ppf name; pp_text ppf doc;
    pp_line ppf "item-end";
  in
  let pp_dir ppf = function
  | Dirs -> pp_line ppf "dirs"
  | Files -> pp_line ppf "files"
  | Restart -> pp_line ppf "restart"
  | Group (name, items) ->
      pp_line ppf "group";
      pp_line ppf name;
      Cmdliner_base.Fmt.(list ~sep:nop pp_item) ppf items;
  | Message msg ->
      pp_line ppf "message"; pp_text ppf msg; pp_line ppf "message-end"
  in
  Cmdliner_base.Fmt.pf ppf "@[<v>%d@,%a@]" vnum
    Cmdliner_base.Fmt.(list ~sep:nop pp_dir) dirs

let add_subcommands_group ~err_ppf ~subst eval comp directives =
  if not (Cmdliner_def.Complete.subcmds comp) then directives else
  let prefix = Cmdliner_def.Complete.token comp in
  let maybe_item cmd =
    let name = Cmdliner_def.Cmd_info.name cmd in
    if not (Cmdliner_base.string_starts_with ~prefix name) then None else
    (* FIXME subst is wrong here. *)
    let doc = Cmdliner_def.Cmd_info.styled_doc ~errs:err_ppf ~subst cmd in
    Some (name, doc)
  in
  let subcmds = Cmdliner_def.Eval.subcmds eval in
  Group ("Subcommands", List.filter_map maybe_item subcmds) :: directives

let add_options_group ~err_ppf ~subst eval comp directives =
  let prefix = Cmdliner_def.Complete.token comp in
  let maybe_items arg_info =
    let names = Cmdliner_def.Arg_info.opt_names arg_info in
    let subst = Cmdliner_def.Arg_info.doclang_subst ~subst arg_info in
    let doc = Cmdliner_def.Arg_info.styled_doc ~errs:err_ppf ~subst arg_info in
    let add_name n =
      if not (Cmdliner_base.string_starts_with ~prefix n) then None else
      Some (n, doc)
    in
    List.filter_map add_name names
  in
  let maybe_opt = prefix = "" || prefix.[0] = '-' in
  if Cmdliner_def.Complete.after_dashdash comp || not maybe_opt
  then directives else
  let cmd_info = Cmdliner_def.Eval.cmd eval in
  let set = Cmdliner_def.Cmd_info.args cmd_info in
  if Cmdliner_def.Arg_info.Set.is_empty set then directives else
  let options = Cmdliner_def.Arg_info.Set.elements set in
  Group ("Options", List.concat (List.map maybe_items options)) :: directives

let add_argument_value_directives directives eval arg_info comp cline =
  let (Conv conv) =
    let arg_infos = Cmdliner_def.Cmd_info.args (Cmdliner_def.Eval.cmd eval) in
    Option.get (Cmdliner_def.Arg_info.Set.find_opt arg_info arg_infos)
  in
  let value_dirs =
    let completion = Cmdliner_def.Arg_conv.completion conv in
    match Cmdliner_def.Arg_completion.complete completion with
    | Complete (ctx, func) ->
        let ctx = match ctx with
        | None -> None
        | Some ctx ->
            match (Cmdliner_term.parser ctx) eval cline with
            | Ok ctx -> Some ctx
            | Error _ -> None
            | exception exn -> None
        in
        func ctx ~token:(Cmdliner_def.Complete.token comp)
  in
  match value_dirs with
  | Error msg -> `Directives [Message msg]
  | Ok ds ->
      let pp = Cmdliner_def.Arg_conv.pp conv in
      let rec loop values msgs ~files ~dirs ~restart ~raw = function
      | [] ->
          begin match raw with
          | Some r -> `Raw r
          | None ->
              if Cmdliner_def.Complete.after_dashdash comp && restart
              then `Directives [Restart] else
              let dd =
                cons_if dirs Dirs @@
                cons_if files Files @@
                cons_if (values <> []) (Group ("Values", List.rev values)) []
              in
              `Directives (List.rev_append msgs (List.rev_append dd directives))
          end
      | d :: ds ->
          match d with
          | Cmdliner_def.Arg_completion.String (s, doc) ->
              loop ((s, doc) :: values) msgs ~files ~dirs ~restart ~raw ds
          | Value (v, doc) ->
              let s = Cmdliner_base.Fmt.str "@[<h>%a@]" pp v in
              loop ((s, doc) :: values) msgs ~files ~dirs ~restart ~raw ds
          | Files -> loop values msgs ~files:true ~dirs ~restart ~raw ds
          | Dirs -> loop values msgs ~files ~dirs:true ~restart ~raw ds
          | Restart -> loop values msgs ~files ~dirs ~restart:true ~raw ds
          | Message msg ->
              loop values (Message msg :: msgs) ~files ~dirs ~restart ~raw ds
          | Raw r -> loop values msgs ~files ~dirs ~restart ~raw:(Some r) ds
      in
      loop [] [] ~files:false ~dirs:false ~restart:false ~raw:None ds

let output ~out_ppf ~err_ppf eval comp cline =
  let subst = Cmdliner_def.Eval.doclang_subst eval in
  let dirs = add_subcommands_group ~err_ppf ~subst eval comp [] in
  let res = match Cmdliner_def.Complete.kind comp with
  | Opt_value arg_info ->
      add_argument_value_directives dirs eval arg_info comp cline
  | Opt_name_or_pos_value arg_info ->
      let dirs = add_options_group ~err_ppf ~subst eval comp dirs in
      add_argument_value_directives dirs eval arg_info comp cline
  | Opt_name ->
      `Directives (add_options_group ~err_ppf ~subst eval comp dirs)
  in
  if out_ppf == Format.std_formatter
  then set_binary_mode_out stdout true;
  match res with
  | `Raw raw -> Cmdliner_base.Fmt.pf out_ppf "%s@?" raw
  | `Directives dirs -> Cmdliner_base.Fmt.pf out_ppf "%a@?" pp_protocol dirs
end
module Cmdliner_cmd : sig
(*---------------------------------------------------------------------------
   Copyright (c) 2022 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

(** Commands and their information. *)

type info = Cmdliner_def.Cmd_info.t

val info :
  ?deprecated:string -> ?man_xrefs:Cmdliner_manpage.xref list ->
  ?man:Cmdliner_manpage.block list -> ?envs:Cmdliner_def.Env.info list ->
  ?exits:Cmdliner_def.Exit.info list -> ?sdocs:string -> ?docs:string ->
  ?doc:string -> ?version:string -> string -> info

type 'a t =
| Cmd of info * 'a Cmdliner_term.parser
| Group of info * ('a Cmdliner_term.parser option * 'a t list)

val make : info -> 'a Cmdliner_term.t -> 'a t
val v : info -> 'a Cmdliner_term.t -> 'a t
val group : ?default:'a Cmdliner_term.t -> info -> 'a t list -> 'a t
val name : 'a t -> string
val name_trie : 'a t list -> 'a t Cmdliner_trie.t
val list_names : 'a t list -> string list
val get_info : 'a t -> info
val get_children_infos : 'a t -> info list
end = struct
(*---------------------------------------------------------------------------
   Copyright (c) 2022 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

(* Commands *)

type info = Cmdliner_def.Cmd_info.t
let info = Cmdliner_def.Cmd_info.make

type 'a t =
| Cmd of info * 'a Cmdliner_term.parser
| Group of info * ('a Cmdliner_term.parser option * 'a t list)

let make info t =
  let info = Cmdliner_def.Cmd_info.add_args info (Cmdliner_term.argset t) in
  Cmd (info, Cmdliner_term.parser t)

let v = make

let get_info = function Cmd (info, _) | Group (info, _) -> info
let get_children_infos = function
| Cmd _ -> [] | Group (_, (_, cs)) -> List.map get_info cs

let group ?default info cmds =
  let args, parser = match default with
  | None -> None, None
  | Some t -> Some (Cmdliner_term.argset t), Some (Cmdliner_term.parser t)
  in
  let children = List.map get_info cmds in
  let info = Cmdliner_def.Cmd_info.with_children info ~args ~children in
  Group (info, (parser, cmds))

let name c = Cmdliner_def.Cmd_info.name (get_info c)

let name_trie cmds =
  let add acc cmd =
    let info = get_info cmd in
    let name = Cmdliner_def.Cmd_info.name info in
    match Cmdliner_trie.add acc name cmd with
    | `New t -> t
    | `Replaced (cmd', _) ->
        let info' = get_info cmd' and kind = "command" in
        invalid_arg @@
        Cmdliner_base.err_multi_def ~kind name
          Cmdliner_def.Cmd_info.doc info info'
  in
  List.fold_left add Cmdliner_trie.empty cmds

let list_names cmds =
  let cmd_name c = Cmdliner_def.Cmd_info.name (get_info c) in
  List.sort String.compare (List.rev_map cmd_name cmds)
end
module Cmdliner_cline : sig
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

(** Command lines. *)

val is_opt : string -> bool
val has_complete_prefix : string -> bool
val get_token_to_complete : string -> string

(** {1:cli Command lines} *)

val create :
  ?peek_opts:bool -> legacy_prefixes:bool -> for_completion:bool ->
  Cmdliner_def.Arg_info.Set.t -> string list ->
  [ `Ok of Cmdliner_def.Cline.t
  | `Complete of Cmdliner_def.Complete.t * Cmdliner_def.Cline.t
  | `Error of string * Cmdliner_def.Cline.t ]
end = struct
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

(* A command line stores pre-parsed information about the command
   line's arguments in a more structured way. Given the
   Cmdliner_def.Arg_info.t values mentioned in a term and Sys.argv
   (without exec name) we parse the command line into
   [Cmdliner_def.Cline.t] which is map of [Cmdliner_def.Arg_info.t]
   values to [Cmdliner_def.Cline.arg] values. This map is used by the
   term's closures to retrieve and convert command line arguments (see
   the [Cmdliner_arg] module). *)

(* Completion *)

let complete_prefix = "--__complete="
let has_complete_prefix s =
  Cmdliner_base.string_starts_with ~prefix:complete_prefix s

let get_token_to_complete s =
  Cmdliner_base.string_drop_first (String.length complete_prefix) s

let is_opt_to_complete s = (* assert (has_complete_prefix s) *)
  String.length s > String.length complete_prefix &&
  s.[String.length complete_prefix] = '-'

let maybe_token_to_complete ~for_completion s =
  if not for_completion || not (has_complete_prefix s) then None else
  Some (get_token_to_complete s)

(* Command lines *)

let err_multi_opt_name_def name arg_info arg_info' =
  Cmdliner_base.err_multi_def ~kind:"option name" name
    Cmdliner_def.Arg_info.doc arg_info arg_info'

let arg_info_indexes arg_infos =
  (* from [args] returns a trie mapping the names of optional arguments to
     their arg_info, a list with all arg_info for positional arguments and
     a Cmdliner_def.Cline.t mapping each arg_info to an empty [arg]. *)
  let rec loop optidx posidx cline = function
  | [] -> optidx, posidx, cline
  | arg_info :: l ->
      match Cmdliner_def.Arg_info.is_pos arg_info with
      | true ->
          let cline = Cmdliner_def.Cline.add arg_info (P []) cline in
          loop optidx (arg_info :: posidx) cline l
      | false ->
          let add t name = match Cmdliner_trie.add t name arg_info with
          | `New t -> t
          | `Replaced (a', _) ->
              invalid_arg (err_multi_opt_name_def name arg_info a')
          in
          let names = Cmdliner_def.Arg_info.opt_names arg_info in
          let optidx = List.fold_left add optidx names in
          let cline = Cmdliner_def.Cline.add arg_info (O []) cline in
          loop optidx posidx cline l
  in
  let cline = Cmdliner_def.Cline.empty in
  let arg_infos = Cmdliner_def.Arg_info.Set.elements arg_infos in
  loop Cmdliner_trie.empty [] cline arg_infos

(* Optional argument parsing *)

(* Note on option completion. Technically when trying to complete an
   option we could try to avoid mentioning names that have already be
   mentioned and that are not repeatable. Sometimes not being able to
   complete what we know exists ends up being more confusing than
   enlightening so we don't do that for now.

   Also the code is quite messy, perhaps we should cleanly separate
   parsing for completion and parsing for evaluation. *)

let is_opt s = String.length s > 1 && s.[0] = '-'
let is_short_opt s = String.length s = 2 && s.[0] = '-'

let parse_opt_arg s =
  (* (name, value) of opt arg, assert len > 1. except if complete *)
  let is_completion = has_complete_prefix s in
  let s = if is_completion then get_token_to_complete s else s in
  let l = String.length s in
  if l <= 1 then "-", None, is_completion else
  if s.[1] <> '-' then (* short opt *)
    if l = 2 then s, None, is_completion else
    String.sub s 0 2, Some (String.sub s 2 (l - 2)) (* with glued opt arg *),
    is_completion
  else try (* long opt *)
    let i = String.index s '=' in
    String.sub s 0 i, Some (String.sub s (i + 1) (l - i - 1)), is_completion
  with Not_found -> s, None, is_completion

let hint_matching_opt optidx s =
  (* hint option names that could match [s] in [optidx]. *)
  if String.length s <= 2 then [] else
  let short_opt, long_opt =
    if s.[1] <> '-'
    then s, Printf.sprintf "-%s" s
    else String.sub s 1 (String.length s - 1), s
  in
  let short_opt, _, _ = parse_opt_arg short_opt in
  let long_opt, _, _ = parse_opt_arg long_opt in
  let all = Cmdliner_trie.ambiguities optidx "-" in
  match List.mem short_opt all, Cmdliner_base.suggest long_opt all with
  | false, [] -> []
  | false, l -> l
  | true, [] -> [short_opt]
  | true, l -> if List.mem short_opt l then l else short_opt :: l

let parse_opt_value ~for_completion cline arg_info name value args =
  (* Either we got a value glued in [value] or we need to get one in [args]
     in this case we need to take care of a possible completion token *)
  match Cmdliner_def.Arg_info.opt_kind arg_info with
  | Flag -> (* Flags have no values but we may get dash sharing in [value] *)
      begin match value with
      | None -> None, None, args
      | Some v when is_short_opt name -> (* short flag dash sharing *)
          None, None, ("-" ^ v) :: args
      | Some _ -> (* an error but this is reported during typed parsing *)
          None, value, args
      end
  | _ ->
      match value with
      | Some _ -> None, value, args
      | None -> (* Get it from the next argument. *)
          match args with
          | [] -> None, None, args
          | v :: rest when for_completion && has_complete_prefix v ->
              let v = get_token_to_complete v in
              if is_opt v then (* not an option value *) None, None, args else
              let comp =
                Cmdliner_def.Complete.make ~token:v (Opt_value arg_info)
              in
              Some comp, None, rest
          | v :: rest ->
              if is_opt v then None, None, args else None, Some v, rest

let try_complete_opt_value cline arg_info name value args =
  (* At that point we found a matching option name so this should be mostly
     about completing a glued option value, but there are twists. *)
  match Cmdliner_def.Arg_info.opt_kind arg_info with
  | Cmdliner_def.Arg_info.Flag ->
      begin match value with
      | Some v when is_short_opt name ->
          (* short flag dash sharing, push the completion *)
          let args = (complete_prefix ^ "-" ^ v) :: args in
          None, None, args
      | Some v ->
          (* This is actually a parse error, flags have no value.  We
             make it an option completion but the completions will
             eventually be empty (the prefix won't match) *)
          Some (Cmdliner_def.Complete.make ~token:(name ^ v) Opt_name),
          None, args
      | None ->
          (* We have in fact a fully completed flag turn it into an
             option completion. *)
          Some (Cmdliner_def.Complete.make ~token:name Opt_name), None, args
      end
  | _ ->
      begin match value with
      | Some token ->
          Some (Cmdliner_def.Complete.make ~token (Opt_value arg_info)), None,
          args
      | None ->
          (* We have a fully completed option name, we don't try to
             lookup what happens in the next argument which should
             hold the value if any, we just turn it into an option
             completion. *)
          Some (Cmdliner_def.Complete.make ~token:name Opt_name), None, args
      end

let parse_opt_args
    ~peek_opts ~legacy_prefixes ~for_completion optidx cline args
  =
  (* returns an updated [cline] cmdline according to the options found in [args]
     with the trie index [optidx]. Positional arguments are returned in order
     in a list. *)
  let rec loop errs k comp cline pargs = function
  | [] -> List.rev errs, comp, cline, false, List.rev pargs
  | "--" :: args ->
      List.rev errs, comp, cline, true, (List.rev_append pargs args)
  | s :: args ->
      let do_parse =
        is_opt s &&
        (if not for_completion then true else
         if not (has_complete_prefix s) then true else
         is_opt_to_complete s)
      in
      if not do_parse then loop errs (k + 1) comp cline (s :: pargs) args else
      let name, value, is_completion = parse_opt_arg s in
      match Cmdliner_trie.find ~legacy_prefixes optidx name with
      | Ok arg_info ->
          let acomp, value, args =
            if is_completion
            then try_complete_opt_value cline arg_info name value args
            else parse_opt_value ~for_completion cline arg_info name value args
          in
          let comp = match acomp with Some _ -> acomp | None -> comp in
          let arg : Cmdliner_def.Cline.arg =
            O ((k, name, value) ::
               Cmdliner_def.Cline.get_opt_arg cline arg_info)
          in
          let cline = Cmdliner_def.Cline.add arg_info arg cline in
          loop errs (k + 1) comp cline pargs args
      | Error `Not_found when for_completion ->
          if not is_completion then
            (* Drop the data, if the user thought this was an opt with
               an argument this may confuse positional args but there's
               not much we can do. *)
            loop errs (k + 1) comp cline pargs args
          else
          let token = name ^ Option.value ~default:"" value in
          let comp = Some (Cmdliner_def.Complete.make ~token Opt_name) in
          loop errs (k + 1) comp cline pargs args
      | Error `Not_found when peek_opts ->
          loop errs (k + 1) comp cline pargs args
      | Error `Not_found ->
          let hints = hint_matching_opt optidx s in
          let err = Cmdliner_base.err_unknown ~kind:"option" ~hints name in
          loop (err :: errs) (k + 1) comp cline pargs args
      | Error `Ambiguous (* Only on legacy prefixes *) ->
          let ambs = Cmdliner_trie.ambiguities optidx name in
          let ambs = List.sort compare ambs in
          let err = Cmdliner_base.err_ambiguous ~kind:"option" name ~ambs in
          loop (err :: errs) (k + 1) comp cline pargs args
  in
  let errs, comp, cline, has_dashdash, pargs = loop [] 0 None cline [] args in
  if errs = [] then Ok (comp, cline, has_dashdash, pargs) else
  match comp with
  | Some _ -> Ok (comp, cline, has_dashdash, pargs)
  | None ->
      let err = String.concat "\n" errs in
      Error (err, cline, has_dashdash, pargs)

(* Positional argument parsing *)

let take_range ~for_completion start stop l =
  let rec loop i comp acc = function
  | [] -> comp, (List.rev acc)
  | v :: vs ->
      if i < start then loop (i + 1) comp acc vs else
      if i <= stop then match maybe_token_to_complete ~for_completion v with
      | Some _ as comp -> loop (i + 1) comp (v :: acc) vs
      | None -> loop (i + 1) comp (v :: acc) vs
      else comp, List.rev acc
  in
  loop 0 None [] l

let parse_pos_args ~for_completion posidx comp cline ~has_dashdash pargs =
  (* returns an updated [cline] cmdline in which each positional arg mentioned
     in the list index [posidx], is given a value according the list
     of positional arguments values [pargs]. *)
  if pargs = [] then
    let misses = List.filter Cmdliner_def.Arg_info.is_req posidx in
    if misses = [] then Ok (comp, cline) else
    match comp with
    | Some _ -> Ok (comp, cline)
    | None -> Error (Cmdliner_msg.err_pos_misses misses, cline)
  else
  let last = List.length pargs - 1 in
  let pos rev k = if rev then last - k else k in
  let rec loop misses comp cline max_spec = function
  | [] -> misses, comp, cline, max_spec
  | arg_info :: al ->
      let apos = Cmdliner_def.Arg_info.pos_kind arg_info in
      let rev = Cmdliner_def.Arg_info.pos_rev apos in
      let start = pos rev (Cmdliner_def.Arg_info.pos_start apos) in
      let stop = match Cmdliner_def.Arg_info.pos_len apos with
      | None -> pos rev last
      | Some n -> pos rev (Cmdliner_def.Arg_info.pos_start apos + n - 1)
      in
      let start, stop = if rev then stop, start else start, stop in
      let comp, args = match take_range ~for_completion start stop pargs with
      | None, args -> comp, args
      | Some token, args ->
          let comp =
            Cmdliner_def.Complete.make ~after_dashdash:has_dashdash ~token
              (Opt_name_or_pos_value arg_info)
          in
          Some comp, args
      in
      let max_spec = max stop max_spec in
      let cline = Cmdliner_def.Cline.add arg_info (P args) cline in
      let misses = match Cmdliner_def.Arg_info.is_req arg_info && args = [] with
      | true -> arg_info :: misses
      | false -> misses
      in
      loop misses comp cline max_spec al
  in
  let misses, comp, cline, max_spec = loop [] comp cline (-1) posidx in
  if misses <> [] then begin
    if Option.is_some comp then Ok (comp, cline) else
    Error (Cmdliner_msg.err_pos_misses misses, cline)
  end else
  if last <= max_spec then Ok (comp, cline) else
  if Option.is_some comp then Ok (comp, cline) else
  let comp, excess = take_range ~for_completion (max_spec + 1) last pargs in
  match comp with
  | None -> Error (Cmdliner_msg.err_pos_excess excess, cline)
  | Some token ->
      let comp =
        Cmdliner_def.Complete.make ~after_dashdash:has_dashdash ~token Opt_name
      in
      Ok (Some comp, cline)

let create ?(peek_opts = false) ~legacy_prefixes ~for_completion al args =
  let optidx, posidx, cline = arg_info_indexes al in
  match
    parse_opt_args ~for_completion ~peek_opts ~legacy_prefixes optidx cline args
  with
  | Ok (comp, cline, _has_dashdash, _pargs) when peek_opts ->
      begin match comp with
      | None -> `Ok cline
      | Some comp -> `Complete (comp, cline)
      end
  | Ok (comp, cline, has_dashdash, pargs) ->
      begin match
        parse_pos_args ~for_completion posidx comp cline ~has_dashdash pargs
      with
      | Ok (None, _) | Error _ when for_completion ->
          (* Normally we should have found a completion token This
             may fail to happen if pos args are ill defined: we may miss the
             completion token. Just make sure we do a completion. *)
          begin match List.find_opt has_complete_prefix pargs with
          | None -> assert false
          | Some arg ->
              match maybe_token_to_complete ~for_completion:true arg with
              | None -> assert false
              | Some token ->
                  let comp =
                    Cmdliner_def.Complete.make
                      ~after_dashdash:has_dashdash ~token Opt_name
                  in
                  `Complete (comp, cline)
          end
      | Ok (None, cline) -> `Ok cline
      | Ok (Some comp, cline) -> `Complete (comp, cline)
      | Error v -> `Error v
      end
  | Error (errs, cline, has_dashdash, pargs) ->
      match
        parse_pos_args ~for_completion posidx None cline ~has_dashdash pargs
      with
      | Ok (Some comp, cline) -> `Complete (comp, cline)
      | _ -> `Error (errs, cline)
end
module Cmdliner_arg : sig
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

(** Command line arguments as terms. *)

(* Converters *)

type 'a conv

module Completion : sig
  type 'a directive

  val value : ?doc:string -> 'a -> 'a directive
  val string : ?doc:string -> string -> 'a directive
  val files : 'a directive
  val dirs : 'a directive
  val restart : 'a directive
  val message : string -> 'a directive
  val raw : string -> 'a directive

  type ('ctx, 'a) func =
    'ctx option -> token:string -> ('a directive list, string) result

  type 'a complete =
  | Complete : 'ctx Cmdliner_term.t option * ('ctx, 'a) func -> 'a complete

  type 'a t

  val make : ?context:'ctx Cmdliner_term.t -> ('ctx, 'a) func -> 'a t

  val complete : 'a t -> 'a complete
  val complete_none : 'a t
  val complete_files : 'a t
  val complete_dirs : 'a t
  val complete_paths : 'a t
  val complete_restart : 'a t
end

module Conv : sig
  type 'a parser = string -> ('a, string) result
  type 'a fmt = Format.formatter -> 'a -> unit
  type 'a t = 'a conv
  val make :
    ?completion:'a Completion.t -> docv:string -> parser:'a parser ->
    pp:'a fmt -> unit -> 'a t

  val of_conv :
    ?completion:'a Completion.t -> ?docv:string -> ?parser:'a parser ->
    ?pp:'a fmt -> 'a t -> 'a t

  val docv : 'a conv -> string
  val parser : 'a conv -> 'a parser
  val pp : 'a conv -> 'a fmt
  val completion : 'a t -> 'a Completion.t
end

val some : ?none:string -> 'a conv -> 'a option conv
val some' : ?none:'a -> 'a conv -> 'a option conv

(* Arguments *)

type 'a t = 'a Cmdliner_term.t

type info
val info :
  ?deprecated:string -> ?absent:string -> ?docs:string ->
  ?doc_envs:Cmdliner_def.Env.info list -> ?docv:string -> ?doc:string ->
  ?env:Cmdliner_def.Env.info -> string list -> info

val ( & ) : ('a -> 'b) -> 'a -> 'b

val flag : info -> bool t
val flag_all : info -> bool list t
val vflag : 'a -> ('a * info) list -> 'a t
val vflag_all : 'a list -> ('a * info) list -> 'a list t
val opt : ?vopt:'a -> 'a conv -> 'a -> info -> 'a t
val opt_all : ?vopt:'a -> 'a conv -> 'a list -> info -> 'a list t

val pos : ?rev:bool -> int -> 'a conv -> 'a -> info -> 'a t
val pos_all : 'a conv -> 'a list -> info -> 'a list t
val pos_left : ?rev:bool -> int -> 'a conv -> 'a list -> info -> 'a list t
val pos_right : ?rev:bool -> int -> 'a conv -> 'a list -> info -> 'a list t

(* As terms *)

val value : 'a t -> 'a Cmdliner_term.t
val required : 'a option t -> 'a Cmdliner_term.t
val non_empty : 'a list t -> 'a list Cmdliner_term.t
val last : 'a list t -> 'a Cmdliner_term.t

(* Predefined arguments *)

val man_format : Cmdliner_manpage.format Cmdliner_term.t
val stdopt_version : docs:string -> bool Cmdliner_term.t
val stdopt_help : docs:string -> Cmdliner_manpage.format option Cmdliner_term.t

(* Predifined converters *)

val bool : bool conv
val char : char conv
val int : int conv
val nativeint : nativeint conv
val int32 : int32 conv
val int64 : int64 conv
val float : float conv
val string : string conv
val enum : ?docv:string -> (string * 'a) list -> 'a conv
val path : string conv
val filepath : string conv
val dirpath : string conv
val file : string conv
val dir : string conv
val non_dir_file : string conv
val list : ?sep:char -> 'a conv -> 'a list conv
val array : ?sep:char -> 'a conv -> 'a array conv
val pair : ?sep:char -> 'a conv -> 'b conv -> ('a * 'b) conv
val t2 : ?sep:char -> 'a conv -> 'b conv -> ('a * 'b) conv
val t3 : ?sep:char -> 'a conv ->'b conv -> 'c conv -> ('a * 'b * 'c) conv
val t4 :
  ?sep:char -> 'a conv ->'b conv -> 'c conv -> 'd conv ->
  ('a * 'b * 'c * 'd) conv

val doc_quote : string -> string
val doc_alts : ?quoted:bool -> string list -> string
val doc_alts_enum : ?quoted:bool -> (string * 'a) list -> string

(* Deprecated *)

type 'a printer = Format.formatter -> 'a -> unit
val conv' : ?docv:string -> 'a Conv.parser * 'a Conv.fmt -> 'a conv
val conv :
  ?docv:string -> (string -> ('a, [`Msg of string]) result) * 'a Conv.fmt ->
  'a conv

val conv_parser : 'a conv -> (string -> ('a, [`Msg of string]) result)
val conv_printer : 'a conv -> 'a printer
val conv_docv : 'a conv -> string
val parser_of_kind_of_string :
  kind:string -> (string -> 'a option) ->
  (string -> ('a, [`Msg of string]) result)
end = struct
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

let rev_compare n0 n1 = compare n1 n0

(* Documentation formatting helpers *)

module Fmt = Cmdliner_base.Fmt

let doc_quote = Cmdliner_base.quote
let doc_alts = Cmdliner_base.alts_str
let doc_alts_enum ?quoted enum = doc_alts ?quoted (List.map fst enum)
let str_of_pp pp v = pp Format.str_formatter v; Format.flush_str_formatter ()

(* Invalid_argument strings *)

let err_not_opt = "Option argument without name"
let err_not_pos = "Positional argument with a name"
let err_incomplete_enum ss =
  Printf.sprintf
    "Arg.enum: missing printable string for a value, other strings are: %s"
    (String.concat ", " ss)

(* Parse error strings *)

let err_no kind s = Fmt.str "no %a %s" Fmt.code_or_quote s kind
let err_not_dir s =
  Fmt.str "%a %a" Fmt.code_or_quote s Fmt.ereason "is not a directory"

let err_is_dir s =
  Fmt.str "%a %a" Fmt.code_or_quote s Fmt.ereason "is a directory"

let err_element kind s exp =
  Fmt.str "%a element in %s (%a): %s"
    Fmt.invalid () kind Fmt.code_or_quote s exp

let err_invalid kind s exp =
  Fmt.str "@[%a %s %a, %s@]" Fmt.invalid () kind Fmt.code_or_quote s exp

let err_invalid_val = err_invalid "value"
let err_sep_miss sep s =
  err_invalid_val s (Fmt.str "%a a '%c' separator" Fmt.missing () sep)

let err_invalid_enum var s enums =
  let pp_docv ppf var =
    if not (var = "ENUM" || var = "") then Fmt.pf ppf "%a " Fmt.code_var var
  in
  Fmt.str "@[%a@ %avalue %a, expected@ %a@]" Fmt.invalid () pp_docv var
    Fmt.code_or_quote s Cmdliner_base.pp_alts enums

(* Argument converters *)

module Completion = Cmdliner_def.Arg_completion
module Conv = Cmdliner_def.Arg_conv
type 'a conv = 'a Conv.t
let some = Cmdliner_def.Arg_conv.some
let some' = Cmdliner_def.Arg_conv.some'
let none = Cmdliner_def.Arg_conv.none

(* Argument information *)

type 'a t = 'a Cmdliner_term.t
type info = Cmdliner_def.Arg_info.t
let info = Cmdliner_def.Arg_info.make

(* Arguments *)

let ( & ) f x = f x
let parse_error e = Error (`Parse e)

let env_bool_parse s = match String.lowercase_ascii s with
| "" | "false" | "no" | "n" | "0" -> Ok false
| "true" | "yes" | "y" | "1" -> Ok true
| s ->
    let alts = doc_alts ~quoted:true ["true"; "yes"; "false"; "no" ] in
    Error (err_invalid_val s alts)

let parse_to_list parser s = match parser s with
| Ok v -> Ok [v] | Error _ as e -> e

let try_env ei a parse ~absent = match Cmdliner_def.Arg_info.env a with
| None -> Ok absent
| Some env ->
    let var = Cmdliner_def.Env.info_var env in
    match Cmdliner_def.Eval.env_var ei var with
    | None -> Ok absent
    | Some v ->
        match parse v with
        | Error e -> parse_error (Cmdliner_msg.err_env_parse env ~err:e)
        | Ok _ as v -> v

let arg_to_args a complete = Cmdliner_def.Arg_info.Set.singleton a complete
let list_to_args f l complete =
  let add acc v = Cmdliner_def.Arg_info.Set.add (f v) complete acc in
  List.fold_left add Cmdliner_def.Arg_info.Set.empty l

let flag a =
  if Cmdliner_def.Arg_info.is_pos a then invalid_arg err_not_opt else
  let convert ei cl = match Cmdliner_def.Cline.get_opt_arg cl a with
  | [] -> try_env ei a env_bool_parse ~absent:false
  | [_, _, None] -> Ok true
  | [_, f, Some v] -> parse_error (Cmdliner_msg.err_flag_value f v)
  | (_, f, _) :: (_ ,g, _) :: _  ->
      parse_error (Cmdliner_msg.err_opt_repeated f g)
  in
  Cmdliner_term.make (arg_to_args a (Conv none)) convert

let flag_all a =
  if Cmdliner_def.Arg_info.is_pos a then invalid_arg err_not_opt else
  let a = Cmdliner_def.Arg_info.make_all_opts a in
  let convert ei cl = match Cmdliner_def.Cline.get_opt_arg cl a with
  | [] -> try_env ei a (parse_to_list env_bool_parse) ~absent:[]
  | l ->
      try
        let truth (_, f, v) = match v with
        | None -> true
        | Some v -> failwith (Cmdliner_msg.err_flag_value f v)
        in
        Ok (List.rev_map truth l)
      with Failure e -> parse_error e
  in
  Cmdliner_term.make (arg_to_args a (Conv none)) convert

let vflag v l =
  let convert _ cl =
    let rec aux fv = function
    | (v, a) :: rest ->
        begin match Cmdliner_def.Cline.get_opt_arg cl a with
        | [] -> aux fv rest
        | [_, f, None] ->
            begin match fv with
            | None -> aux (Some (f, v)) rest
            | Some (g, _) -> failwith (Cmdliner_msg.err_opt_repeated g f)
            end
        | [_, f, Some v] -> failwith (Cmdliner_msg.err_flag_value f v)
        | (_, f, _) :: (_, g, _) :: _ ->
            failwith (Cmdliner_msg.err_opt_repeated g f)
        end
    | [] -> match fv with None -> v | Some (_, v) -> v
    in
    try Ok (aux None l) with Failure e -> parse_error e
  in
  let flag (_, a) =
    if Cmdliner_def.Arg_info.is_pos a then invalid_arg err_not_opt else a
  in
  Cmdliner_term.make (list_to_args flag l (Conv none)) convert

let vflag_all v l =
  let convert _ cl =
    let rec aux acc = function
    | (fv, a) :: rest ->
        begin match Cmdliner_def.Cline.get_opt_arg cl a with
        | [] -> aux acc rest
        | l ->
            let fval (k, f, v) = match v with
            | None -> (k, fv)
            | Some v -> failwith (Cmdliner_msg.err_flag_value f v)
            in
            aux (List.rev_append (List.rev_map fval l) acc) rest
        end
    | [] ->
        if acc = [] then v else List.rev_map snd (List.sort rev_compare acc)
    in
    try Ok (aux [] l) with Failure e -> parse_error e
  in
  let flag (_, a) =
    if Cmdliner_def.Arg_info.is_pos a then invalid_arg err_not_opt else
    Cmdliner_def.Arg_info.make_all_opts a
  in
  Cmdliner_term.make (list_to_args flag l (Conv none)) convert

let parse_opt_value parse f v = match parse v with
| Ok v -> v | Error err -> failwith (Cmdliner_msg.err_opt_parse f ~err)

let opt ?vopt conv v a =
  if Cmdliner_def.Arg_info.is_pos a then invalid_arg err_not_opt else
  let absent = match Cmdliner_def.Arg_info.absent a with
  | Cmdliner_def.Arg_info.Doc d as a when d <> "" -> a
  | _ -> Cmdliner_def.Arg_info.Val (lazy (str_of_pp (Conv.pp conv) v))
  in
  let kind = match vopt with
  | None -> Cmdliner_def.Arg_info.Opt
  | Some dv -> Cmdliner_def.Arg_info.Opt_vopt (str_of_pp (Conv.pp conv) dv)
  in
  let docv = match Cmdliner_def.Arg_info.docv a with
  | "" -> Conv.docv conv | docv -> docv
  in
  let a = Cmdliner_def.Arg_info.make_opt ~docv ~absent ~kind a in
  let convert ei cl = match Cmdliner_def.Cline.get_opt_arg cl a with
  | [] -> try_env ei a (Conv.parser conv) ~absent:v
  | [_, f, Some v] ->
      (try Ok (parse_opt_value (Conv.parser conv) f v) with
      | Failure e -> parse_error e)
  | [_, f, None] ->
      begin match vopt with
      | None -> parse_error (Cmdliner_msg.err_opt_value_missing f)
      | Some optv -> Ok optv
      end
  | (_, f, _) :: (_, g, _) :: _ ->
      parse_error (Cmdliner_msg.err_opt_repeated g f)
  in
  Cmdliner_term.make (arg_to_args a (Conv conv)) convert

let opt_all ?vopt conv v a =
  if Cmdliner_def.Arg_info.is_pos a then invalid_arg err_not_opt else
  let absent = match Cmdliner_def.Arg_info.absent a with
  | Cmdliner_def.Arg_info.Doc d as a when d <> "" -> a
  | _ -> Cmdliner_def.Arg_info.Val (lazy "")
  in
  let kind = match vopt with
  | None -> Cmdliner_def.Arg_info.Opt
  | Some dv -> Cmdliner_def.Arg_info.Opt_vopt (str_of_pp (Conv.pp conv) dv)
  in
  let docv = match Cmdliner_def.Arg_info.docv a with
  | "" -> Conv.docv conv | docv -> docv
  in
  let a = Cmdliner_def.Arg_info.make_opt_all ~docv ~absent ~kind a in
  let convert ei cl = match Cmdliner_def.Cline.get_opt_arg cl a with
  | [] -> try_env ei a (parse_to_list (Conv.parser conv)) ~absent:v
  | l ->
      let parse (k, f, v) = match v with
      | Some v -> (k, parse_opt_value (Conv.parser conv) f v)
      | None -> match vopt with
      | None -> failwith (Cmdliner_msg.err_opt_value_missing f)
      | Some dv -> (k, dv)
      in
      try Ok (List.rev_map snd
                (List.sort rev_compare (List.rev_map parse l))) with
      | Failure e -> parse_error e
  in
  Cmdliner_term.make (arg_to_args a (Conv conv)) convert

(* Positional arguments *)

let parse_pos_value parse a v = match parse v with
| Ok v -> v
| Error err -> failwith (Cmdliner_msg.err_pos_parse a ~err)

let pos ?(rev = false) k conv v a =
  if Cmdliner_def.Arg_info.is_opt a then invalid_arg err_not_pos else
  let absent = match Cmdliner_def.Arg_info.absent a with
  | Cmdliner_def.Arg_info.Doc d as a when d <> "" -> a
  | _ -> Cmdliner_def.Arg_info.Val (lazy (str_of_pp (Conv.pp conv) v))
  in
  let pos = Cmdliner_def.Arg_info.pos ~rev ~start:k ~len:(Some 1) in
  let docv = match Cmdliner_def.Arg_info.docv a with
  | "" -> Conv.docv conv | docv -> docv
  in
  let a = Cmdliner_def.Arg_info.make_pos_abs ~docv ~absent ~pos a in
  let convert ei cl = match Cmdliner_def.Cline.get_pos_arg cl a with
  | [] -> try_env ei a (Conv.parser conv) ~absent:v
  | [v] ->
      (try Ok (parse_pos_value (Conv.parser conv) a v) with
      | Failure e -> parse_error e)
  | _ -> assert false
  in
  Cmdliner_term.make (arg_to_args a (Conv conv)) convert

let pos_list pos conv v a =
  if Cmdliner_def.Arg_info.is_opt a then invalid_arg err_not_pos else
  let docv = match Cmdliner_def.Arg_info.docv a with
  | "" -> Conv.docv conv | docv -> docv
  in
  let a = Cmdliner_def.Arg_info.make_pos ~docv ~pos a in
  let convert ei cl = match Cmdliner_def.Cline.get_pos_arg cl a with
  | [] -> try_env ei a (parse_to_list (Conv.parser conv)) ~absent:v
  | l ->
      try Ok (List.rev (List.rev_map (parse_pos_value (Conv.parser conv) a) l))
      with
      | Failure e -> parse_error e
  in
  Cmdliner_term.make (arg_to_args a (Conv conv)) convert

let all = Cmdliner_def.Arg_info.pos ~rev:false ~start:0 ~len:None
let pos_all c v a = pos_list all c v a

let pos_left ?(rev = false) k =
  let start = if rev then k + 1 else 0 in
  let len = if rev then None else Some k in
  pos_list (Cmdliner_def.Arg_info.pos ~rev ~start ~len)

let pos_right ?(rev = false) k =
  let start = if rev then 0 else k + 1 in
  let len = if rev then Some k else None in
  pos_list (Cmdliner_def.Arg_info.pos ~rev ~start ~len)

(* Arguments as terms *)

let absent_error args =
  let make_req a v acc =
    let req_a = Cmdliner_def.Arg_info.make_req a in
    Cmdliner_def.Arg_info.Set.add req_a v acc
  in
  Cmdliner_def.Arg_info.Set.fold make_req args Cmdliner_def.Arg_info.Set.empty

let value a = a

let err_arg_missing args =
  parse_error @@
  Cmdliner_msg.err_arg_missing (fst (Cmdliner_def.Arg_info.Set.choose args))

let required t =
  let args = absent_error (Cmdliner_term.argset t) in
  let convert ei cl = match (Cmdliner_term.parser t) ei cl with
  | Ok (Some v) -> Ok v
  | Ok None -> err_arg_missing args
  | Error _ as e -> e
  in
  Cmdliner_term.make args convert

let non_empty t =
  let args = absent_error (Cmdliner_term.argset t) in
  let convert ei cl = match (Cmdliner_term.parser t) ei cl with
  | Ok [] -> err_arg_missing args
  | Ok l -> Ok l
  | Error _ as e -> e
  in
  Cmdliner_term.make args convert

let last t =
  let convert ei cl = match (Cmdliner_term.parser t) ei cl with
  | Ok [] -> err_arg_missing (Cmdliner_term.argset t)
  | Ok l -> Ok (List.hd (List.rev l))
  | Error _ as e -> e
  in
  Cmdliner_term.make (Cmdliner_term.argset t) convert

(* Predefined converters. *)

let add_prefix_completion ~token name =
  if Cmdliner_base.string_starts_with ~prefix:token name
  then Some (Completion.string name) else None

let bool =
  let alts = ["true"; "false"] in
  let parser s = try Ok (bool_of_string s) with
  | Invalid_argument _ -> Error (err_invalid_enum "" s alts)
  in
  let completion =
    let func _ctx ~token =
      Ok (List.filter_map (add_prefix_completion ~token) alts)
    in
    Completion.make func
  in
  Conv.make ~docv:"BOOL" ~parser ~pp:Format.pp_print_bool ~completion ()

let char =
  let parser s = match String.length s = 1 with
  | true -> Ok s.[0]
  | false -> Error (err_invalid_val s "expected a character")
  in
  Conv.make ~docv:"CHAR" ~parser ~pp:Fmt.char ()

let parse_with t_of_str exp s =
  try Ok (t_of_str s) with Failure _ -> Error (err_invalid_val s exp)

let int =
  let parser = parse_with int_of_string "expected an integer" in
  Conv.make ~docv:"INT" ~parser ~pp:Format.pp_print_int ()

let int32 =
  let parser = parse_with Int32.of_string "expected a 32-bit integer" in
  let pp ppf = Fmt.pf ppf "%ld" in
  Conv.make ~docv:"INT32" ~parser ~pp ()

let int64 =
  let parser = parse_with Int64.of_string "expected a 64-bit integer" in
  let pp ppf = Fmt.pf ppf "%Ld" in
  Conv.make ~docv:"INT64" ~parser ~pp ()

let nativeint =
  let err = "expected a processor-native integer" in
  let parser = parse_with Nativeint.of_string err in
  let pp ppf = Fmt.pf ppf "%nd" in
  Conv.make ~docv:"NATIVEINT" ~parser ~pp ()

let float =
  let parser = parse_with float_of_string "expected a floating point number" in
  Conv.make ~docv:"DOUBLE" ~parser ~pp:Format.pp_print_float ()

let string = Conv.make ~docv:"" ~parser:Result.ok ~pp:Fmt.string ()

let enum ?(docv = "ENUM") sl =
  if sl = [] then invalid_arg Cmdliner_base.err_empty_list else
  let t = Cmdliner_trie.of_list sl in
  let parser s =
    let legacy_prefixes = Cmdliner_trie.legacy_prefixes ~env:Sys.getenv_opt in
    match Cmdliner_trie.find ~legacy_prefixes t s with
    | Ok _ as v -> v
    | Error `Ambiguous (* Only on legacy prefixes *) ->
        let ambs = List.sort compare (Cmdliner_trie.ambiguities t s) in
        Error (Cmdliner_base.err_ambiguous ~kind:"enum value" s ~ambs)
    | Error `Not_found ->
        let alts = List.rev (List.rev_map (fun (s, _) -> s) sl) in
        Error (err_invalid_enum docv s alts)
  in
  let pp ppf v =
    let sl_inv = List.rev_map (fun (s,v) -> (v,s)) sl in
    try Fmt.string ppf (List.assoc v sl_inv)
    with Not_found -> invalid_arg (err_incomplete_enum (List.map fst sl))
  in
  let completion =
    let func _ctx ~token =
      Ok (List.filter_map (fun (n, _) -> add_prefix_completion ~token n) sl)
    in
    Completion.make func
  in
  Conv.make ~docv ~parser ~pp ~completion ()

let path =
  let parser s = Ok s in
  let pp ppf s = Fmt.string ppf (Filename.quote s) in
  let completion = Completion.complete_paths in
  Conv.make ~docv:"PATH" ~parser ~pp ~completion ()

let filepath =
  let parser s = Ok s in
  let pp ppf s = Fmt.string ppf (Filename.quote s) in
  let completion = Completion.complete_files in
  Conv.make ~docv:"FILE" ~parser ~pp ~completion ()

let dirpath =
  let parser s = Ok s in
  let pp ppf s = Fmt.string ppf (Filename.quote s) in
  let completion = Completion.complete_dirs in
  Conv.make ~docv:"DIR" ~parser ~pp ~completion ()

let file =
  let parser s =
    if s = "-" then Ok s else
    if Sys.file_exists s then Ok s else
    Error (err_no "file or directory" s)
  in
  let completion = Completion.complete_files in
  Conv.make ~docv:"PATH" ~parser ~pp:Fmt.string ~completion ()

let dir =
  let parser s =
    if Sys.file_exists s
    then (if Sys.is_directory s then Ok s else Error (err_not_dir s))
    else Error (err_no "directory" s)
  in
  let completion = Completion.complete_dirs in
  Conv.make ~docv:"DIR" ~parser ~pp:Fmt.string ~completion ()

let non_dir_file =
  let parser s =
    if s = "-" then Ok s else
    if Sys.file_exists s
    then (if not (Sys.is_directory s) then Ok s else Error (err_is_dir s))
    else Error (err_no "file" s)
  in
  let completion = Completion.complete_files in
  Conv.make ~docv:"FILE" ~parser ~pp:Fmt.string ~completion ()

let split_and_parse sep parse s = (* raises [Failure] *)
  let parse sub = match parse sub with
  | Error e -> failwith e | Ok v -> v
  in
  let rec split accum j =
    let i = try String.rindex_from s j sep with Not_found -> -1 in
    if (i = -1) then
      let p = String.sub s 0 (j + 1) in
      if p <> "" then parse p :: accum else accum
    else
    let p = String.sub s (i + 1) (j - i) in
    let accum' = if p <> "" then parse p :: accum else accum in
    split accum' (i - 1)
  in
  split [] (String.length s - 1)

let list ?(sep = ',') conv =
  let parser s = try Ok (split_and_parse sep (Conv.parser conv) s) with
  | Failure e -> Error (err_element "list" s e)
  in
  let rec pp ppf = function
  | [] -> ()
  | v :: l ->
      (Conv.pp conv) ppf v; if (l <> []) then (Fmt.char ppf sep; pp ppf l)
  in
  let docv = Printf.sprintf "%s[%c]" (Conv.docv conv) sep in
  Conv.make ~docv ~parser ~pp ()

let array ?(sep = ',') conv =
  let parser s =
    try Ok (Array.of_list (split_and_parse sep (Conv.parser conv) s)) with
    | Failure e -> Error (err_element "array" s e)
  in
  let pp ppf v =
    let max = Array.length v - 1 in
    for i = 0 to max do
      Conv.pp conv ppf v.(i); if i <> max then Fmt.char ppf sep
    done
  in
  let docv = Printf.sprintf "%s[%c]" (Conv.docv conv) sep in
  Conv.make ~docv ~parser ~pp ()

let split_left sep s =
  try
    let i = String.index s sep in
    let len = String.length s in
    Some ((String.sub s 0 i), (String.sub s (i + 1) (len - i - 1)))
  with Not_found -> None

let pair ?(sep = ',') conv0 conv1 =
  let parser s = match split_left sep s with
  | None -> Error (err_sep_miss sep s)
  | Some (v0, v1) ->
      match (Conv.parser conv0) v0, (Conv.parser conv1) v1 with
      | Ok v0, Ok v1 -> Ok (v0, v1)
      | Error e, _ | _, Error e -> Error (err_element "pair" s e)
  in
  let pp ppf (v0, v1) =
    Fmt.pf ppf "%a%c%a" (Conv.pp conv0) v0 sep (Conv.pp conv1) v1
  in
  let docv = Printf.sprintf "%s%c%s" (Conv.docv conv0) sep (Conv.docv conv1) in
  Conv.make ~docv ~parser ~pp ()

let t2 = pair
let t3 ?(sep = ',') conv0 conv1 conv2 =
  let parser s = match split_left sep s with
  | None -> Error (err_sep_miss sep s)
  | Some (v0, s) ->
      match split_left sep s with
      | None -> Error (err_sep_miss sep s)
      | Some (v1, v2) ->
          match (Conv.parser conv0) v0, (Conv.parser conv1) v1,
                (Conv.parser conv2) v2 with
          | Ok v0, Ok v1, Ok v2 -> Ok (v0, v1, v2)
          | Error e, _, _ | _, Error e, _ | _, _, Error e ->
              Error (err_element "triple" s e)
  in
  let pp ppf (v0, v1, v2) =
    let pp = Conv.pp in
    Fmt.pf ppf "%a%c%a%c%a" (pp conv0) v0 sep (pp conv1) v1 sep (pp conv2) v2
  in
  let docv =
    let docv = Conv.docv in
    Printf.sprintf "%s%c%s%c%s" (docv conv0) sep (docv conv1) sep (docv conv2)
  in
  Conv.make ~docv ~parser ~pp ()

let t4 ?(sep = ',') conv0 conv1 conv2 conv3 =
  let parser s = match split_left sep s with
  | None -> Error (err_sep_miss sep s)
  | Some(v0, s) ->
      match split_left sep s with
      | None -> Error (err_sep_miss sep s)
      | Some (v1, s) ->
          match split_left sep s with
          | None -> Error (err_sep_miss sep s)
          | Some (v2, v3) ->
              match (Conv.parser conv0) v0, (Conv.parser conv1) v1,
                    (Conv.parser conv2) v2, (Conv.parser conv3) v3  with
              | Ok v1, Ok v2, Ok v3, Ok v4 -> Ok (v1, v2, v3, v4)
              | Error e, _, _, _ | _, Error e, _, _ | _, _, Error e, _
              | _, _, _, Error e -> Error (err_element "quadruple" s e)
  in
  let pp ppf (v0, v1, v2, v3) =
    let pp = Conv.pp in
    Fmt.pf ppf "%a%c%a%c%a%c%a" (pp conv0) v0 sep (pp conv1) v1 sep (pp conv2)
      v2 sep (pp conv3) v3
  in
  let docv =
    let docv = Conv.docv in
    Printf.sprintf "%s%c%s%c%s%c%s"
      (docv conv0) sep (docv conv1) sep (docv conv2) sep (docv conv3)
  in
  Conv.make ~docv ~parser ~pp ()

(* Predefined arguments *)

let man_fmts =
  ["auto", `Auto; "pager", `Pager; "groff", `Groff; "plain", `Plain]

let man_fmt_docv = "FMT"
let man_fmts_enum = enum ~docv:man_fmt_docv man_fmts
let man_fmts_alts = doc_alts_enum man_fmts
let man_fmts_doc kind =
  Printf.sprintf
    "Show %s in format $(docv). The value $(docv) must be %s. \
     With $(b,auto), the format is $(b,pager) or $(b,plain) whenever \
     the $(b,TERM) env var is $(b,dumb) or undefined."
    kind man_fmts_alts

let man_format =
  let doc = man_fmts_doc "output" in
  let docv = man_fmt_docv in
  value & opt man_fmts_enum `Pager & info ["man-format"] ~docv ~doc

let stdopt_version ~docs =
  value & flag & info ["version"] ~docs ~doc:"Show version information."

let stdopt_help ~docs =
  let doc = man_fmts_doc "this help" in
  let docv = man_fmt_docv in
  value & opt ~vopt:(Some `Auto) (some man_fmts_enum) None &
  info ["help"] ~docv ~docs ~doc

(* Deprecated *)

type 'a printer = 'a Conv.fmt
let docv_default = "VALUE"
let conv' ?docv (parser, pp) = Conv.make ~docv:docv_default ~parser ~pp ()
let conv ?docv (parser, pp) =
  let parser s = match parser s with
  | Ok _ as v -> v | Error (`Msg e) -> Error e
  in
  Conv.make ~docv:docv_default ~parser ~pp ()

let conv_printer = Conv.pp
let conv_docv = Conv.docv
let conv_parser conv =
  fun s -> match Conv.parser conv s with
  | Ok _ as v -> v | Error e -> Error (`Msg e)

let err_invalid s kind =
  `Msg (Printf.sprintf "invalid value '%s', expected %s" s kind)

let parser_of_kind_of_string ~kind k_of_string =
  fun s -> match k_of_string s with
  | None -> Error (err_invalid s kind)
  | Some v -> Ok v
end
module Cmdliner_eval : sig
(*---------------------------------------------------------------------------
   Copyright (c) 2022 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

(** Command evaluation *)

type 'a eval_ok = [ `Ok of 'a | `Version | `Help ]
type eval_error = [ `Parse | `Term | `Exn ]
type 'a eval_exit = [ `Ok of 'a  | `Exit of Cmdliner_def.Exit.code ]

val eval_value :
  ?help:Format.formatter -> ?err:Format.formatter -> ?catch:bool ->
  ?env:(string -> string option) -> ?argv:string array -> 'a Cmdliner_cmd.t ->
  ('a eval_ok, eval_error) result

val eval_value' :
  ?help:Format.formatter -> ?err:Format.formatter -> ?catch:bool ->
  ?env:(string -> string option) -> ?argv:string array ->
  ?term_err:int -> 'a Cmdliner_cmd.t -> 'a eval_exit

val eval_peek_opts :
  ?version_opt:bool -> ?env:(string -> string option) ->
  ?argv:string array -> 'a Cmdliner_term.t ->
  'a option * ('a eval_ok, eval_error) result

val eval :
  ?help:Format.formatter -> ?err:Format.formatter -> ?catch:bool ->
  ?env:(string -> string option) -> ?argv:string array ->
  ?term_err:int -> unit Cmdliner_cmd.t -> Cmdliner_def.Exit.code

val eval' :
  ?help:Format.formatter -> ?err:Format.formatter -> ?catch:bool ->
  ?env:(string -> string option) -> ?argv:string array ->
  ?term_err:int -> int Cmdliner_cmd.t -> Cmdliner_def.Exit.code

val eval_result :
  ?help:Format.formatter -> ?err:Format.formatter -> ?catch:bool ->
  ?env:(string -> string option) -> ?argv:string array ->
  ?term_err:Cmdliner_def.Exit.code -> (unit, string) result Cmdliner_cmd.t ->
  Cmdliner_def.Exit.code

val eval_result' :
  ?help:Format.formatter -> ?err:Format.formatter -> ?catch:bool ->
  ?env:(string -> string option) -> ?argv:string array ->
  ?term_err:Cmdliner_def.Exit.code ->
  (Cmdliner_def.Exit.code, string) result Cmdliner_cmd.t ->
  Cmdliner_def.Exit.code
end = struct
(*---------------------------------------------------------------------------
   Copyright (c) 2022 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

type 'a eval_ok = [ `Ok of 'a | `Version | `Help ]
type eval_error = [ `Parse | `Term | `Exn ]
type 'a eval_exit = [ `Ok of 'a  | `Exit of Cmdliner_def.Exit.code ]

type eval_result_error =
  [ Cmdliner_term.term_escape
  | `Exn of exn * Printexc.raw_backtrace
  | `Parse of string
  | `Std_help of Cmdliner_manpage.format
  | `Std_version ]

type 'a eval_result =
  ('a, [ eval_result_error
       | `Complete of Cmdliner_def.Complete.t * Cmdliner_def.Cline.t]) result

let err_help s = "Term error, help requested for unknown command " ^ s
let err_argv = "argv array must have at least one element"

let add_stdopts eval =
  let docs = Cmdliner_def.Cmd_info.stdopts_docs (Cmdliner_def.Eval.cmd eval) in
  let vargs, vers =
    match Cmdliner_def.Cmd_info.version (Cmdliner_def.Eval.main eval) with
    | None -> Cmdliner_def.Arg_info.Set.empty, None
    | Some _ ->
        let vers = Cmdliner_arg.stdopt_version ~docs in
        (Cmdliner_term.argset vers), Some vers
  in
  let help = Cmdliner_arg.stdopt_help ~docs in
  let args =
    Cmdliner_def.Arg_info.Set.union vargs (Cmdliner_term.argset help)
  in
  let cmd = Cmdliner_def.Cmd_info.add_args (Cmdliner_def.Eval.cmd eval) args in
  help, vers, Cmdliner_def.Eval.with_cmd eval cmd

let run_parser ~catch eval cl f =
  try (f eval cl :> ('a, eval_result_error) result) with
  | exn when catch ->
      let bt = Printexc.get_raw_backtrace () in
      Error (`Exn (exn, bt))

let try_eval_stdopts ~catch eval cline help version : 'a eval_result option =
  match run_parser ~catch eval cline (Cmdliner_term.parser help) with
  | Ok (Some fmt) -> Some (Error (`Std_help fmt))
  | Error (`Parse _) ->
      (* only [FMT] errored, there was a `--help`, show help anyways *)
      Some (Error (`Std_help `Auto))
  | Error _ as err -> (Some err :> 'a eval_result option)
  | Ok None ->
      match version with
      | None -> None
      | Some version ->
          match (run_parser ~catch eval cline (Cmdliner_term.parser version))
          with
          | Ok false -> None
          | Ok true -> Some (Error (`Std_version))
          | Error _ as err -> (Some err :> 'a eval_result option)

let do_help ~env help_ppf err_ppf eval fmt cmd_name =
  let eval = match cmd_name with
  | None (* help of main command requested *)  ->
      let env _ = assert false in
      let cmd = Cmdliner_def.Eval.main eval in
      let subcmds = Cmdliner_def.Eval.subcmds eval in
      let eval' =
        Cmdliner_def.Eval.make ~ancestors:[] ~cmd ~subcmds ~env ~err_ppf
      in
      begin match Cmdliner_def.Eval.ancestors eval with
      | [] -> (* [ei] is an evaluation of main, [cmd] has stdopts *) eval'
      | _ -> let _, _, eval' = add_stdopts eval' in eval'
      end
  | Some cmd ->
      try
        (* For now we simply keep backward compat. [cmd] should be
           a name from main's children. *)
        let main = Cmdliner_def.Eval.main eval in
        let is_cmd t = Cmdliner_def.Cmd_info.name t = cmd in
        let children = Cmdliner_def.Cmd_info.children main in
        let cmd = List.find is_cmd children in
        let _, _, eval = add_stdopts (Cmdliner_def.Eval.with_cmd eval cmd) in
        eval
      with Not_found -> invalid_arg (err_help cmd)
  in
  Cmdliner_docgen.pp_man ~env ~errs:err_ppf fmt help_ppf eval

let do_result ~env help_ppf err_ppf eval = function
| Ok v -> Ok (`Ok v)
| Error res ->
    match res with
    | `Std_help fmt ->
        Cmdliner_docgen.pp_man ~env ~errs:err_ppf fmt help_ppf eval; Ok `Help
    | `Std_version ->
        Cmdliner_msg.pp_version help_ppf eval; Ok `Version
    | `Parse err ->
        Cmdliner_msg.pp_usage_and_err err_ppf eval ~err; Error `Parse
    | `Complete (comp, cline) ->
        Cmdliner_completion.output ~out_ppf:help_ppf ~err_ppf eval comp cline;
        Ok `Help
    | `Help (fmt, cmd_name) ->
        do_help ~env help_ppf err_ppf eval fmt cmd_name; Ok `Help
    | `Exn (e, bt) ->
        Cmdliner_msg.pp_backtrace err_ppf eval e bt; (Error `Exn)
    | `Error (usage, err) ->
        (if usage
         then Cmdliner_msg.pp_usage_and_err err_ppf eval ~err
         else Cmdliner_msg.pp_err err_ppf eval ~err);
        Error `Term

let do_deprecated_msgs ~env err_ppf cl eval =
  let cmd_info = Cmdliner_def.Eval.cmd eval in
  let deprecated = Cmdliner_def.Cline.deprecated ~env cl in
  match Cmdliner_def.Cmd_info.deprecated cmd_info, deprecated with
  | None, [] -> ()
  | depr_cmd, deprs ->
      let open Cmdliner_base in
      let pp_sep ppf () =
        if Option.is_some depr_cmd && deprs <> [] then Fmt.cut ppf ();
      in
      let subst = Cmdliner_def.Eval.doclang_subst eval in
      let pp_cmd_msg ppf cmd =
        match
          Cmdliner_def.Cmd_info.styled_deprecated ~subst ~errs:err_ppf cmd
        with
        | "" -> ()
        | msg ->
            let name = Cmdliner_def.Cmd_info.name cmd in
            Fmt.pf ppf "@[%a command %a:@[ %a@]@]"
              Fmt.deprecated () Fmt.code_or_quote name Fmt.styled_text msg
      in
      let pp_deprs = Fmt.list (Cmdliner_def.Cline.pp_deprecated ~subst) in
      Fmt.pf err_ppf "@[%a @[<v>%a%a%a@]@]@."
        Cmdliner_msg.pp_exec_msg eval pp_cmd_msg cmd_info
        pp_sep () pp_deprs deprs

let find_cmd_and_parser ~legacy_prefixes ~for_completion args cmd =
  (* This finds the command to use if it's a group and [for_completion]
     is [true] whether we may need to add the subcommand names to the
     completions. *)
  let stop ~ancestors ~cmd args = match (cmd : 'a Cmdliner_cmd.t) with
  | Cmd (_, parser) -> ancestors, cmd, args, Ok parser
  | Group (_, (Some parser, _)) -> ancestors, cmd, args, Ok parser
  | Group (_, (None, children)) ->
      let dom = Cmdliner_cmd.list_names children in
      let err = Cmdliner_msg.err_cmd_missing ~dom in
      let try_stdopts = true in
      ancestors, cmd, args, Error (`Parse (try_stdopts, err))
  in
  let rec loop ~ancestors ~current_cmd = function
  | "--" :: _ | [] as args -> stop ~ancestors ~cmd:current_cmd args
  | arg :: _ as args when for_completion &&
                          Cmdliner_cline.has_complete_prefix arg ->
      begin match current_cmd with
      | Cmd _ -> (* arg completion *) stop ~ancestors ~cmd:current_cmd args
      | Group (_, (parser, _))  ->
          let is_opt = Cmdliner_cline.(is_opt (get_token_to_complete arg)) in
          if not is_opt then ancestors, current_cmd, args, Error `Complete else
          stop ~ancestors ~cmd:current_cmd args
      end
  | arg :: _ as args when Cmdliner_cline.is_opt arg ->
      stop ~ancestors ~cmd:current_cmd args
  | arg :: rest as args ->
      match current_cmd with
      | Cmd (i, parser) -> ancestors, current_cmd, args, Ok parser
      | Group (i, (_, children)) ->
          let cmd_index = Cmdliner_cmd.name_trie children in
          match Cmdliner_trie.find ~legacy_prefixes cmd_index arg with
          | Ok cmd -> loop ~ancestors:(i :: ancestors) ~current_cmd:cmd rest
          | Error `Not_found ->
              let all = Cmdliner_trie.ambiguities cmd_index "" in
              let hints = Cmdliner_base.suggest arg all in
              let dom = Cmdliner_cmd.list_names children in
              let kind = "command" in
              let err = Cmdliner_base.err_unknown ~kind ~dom ~hints arg in
              let try_stdopts =
                (* When one writes [cmd no_such_cmd --help] it's better
                   to show the unknown command error message rather
                   than get into the help of the parent command. Otherwise
                   one gets confused into thinking the command exists and/or
                   annoyed not to be reading the right man page. *)
                false
              in
              ancestors, current_cmd, args, Error (`Parse (try_stdopts, err))
          | Error `Ambiguous (* Only on legacy prefixes *)  ->
              let ambs = Cmdliner_trie.ambiguities cmd_index arg in
              let ambs = List.sort compare ambs in
              let err = Cmdliner_base.err_ambiguous ~kind:"command" arg ~ambs in
              let try_stdopts = false in
              ancestors, current_cmd, args, Error (`Parse (try_stdopts, err))
  in
  loop ~ancestors:[] ~current_cmd:cmd args

let cli_args_of_argv argv = match Array.to_list argv with
| exec :: "--__complete" :: args -> true, args
| exec :: args -> false, args
| [] -> invalid_arg err_argv

let eval_value
    ?help:(help_ppf = Format.std_formatter)
    ?err:(err_ppf = Format.err_formatter)
    ?(catch = true) ?(env = Sys.getenv_opt) ?(argv = Sys.argv) cmd
  =
  let legacy_prefixes = Cmdliner_trie.legacy_prefixes ~env in
  let for_completion, args = cli_args_of_argv argv in
  let ancestors, cmd, args, parser =
    find_cmd_and_parser ~legacy_prefixes ~for_completion args cmd
  in
  let help, version, eval =
    let subcmds = Cmdliner_cmd.get_children_infos cmd in
    let cmd = Cmdliner_cmd.get_info cmd in
    let eval = Cmdliner_def.Eval.make ~ancestors ~cmd ~subcmds ~env ~err_ppf in
    add_stdopts eval
  in
  let cline =
    let args_info = Cmdliner_def.Cmd_info.args (Cmdliner_def.Eval.cmd eval) in
    Cmdliner_cline.create ~legacy_prefixes ~for_completion args_info args
  in
  let res = match parser with
  | Error (`Parse (try_stdopts, msg)) ->
      (* Command lookup error, we may still prioritize stdargs *)
      begin match cline with
      | `Complete c -> Error (`Complete c)
      | `Error (_, cl) | `Ok cl ->
          let stdopts =
            if try_stdopts
            then try_eval_stdopts ~catch eval cl help version else None
          in
          begin match stdopts with
          | None -> Error (`Error (true, msg))
          | Some e -> e
          end
      end
  | Error `Complete ->
      begin match cline with
      | `Complete (comp, cline) ->
          let comp = Cmdliner_def.Complete.add_subcmds comp in
          Error (`Complete (comp, cline))
      | `Ok _ | `Error _ -> assert false
      end
  | Ok parser ->
      begin match cline with
      | `Complete c -> Error (`Complete c)
      | `Error (e, cl) ->
          begin match try_eval_stdopts ~catch eval cl help version with
          | Some e -> e
          | None -> Error (`Error (true, e))
          end
      | `Ok cl ->
          match try_eval_stdopts ~catch eval cl help version with
          | Some e -> e
          | None ->
              do_deprecated_msgs ~env err_ppf cl eval;
              (run_parser ~catch eval cl parser :> 'a eval_result)
      end
  in
  do_result ~env help_ppf err_ppf eval res

let eval_peek_opts
    ?(version_opt = false) ?(env = Sys.getenv_opt) ?(argv = Sys.argv) t
  : 'a option * ('a eval_ok, eval_error) result
  =
  let legacy_prefixes = Cmdliner_trie.legacy_prefixes ~env in
  let for_completion, args = cli_args_of_argv argv in
  let version = if version_opt then Some "dummy" else None in
  let cmd_info, parser =
    let args, parser = Cmdliner_term.argset t, Cmdliner_term.parser t in
    let cmd_info = Cmdliner_def.Cmd_info.make ?version "dummy" in
    Cmdliner_def.Cmd_info.add_args cmd_info args, parser
  in
  let help, version, eval =
    let err_ppf = Format.make_formatter (fun _ _ _ -> ()) (fun () -> ()) in
    let ancestors = [] and cmd = cmd_info and subcmds = [] in
    let eval = Cmdliner_def.Eval.make ~ancestors ~cmd ~subcmds ~env ~err_ppf in
    add_stdopts eval
  in
  let cline =
    let arg_infos = Cmdliner_def.Cmd_info.args (Cmdliner_def.Eval.cmd eval) in
    Cmdliner_cline.create
      ~peek_opts:true ~legacy_prefixes ~for_completion arg_infos args
  in
  let v, ret = match cline with
  | `Complete comp -> None, (Error (`Complete comp))
  | `Error (e, cl) ->
      begin match try_eval_stdopts ~catch:true eval cl help version with
      | Some e -> None, e
      | None -> None, Error (`Error (true, e))
      end
  | `Ok cl ->
      let ret = run_parser ~catch:true eval cl parser in
      let v = match ret with Ok v -> Some v | Error _ -> None in
      begin match try_eval_stdopts ~catch:true eval cl help version with
      | Some e -> v, e
      | None -> v, (ret :> 'a eval_result)
      end
  in
  let ret = match ret with
  | Ok v -> Ok (`Ok v)
  | Error `Std_help _ -> Ok `Help
  | Error `Std_version -> Ok `Version
  | Error `Parse _ -> Error `Parse
  | Error `Help _ -> Ok `Help
  | Error `Complete _ -> Ok `Help
  | Error `Exn _ -> Error `Exn
  | Error `Error _ -> Error `Term
  in
  (v, ret)

let exit_status_of_result ?(term_err = Cmdliner_def.Exit.cli_error) = function
| Ok (`Ok _ | `Help | `Version) -> Cmdliner_def.Exit.ok
| Error `Term -> term_err
| Error `Parse -> Cmdliner_def.Exit.cli_error
| Error `Exn -> Cmdliner_def.Exit.internal_error

let eval_value' ?help ?err ?catch ?env ?argv ?term_err cmd =
  match eval_value ?help ?err ?catch ?env ?argv cmd with
  | Ok (`Ok _ as v) -> v
  | ret -> `Exit (exit_status_of_result ?term_err ret)

let eval ?help ?err ?catch ?env ?argv ?term_err cmd =
  exit_status_of_result ?term_err @@
  eval_value ?help ?err ?catch ?env ?argv cmd

let eval' ?help ?err ?catch ?env ?argv ?term_err cmd =
  match eval_value ?help ?err ?catch ?env ?argv cmd with
  | Ok (`Ok c) -> c
  | r -> exit_status_of_result ?term_err r

let pp_err ppf cmd ~msg =
  (* Here instead of Cmdliner_msgs to avoid circular dep *)
  let name = Cmdliner_cmd.name cmd in
  Cmdliner_base.Fmt.pf ppf "%s: @[%a@]@." name Cmdliner_base.Fmt.lines msg

let eval_result
    ?help ?(err = Format.err_formatter) ?catch ?env ?argv ?term_err cmd
  =
  match eval_value ?help ~err ?catch ?env ?argv cmd with
  | Ok (`Ok (Error msg)) -> pp_err err cmd ~msg; Cmdliner_def.Exit.some_error
  | r -> exit_status_of_result ?term_err r

let eval_result'
    ?help ?(err = Format.err_formatter) ?catch ?env ?argv ?term_err cmd
  =
  match eval_value ?help ~err ?catch ?env ?argv cmd with
  | Ok (`Ok (Ok c)) -> c
  | Ok (`Ok (Error msg)) -> pp_err err cmd ~msg; Cmdliner_def.Exit.some_error
  | r -> exit_status_of_result ?term_err r
end
module Cmdliner : sig
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

(** Declarative definition of command line interfaces.

    Consult the {{!page-tutorial}tutorial}, the
    {{!page-cookbook}cookbook}, program
    {{!page-cookbook.blueprints}blueprints} and
    {{!page-cookbook.tip_src_structure}source structure}, details about the
    supported {{!page-cli}command line syntax} and
    {{!page-examples}examples} of use.

    Open the module to use it, it defines only these modules in your
    scope. *)

(** Man pages.

    Man page generation is automatically handled by [Cmdliner], see
    the {{!page-tool_man.manual}details}. The {!Manpage.block} type is
    used to define a man page's content. It's a good idea to follow
    the {{!Manpage.standard_sections}standard} manual page structure.

   {b References.}
   {ul
   {- [man-pages(7)], {{:http://man7.org/linux/man-pages/man7/man-pages.7.html}
      {e Conventions for writing Linux man pages}}.}} *)
module Manpage : sig

  (** {1:man Man pages} *)

  type section_name = string
  (** The type for section names (titles). See
      {{!standard_sections}standard section names}. *)

  type block =
  [ `S of section_name (** Start a new section with given name. *)
  | `P of string (** Paragraph with given text. *)
  | `Pre of string (** Preformatted paragraph with given text. *)
  | `I of string * string (** Indented paragraph with given label and text. *)
  | `Noblank (** Suppress blank line introduced between two blocks. *)
  | `Blocks of block list (** Splice given blocks. *) ]
  (** The type for a block of man page text.

      Except in [`Pre], whitespace and newlines are not significant
      and are all collapsed to a single space. All block strings
      support the {{!page-tool_man.doclang}documentation markup language}.*)

  val escape : string -> string
  (** [escape s] escapes [s] so that it doesn't get interpreted by the
      {{!page-tool_man.doclang}documentation markup language}. *)

  type title = string * int * string * string * string
  (** The type for man page titles. Describes the man page
      [title], [section], [center_footer], [left_footer], [center_header]. *)

  type t = title * block list
  (** The type for a man page. A title and the page text as a list of blocks. *)

  type xref =
  [ `Main (** Refer to the man page of the program itself. *)
  | `Cmd of string (** Refer to the command [cmd] of the tool, which must
                       exist. *)
  | `Tool of string (** Tool refer to the given command line tool. *)
  | `Page of string * int (** Refer to the manpage [name(sec)]. *) ]
  (** The type for man page cross-references. *)

  (** {1:standard_sections Standard section names and content}

      The following are standard man page section names, roughly ordered
      in the order they conventionally appear. See also
      {{:http://man7.org/linux/man-pages/man7/man-pages.7.html}[man man-pages]}
      for more elaborations about what sections should contain. *)

  val s_name : section_name
  (** The [NAME] section. This section is automatically created by
      [Cmdliner] for your command. *)

  val s_synopsis : section_name
  (** The [SYNOPSIS] section. By default this section is automatically
      created by [Cmdliner] for your command, unless it is the first
      section of your term's man page, in which case it will replace
      it with yours. *)

  val s_description : section_name
  (** The [DESCRIPTION] section. This should be a description of what
      the tool does and provide a little bit of command line usage and
      documentation guidance. *)

  val s_commands : section_name
  (** The [COMMANDS] section. By default subcommands get listed here. *)

  val s_arguments : section_name
  (** The [ARGUMENTS] section. By default positional arguments get
      listed here. *)

  val s_options : section_name
  (** The [OPTIONS] section. By default optional arguments get
      listed here. *)

  val s_common_options : section_name
  (** The [COMMON OPTIONS] section. By default help and version options get
      listed here. For programs with multiple commands, optional arguments
      common to all commands can be added here. *)

  val s_exit_status : section_name
  (** The [EXIT STATUS] section. By default term status exit codes
      get listed here. *)

  val s_environment : section_name
  (** The [ENVIRONMENT] section. By default environment variables get
      listed here. *)

  val s_environment_intro : block
  (** [s_environment_intro] is the introduction content used by cmdliner
      when it creates the {!s_environment} section. *)

  val s_files : section_name
  (** The [FILES] section. *)

  val s_bugs : section_name
  (** The [BUGS] section. *)

  val s_examples : section_name
  (** The [EXAMPLES] section. *)

  val s_authors : section_name
  (** The [AUTHORS] section. *)

  val s_see_also : section_name
  (** The [SEE ALSO] section. *)

  val s_none : section_name
  (** [s_none] is a special section named ["cmdliner-none"] that can be used
      whenever you do not want something to be listed. *)

  (** {1:output Output}

    The {!print} function can be useful if the client wants to define
    other man pages (e.g. to implement a help command). *)

  type format =
  [ `Auto (** Format like [`Pager] or [`Plain] whenever the [TERM]
              environment variable is [dumb] or unset. *)
  | `Pager (** {{!page-cli.help}Tries} to use a pager or falls back
               to [`Plain]. *)
  | `Plain (** Format to plain text. *)
  | `Groff (** Format to groff commands. *) ]
  (** The type for man page output specification. *)

  val print :
    ?env:(string -> string option) -> ?errs:Format.formatter ->
    ?subst:(string -> string option) -> format -> Format.formatter -> t -> unit
  (** [print ~env ~errs ~subst fmt ppf page] prints [page] on [ppf] in the
      format [fmt].
      {ul
      {- [env] is used to lookup environment for driving paging when the
         format is [`Pager]. Defaults to {!Sys.getenv_opt}.}
      {- [subst] can be used to perform variable
         substitution (defaults to the identity).}
      {- [errs] is used to print formatting errors, it defaults to
         {!Format.err_formatter}.}} *)
end

(** Terms.

    A term made of terms referring to {{!Arg.argterms}command line arguments}
    implicitly defines a command line syntax fragment. Terms are associated
    to command values {!Cmd.t} which are
    {{!Cmd.section-eval}evaluated} to eventually produce an
    {{!Cmd.Exit.code}exit code}.

    Nowadays terms are best defined using the {!Cmdliner.Term.Syntax}.
    See examples in the {{!page-cookbook.blueprints}blueprints}. *)
module Term : sig

  (** {1:terms Terms} *)

  type +'a t
  (** The type for terms evaluating to values of type ['a]. *)

  val const : 'a -> 'a t
  (** [const v] is a term that evaluates to [v]. *)

  val app : ('a -> 'b) t -> 'a t -> 'b t
  (** [app f v] is a term that evaluates to the result applying
      the evaluation of [v] to the one of [f]. *)

  val map : ('a -> 'b) -> 'a t -> 'b t
  (** [map f t] is [app (const f) t]. *)

  val product : 'a t -> 'b t  -> ('a * 'b) t
  (** [product t0 t1] is [app (app (map (fun x y -> (x, y)) t0) t1)] *)

  val ( $ ) : ('a -> 'b) t -> 'a t -> 'b t
  (** [f $ v] is {!app}[ f v]. *)

  (** [let] operators.

      See how to use them in the {{!page-cookbook.blueprints}blueprints}. *)
  module Syntax : sig
    val ( let+ ) : 'a t -> ('a -> 'b) -> 'b t
    (** [( let+ )] is {!map}. *)

    val ( and+ ) : 'a t -> 'b t -> ('a * 'b) t
    (** [( and+ )] is {!product}. *)
  end

  (** {1 Interacting with {!Cmd.t} evaluation}

      These special terms allow to interact with the
      {{!Cmd.section-eval_low}low-level evaluation process} performed
      on commands. *)

  val term_result : ?usage:bool -> ('a, [`Msg of string]) result t -> 'a t
  (** [term_result] is such that:
      {ul
      {- [term_result ~usage (Ok v)] {{!Cmd.eval_value}evaluates}
         to [Ok (`Ok v)].}
      {- [term_result ~usage (Error (`Msg e))]
         {{!Cmd.eval_value}evaluates} to [Error `Term] with the error message
         [e] and usage shown according to [usage] (defaults to [false])}}

      See also {!term_result'}. *)

  val term_result' : ?usage:bool -> ('a, string) result t -> 'a t
  (** [term_result'] is like {!term_result} but with a [string]
      error case. *)

  val cli_parse_result : ('a, [`Msg of string]) result t -> 'a t
  (** [cli_parse_result] is such that:
      {ul
      {- [cli_parse_result (Ok v)] {{!Cmd.eval_value}evaluates}
         [Ok (`Ok v)).}
      {- [cli_parse_result (Error (`Msg e))]] {{!Cmd.eval_value}evaluates}
         [Error `Parse].}}
      See also {!cli_parse_result'}. *)

  val cli_parse_result' : ('a, string) result t -> 'a t
  (** [cli_parse_result'] is like {!cli_parse_result} but with a
      [string] error case. *)

  val main_name : string t
  (** [main_name] is a term that evaluates to the main command name;
      that is the name of the tool. *)

  val choice_names : string list t
  (** [choice_names] is a term that evaluates to the names of the commands
      that are children of the main command. *)

  val with_used_args : 'a t -> ('a * string list) t
  (** [with_used_args t] is a term that evaluates to [t] tupled
      with the arguments from the command line that where used to
      evaluate [t]. *)

  type 'a ret =
  [ `Help of Manpage.format * string option
  | `Error of (bool * string)
  | `Ok of 'a ]
  (** The type for command return values. See {!val-ret}. *)

  val ret : 'a ret t -> 'a t
  (** [ret v] is a term whose evaluation depends on the case
      to which [v] evaluates. With :
      {ul
      {- [`Ok v], it evaluates to [v].}
      {- [`Error (usage, e)], the evaluation fails and [Cmdliner] prints
         the error [e] and the term's usage if [usage] is [true].}
      {- [`Help (format, name)], the evaluation fails and [Cmdliner] prints
         a manpage in format [format]. If [name] is [None] this is the
         the main command's manpage. If [name] is [Some c] this is
         the man page of the subcommand [c] of the main command.}} *)

  val env : (string -> string option) t
  (** [env] is the [env] argument given to {{!Cmd.section-eval}command
      evaluation functions}. If you need to refine the environment
      lookup done by Cmdliner's machinery you should use this rather
      than direct calls to {!Sys.getenv_opt}. *)
end

(** Commands.

    Command line syntaxes are implicitely defined by {!Term.t}
    values. A command value binds a term and its documentation to a
    command name.

    A command can group a list of subcommands (and recursively). In this
    case your tool defines a tree of commands, each with its own command
    line syntax. The root of that tree is called the {e main command};
    it represents your tool and its name. *)
module Cmd : sig

  (** {1:info Command information}

      Command information defines the name and documentation of a command. *)

  (** Exit codes and their information. *)
  module Exit : sig

    (** {1:codes Exit codes} *)

    type code = int
    (** The type for exit codes.

        {b Warning.} You should avoid status codes strictly greater than 125
        as those may be used by
        {{:https://www.gnu.org/software/bash/manual/html_node/Exit-Status.html}
        some} shells. *)

    (** {2:predefined Predefined codes}

        These are documented by {!defaults}. *)

    val ok : code
    (** [ok] is [0], the exit status for success. *)

    val some_error : code
    (** [some_error] is [123], an exit status for indiscriminate errors
        reported on [stderr]. *)

    val cli_error : code
    (** [cli_error] is [124], an exit status for command line parsing
        errors. *)

    val internal_error : code
    (** [internal_error] is [125], an exit status for unexpected internal
        errors. *)

    (** {1:info Exit code information} *)

    type info
    (** The type for exit code information. *)

    val info :
      ?docs:Manpage.section_name -> ?doc:string -> ?max:code -> code -> info
    (** [info ~docs ~doc min ~max] describe the range of exit
        statuses from [min] to [max] (defaults to [min]).
        {ul
        {- [doc] is the man page information for the statuses,
           defaults to ["undocumented"]. The
           {{!page-tool_man.doclang}documentation markup language}
           can be used with following variables:
           {ul
           {- [$(status)], the value of [min].}
           {- [$(status_max)], the value of [max].}
           {- The variables mentioned in the documentation of
              {!Cmd.val-info}}}}
        {- [docs] is the title of the man page section in which the statuses
           will be listed, it defaults to {!Manpage.s_exit_status}.}} *)

    val info_code : info -> code
    (** [info_code i] is the minimal code of [i]. *)

    val defaults : info list
    (** [defaults] are exit code information for {!ok}, {!some_error},
        {!cli_error} and {!internal_error}. *)
  end

  (** Environment variable and their information. *)
  module Env : sig

    (** {1:envvars Environment variables} *)

    type var = string
    (** The type for environment variable names. *)

    (** {1:info Environment variable information} *)

    type info
    (** The type for environment variable information. *)

    val info :
      ?deprecated:string -> ?docs:Manpage.section_name -> ?doc:string -> var ->
      info
    (** [info ~docs ~doc var] describes an environment variable
        [var] such that:
        {ul
        {- [doc] is the man page information of the environment
            variable, defaults to ["See option $(opt)."].}
        {- [docs] is the title of the man page section in which the environment
          variable will be listed, it defaults to
          {!Cmdliner.Manpage.s_environment}.}
        {- [deprecated], if specified the environment variable is
           deprecated.  Use of the variable warns on dep[stderr] This
           message which should be a capitalized sentence is
           preprended to [doc] and output on standard error when the
           environment variable ends up being used.}}

        In [doc] and [deprecated] the {{!page-tool_man.doclang}documentation
        markup language} can be used with following variables:

        {ul
        {- [$(opt)], if any the option name of the argument the variable is
           looked up for.}
        {- [$(env)], the value of [var].}
        {- The variables mentioned in the doc string of {!Cmd.val-info}.}} *)

    val info_var : info -> var
    (** [info_var info] is the variable described by [info]. *)
  end

  type info
  (** The type for information about commands. *)

  val info :
    ?deprecated:string -> ?man_xrefs:Manpage.xref list ->
    ?man:Manpage.block list -> ?envs:Env.info list -> ?exits:Exit.info list ->
    ?sdocs:Manpage.section_name -> ?docs:Manpage.section_name -> ?doc:string ->
    ?version:string -> string -> info
  (** [info ?sdocs ?man ?docs ?doc ?version name] is a term information
      such that:
      {ul
      {- [name] is the name of the command.}
      {- [version] is the version string of the command line tool, this
         is only relevant for the main command and ignored otherwise.}
      {- [deprecated], if specified the command is deprecated. Use of the
          variable warns on [stderr]. This
          message which should be a capitalized sentence is
          preprended to [doc] and output on standard error when the
          environment variable ends up being used.}
      {- [doc] is a one line description of the command used
         for the [NAME] section of the command's man page and in command
         group listings.}
      {- [docs], for commands that are part of a group, the title of the
         section of the parent's command man page where it should be listed
         (defaults to {!Manpage.s_commands}).}
      {- [sdocs] defines the title of the section in which the
         standard [--help] and [--version] arguments are listed
         (defaults to {!Manpage.s_common_options}).}
      {- [exits] is a list of exit statuses that the command evaluation
         may produce, defaults to {!Exit.defaults}.}
      {- [envs] is a list of environment variables that influence
         the command's evaluation.}
      {- [man] is the text of the man page for the command.}
      {- [man_xrefs] are cross-references to other manual pages. These
         are used to generate a {!Manpage.s_see_also} section.}}

      [doc], [deprecated], [man], [envs], [exits] support the
      {{!page-tool_man.doclang} documentation markup language} in which the
      following variables are recognized:

      {ul
      {- [$(tool)] the main, topmost, command name.}
      {- [$(cmd)] the command invocation from main command to the
         command name.}
      {- [$(cmd.name)] the command's name.}
      {- [$(cmd.parent)] the command's parent or the main command if none.}}

      Previously some of these names were refered to as [$(tname)],
      [$(mname)] and [$(iname)], they still work but do not use them,
      they are obscure. *)


  (** {1:cmds Commands} *)

  type 'a t
  (** The type for commands whose evaluation result in a value of
      type ['a]. *)

  val make : info -> 'a Term.t -> 'a t
  (** [make i t] is a command with information [i] and command line syntax
      parsed by [t]. *)

  val v : info -> 'a Term.t -> 'a t
  (** [v] is an old name for {!make} which should be preferred. *)

  val group : ?default:'a Term.t -> info -> 'a t list -> 'a t
  (** [group i ?default cmds] is a command with information [i] that
      groups subcommands [cmds]. [default] is the command line syntax
      to parse if no subcommand is specified on the command line. If
      [default] is [None] (default), the tool errors when no subcommand
      is specified. *)

  val name : 'a t -> string
  (** [name c] is the name of [c]. *)

  (** {1:eval Evaluation}

      Read {!page-cookbook.cmds_which_eval} in the cookbook if you
      struggle to choose between this menagerie of evaluation
      functions.

      These functions are meant to be composed with {!Stdlib.exit}.
      The following exit codes may be returned by all these functions:
      {ul
      {- {!Exit.cli_error} if a parse error occurs.}
      {- {!Exit.internal_error} if the [~catch] argument is [true] (default)
         and an uncaught exception is raised.}
      {- The value of [~term_err] (defaults to {!Exit.cli_error}) if
         a term error occurs.}}

      These exit codes are described in {!Exit.defaults} which is the
      default value of the [?exits] argument of the function {!val-info}. *)

  val eval :
    ?help:Format.formatter -> ?err:Format.formatter -> ?catch:bool ->
    ?env:(string -> string option) -> ?argv:string array ->
    ?term_err:Exit.code -> unit t -> Exit.code
  (** [eval cmd] is {!Exit.ok} if [cmd] evaluates to [()].
      See {!eval_value} for other arguments. *)

  val eval' :
    ?help:Format.formatter -> ?err:Format.formatter -> ?catch:bool ->
    ?env:(string -> string option) -> ?argv:string array ->
    ?term_err:Exit.code -> Exit.code t -> Exit.code
  (** [eval' cmd] is [c] if [cmd] evaluates to the exit code [c].
      See {!eval_value} for other arguments. *)

  val eval_result :
    ?help:Format.formatter -> ?err:Format.formatter -> ?catch:bool ->
    ?env:(string -> string option) -> ?argv:string array ->
    ?term_err:Exit.code -> (unit, string) result t -> Exit.code
  (** [eval_result cmd] is:
      {ul
      {- {!Exit.ok} if [cmd] evaluates to [Ok ()].}
      {- {!Exit.some_error} if [cmd] evaluates to [Error msg]. In this
         case [msg] is printed on [err].}}
      See {!eval_value} for other arguments. *)

  val eval_result' :
    ?help:Format.formatter -> ?err:Format.formatter -> ?catch:bool ->
    ?env:(string -> string option) -> ?argv:string array ->
    ?term_err:Exit.code -> (Exit.code, string) result t -> Exit.code
  (** [eval_result' cmd] is:
      {ul
      {- [c] if [cmd] evaluates to [Ok c].}
      {- {!Exit.some_error} if [cmd] evaluates to [Error msg]. In this
         case [msg] is printed on [err].}}
      See {!eval_value} for other arguments. *)

  (** {2:eval_low Low level evaluation}

      This interface gives more information on command evaluation results
      and lets you choose how to map evaluation results to exit codes.
      All evaluation functions are wrappers around {!eval_value}. *)

  type 'a eval_ok =
  [ `Ok of 'a (** The term of the command evaluated to this value. *)
  | `Version (** The version of the main cmd was requested. *)
  | `Help (** Help was requested. *) ]
  (** The type for successful evaluation results. *)

  type eval_error =
  [ `Parse (** A parse error occurred. *)
  | `Term (** A term evaluation error occurred. *)
  | `Exn (** An uncaught exception occurred. *) ]
  (** The type for erroring evaluation results. *)

  val eval_value :
    ?help:Format.formatter -> ?err:Format.formatter -> ?catch:bool ->
    ?env:(string -> string option) -> ?argv:string array -> 'a t ->
    ('a eval_ok, eval_error) result
  (** [eval ~help ~err ~catch ~env ~argv cmd] is the evaluation result
      of [cmd] with:
      {ul
      {- [argv] the command line arguments to parse (defaults to {!Sys.argv})}
      {- [env] the function used for environment variable lookup (defaults
         to {!Sys.getenv}).}
      {- [catch] if [true] (default) uncaught exceptions
         are intercepted and their stack trace is written to the [err]
         formatter}
      {- [help] is the formatter used to print help, version messages
         or completions, (defaults to {!Format.std_formatter}). Note
         that the completion protocol needs to output ['\n'] line ending,
         if you are outputing to a channel make sure it is in binary
         mode to avoid newline translation (this is done automatically
         before completion when [help] is {!Format.std_formatter}).}
      {- [err] is the formatter used to print error messages
         (defaults to {!Format.err_formatter}).}} *)

  type 'a eval_exit =
  [ `Ok of 'a (** The term of the command evaluated to this value. *)
  | `Exit of Exit.code (** The evaluation wants to exit with this code. *) ]
  (** The type for evaluation exits. *)

  val eval_value' :
    ?help:Format.formatter -> ?err:Format.formatter -> ?catch:bool ->
    ?env:(string -> string option) -> ?argv:string array -> ?term_err:int ->
    'a t -> 'a eval_exit
  (** [eval_value'] is like {!eval_value}, but if the command term
      does not evaluate to [Ok (`Ok v)], returns an exit code like the
      higher-level {{!val-eval}evaluation} functions do (which can be
      {!Exit.ok} in case help or version was requested). *)

  val eval_peek_opts :
    ?version_opt:bool -> ?env:(string -> string option) ->
    ?argv:string array -> 'a Term.t ->
    'a option * ('a eval_ok, eval_error) result
  (** {b WARNING.} You are highly encouraged not to use this
      function it may be removed in the future.

      [eval_peek_opts version_opt argv t] evaluates [t], a term made
      of optional arguments only, with the command line [argv]
      (defaults to {!Sys.argv}). In this evaluation, unknown optional
      arguments and positional arguments are ignored.

      The evaluation returns a pair. The first component is
      the result of parsing the command line [argv] stripped from
      any help and version option if [version_opt] is [true] (defaults
      to [false]). It results in:
      {ul
      {- [Some _] if the command line would be parsed correctly given the
         {e partial} knowledge in [t].}
      {- [None] if a parse error would occur on the options of [t]}}

      The second component is the result of parsing the command line
      [argv] without stripping the help and version options. It
      indicates what the evaluation would result in on [argv] given
      the partial knowledge in [t] (for example it would return
      [`Help] if there's a help option in [argv]). However in
      contrasts to {!val-eval_value} no side effects like error
      reporting or help output occurs.

      {b Note.} Positional arguments can't be peeked without the full
      specification of the command line: we can't tell apart a
      positional argument from the value of an unknown optional
      argument. *)
end

(** Terms for command line arguments.

    This module provides functions to define terms that evaluate
    to the arguments provided on the command line.

    Basic constraints, like the argument type or repeatability, are
    specified by defining a value of type {!Arg.t}. Further constraints can
    be specified during the {{!Arg.argterms}conversion} to a term. *)
module Arg : sig

  (** {1:argconv Argument converters} *)

  (** Argument completion.

      This module provides a type to describe how positional and
      optional argument values of {{!Arg.type-conv}argument
      converters} can be completed. It defines which completion
      directives from the {{!page-cli.completion_protocol}protocol}
      get emitted by your tool for the argument.

      {b Note.} Subcommand and option name are completed
      automatically by the library itself and
      {{!Cmdliner.Arg.predef}prefined argument converters} already
      have completions built-in whenever appropriate. *)
  module Completion : sig

    (** {1:directives Completion directives} *)

    type 'a directive
    (** The type for a completion directive for values of type ['a]. *)

    val value : ?doc:string -> 'a -> 'a directive
    (** [value v ~doc] indicates that the token to complete could be
        replaced by the value [v] as serialized by the argument's
        formatter {!Conv.pp}. [doc] is ANSI styled UTF-8 text
        documenting the value, defaults to [""]. *)

    val string : ?doc:string -> string -> 'a directive
    (** [string s ~doc] indicates that the token to complete could be
        replaced by the string [s]. [doc] is ANSI styled UTF-8 text
        documenting the value, defaults to [""]. *)

    val files : 'a directive
    (** [files] indicates that the token to complete could be replaced
        with files that the shell deems suitable. *)

    val dirs : 'a directive
    (** [dirs] indicates that the token to complete could be replaced with
        directories that the shell deems suitable. *)

    val restart : 'a directive
    (** [restart] indicates that the shell should restart the completion
        after the positional disambiguation token [--].

        This is typically used for tools that end-up invoking other
        tools like [sudo -- TOOL [ARG]]. For the latter a restart
        completion should be added on all positional arguments.  If
        you allow [TOOL] to be only a restricted set of tools known to
        your program you'd eschew [restart] on the first postional
        argument but add it to the remaining ones.

        {b Warning.} A [restart] directive is eventually emited only
        if the completion is requested after a [--] token. In this
        case other completions returned alongside by {!func} are
        ignored. Educate your users to use the [--], for example
        mention them in {{!page-cookbook.manpage_synopsis}user defined
        synopses}, it is good cli specification hygiene as it properly
        delineates argument scopes. *)

    val message : string -> 'a directive
    (** [message s] is a multi-line, ANSI styled, UTF-8 message reported
        to end users. *)

    val raw : string -> 'a directive
    (** [raw s] takes over the whole {{!page-cli.completion_protocol}protocol}
        output (including subcommand and option name completion) with [s],
        you are in charge. Any other directive in the result of {!func}
        is ignored.

        {b Warning.} The protocol is unstable, it is not advised to
        output it yourself. However this can be useful to invoke
        another tool according to the protocol in the completion
        function and treat its result as the requested completion. *)

    (** {1:completion Completion} *)

    type ('ctx, 'a) func =
      'ctx option -> token:string -> ('a directive list, string) result
    (** The type for completion functions.

        Given an optional context determined from a partial command
        line parse and a token to complete it returns a list of
        completion directives or an error which is reported to
        end-users by using a protocol {!message}.

        The context is [None] if no context was given to {!make} or if
        the context failed to parse on the current command line. *)

    type 'a complete =
    | Complete : 'ctx Term.t option * ('ctx, 'a) func -> 'a complete (** *)
    (** The type for completing.

        A completion context specification which captures a partial
        command line parse (for example the path to a configuration
        file) and a completion function. *)

    type 'a t
    (** The type for completing values parsed into values of type ['a]. *)

    val make : ?context:'ctx Term.t -> ('ctx, 'a) func -> 'a t
    (** [make ~context func] uses [func] to complete.

        [context] defines a commmand line fragment that is evaluated
        before performing the completion. It the evaluation is
        successful the result is given to the completion
        function. Otherwise [None] is given.

        {b Warning.} [context] must be part of the term of the command
        in which you use the completion otherwise the context will
        always be [None] in the function. *)

    val complete : 'a t -> 'a complete
    (** [complete c] completes with [c]. *)

    val complete_files : 'a t
    (** [complete_files] holds a context insensitive function that
        always returns [Ok \[]{!files}[\]]. *)

    val complete_dirs : 'a t
    (** [complete_dirs] holds a context insensitive function that
        always returns [Ok \[]{!dirs}[\]]. *)

    val complete_paths : 'a t
    (** [complete_paths] holds a context insensitive function that
        always returns [Ok \[]{!files}[;]{!dirs}[\]]. *)

    val complete_restart : 'a t
    (** [complete_dirs] holds a context insensitive function that
        always returns [Ok \[]{!restart}[\]]. *)
  end

  (** Argument converters.

      An argument converter transforms a string argument of the command
      line to an OCaml value. {{!converters}Predefined converters}
      are provided for many types of the standard library. *)
  module Conv : sig

    (** {1:converters Converters} *)

    type 'a parser = string -> ('a, string) result
    (** The type for parsing arguments to values of type ['a]. *)

    type 'a fmt = Format.formatter -> 'a -> unit
    (** The type for formatting values of type ['a]. *)

    type 'a t
    (** The type for converting arguments to values of type ['a]. *)

    val make :
      ?completion:'a Completion.t -> docv:string -> parser:'a parser ->
      pp:'a fmt -> unit -> 'a t
    (** [make ~docv ~parser ~pp ()] is an argument converter with
        given properties. See corresponding accessors for semantics. *)

    val of_conv :
      ?completion:'a Completion.t -> ?docv:string ->
      ?parser:'a parser -> ?pp:'a fmt -> 'a t -> 'a t
    (** [of_conv conv ()] is a new converter with given unspecified
        properties defaulting to those of [conv]. *)

    (** {1:properties Properties} *)

    val docv : 'a t -> string
    (** [docv c] is [c]'s documentation meta-variable. This value can
        be refered to as [$(docv)] in the documentation strings of
        arguments.  It can be overriden by the {!val-info} value of an
        argument. *)

    val parser : 'a t -> 'a parser
    (** [parser c] is [c]'s argument parser. *)

    val pp : 'a t -> 'a fmt
    (** [pp c] is [c]'s argument formatter. *)

    val completion : 'a t -> 'a Completion.t
    (** [completion c] is [c]'s completion. *)
  end

  type 'a conv = 'a Conv.t
  (** The type for argument converters. See the
      {{!predef}predefined converters}. *)

  val some' : ?none:'a -> 'a conv -> 'a option conv
  (** [some' ?none c] is like the converter [c] except it returns
      [Some] value. It is used for command line arguments that default
      to [None] when absent. If provided, [none] is used with [c]'s
      formatter to document the value taken on absence; to document
      a more complex behaviour use the [absent] argument of {!val-info}.
      If you cannot construct an ['a] value use {!some}. *)

  val some : ?none:string -> 'a conv -> 'a option conv
  (** [some ?none c] is like [some'] but [none] is described as a
      string that will be rendered in bold. Use the [absent] argument
      of {!val-info} to document more complex behaviours. *)

  (** {1:arginfo Arguments} *)

  type 'a t
  (** The type for arguments holding data of type ['a]. *)

  type info
  (** The type for information about command line arguments.

      Argument information defines the man page information of an
      argument and, for optional arguments, its names. An environment
      variable can also be specified to read get the argument value from
      if the argument is absent from the command line and the variable
      is defined. *)

  val info :
    ?deprecated:string -> ?absent:string -> ?docs:Manpage.section_name ->
    ?doc_envs:Cmd.Env.info list -> ?docv:string -> ?doc:string ->
    ?env:Cmd.Env.info -> string list -> info
  (** [info docs docv doc env names] defines information for
      an argument.
      {ul
      {- [names] defines the names under which an optional argument
         can be referred to. Strings of length [1] like ["c"]) define
         short option names ["-c"], longer strings like ["count"])
         define long option names ["--count"]. [names] must be empty
         for positional arguments.}
      {- [env] defines the name of an environment variable which is
         looked up for defining the argument if it is absent from the
         command line. See {{!page-cli.envlookup}environment variables} for
         details.}
      {- [doc] is the man page information of the argument.
         {{!doc_helpers}These functions} can help with formatting argument
         values.}
      {- [docv] is for positional and non-flag optional arguments.
         It is a variable name used in the man page to stand for their value.
         If unspecified is taken from the argument converter's, see
         {!Conv.docv}.}
      {- [doc_envs] is a list of environment variable that are
         added to the manual of the command when the argument is used.}
      {- [docs] is the title of the man page section in which the argument
         will be listed. For optional arguments this defaults
         to {!Manpage.s_options}. For positional arguments this defaults
         to {!Manpage.s_arguments}. However a positional argument is only
         listed if it has both a [doc] and [docv] specified.}
      {- [deprecated], if specified the argument is deprecated. Use of the
          variable warns on [stderr]. This
          message which should be a capitalized sentence is
          preprended to [doc] and output on standard error when the
          environment variable ends up being used.}
      {- [absent], if specified a documentation string that indicates
         what happens when the argument is absent. The document language
         can be used like in [doc]. This overrides the automatic default
         value rendering that is performed by the combinators.}}

      In [doc], [deprecated], [absent] the
      {{!page-tool_man.doclang}documentation markup language} can be
      used with following variables:

      {ul
      {- ["$(docv)"] the value of [docv] (see below).}
      {- ["$(opt)"], one of the options of [names], preference
        is given to a long one.}
      {- ["$(env)"], the environment var specified by [env] (if any).}} *)

  val ( & ) : ('a -> 'b) -> 'a -> 'b
  (** [f & v] is [f v], a right associative composition operator for
      specifying argument terms. *)

(** {2:optargs Optional arguments}

    The {{!type-info}information} of an optional argument must have at least
    one name or [Invalid_argument] is raised. *)

  val flag : info -> bool t
  (** [flag i] is a [bool] argument defined by an optional flag
      that may appear {e at most} once on the command line under one of
      the names specified by [i]. The argument holds [true] if the
      flag is present on the command line and [false] otherwise. *)

  val flag_all : info -> bool list t
  (** [flag_all] is like {!flag} except the flag may appear more than
      once. The argument holds a list that contains one [true] value per
      occurrence of the flag. It holds the empty list if the flag
      is absent from the command line. *)

  val vflag : 'a -> ('a * info) list -> 'a t
  (** [vflag v \[v]{_0}[,i]{_0}[;\]] is an ['a] argument defined
      by an optional flag that may appear {e at most} once on
      the command line under one of the names specified in the [i]{_k}
      values. The argument holds [v] if the flag is absent from the
      command line and the value [v]{_k} if the name under which it appears
      is in [i]{_k}.

      {b Note.} Automatic environment variable lookup is unsupported for
      for these arguments but an [env] in an info will be documented.
      Use an option and {!Term.env} for manually looking something up. *)

  val vflag_all : 'a list -> ('a * info) list -> 'a list t
  (** [vflag_all v l] is like {!vflag} except the flag may appear more
      than once. The argument holds the list [v] if the flag is absent
      from the command line. Otherwise it holds a list that contains one
      corresponding value per occurrence of the flag, in the order found on
      the command line.

      {b Note.} Automatic environment variable lookup is unsupported for
      for these arguments but an [env] in an info will be documented.
      Use an option and {!Term.env} for manually looking something up. *)

  val opt : ?vopt:'a -> 'a conv -> 'a -> info -> 'a t
  (** [opt vopt c v i] is an ['a] argument defined by the value of
      an optional argument that may appear {e at most} once on the command
      line under one of the names specified by [i]. The argument holds
      [v] if the option is absent from the command line. Otherwise
      it has the value of the option as converted by [c].

      If [vopt] is provided the value of the optional argument is
      itself optional, taking the value [vopt] if unspecified on the
      command line.  {b Warning} using [vopt] is
      {{!page-cookbook.tip_avoid_default_option_values}not
      recommended}. *)

  val opt_all : ?vopt:'a -> 'a conv -> 'a list -> info -> 'a list t
  (** [opt_all vopt c v i] is like {!opt} except the optional argument may
      appear more than once. The argument holds a list that contains one value
      per occurrence of the flag in the order found on the command line.
      It holds the list [v] if the flag is absent from the command line. *)

  (** {2:posargs Positional arguments}

      The {{!type-info}information} of a positional argument must have no name
      or [Invalid_argument] is raised. Positional arguments indexing
      is zero-based.

      {b Warning.} The following combinators allow to specify and
      extract a given positional argument with more than one term.
      This should not be done as it will likely confuse end users and
      documentation generation. These over-specifications may be
      prevented by raising [Invalid_argument] in the future. But for now
      it is the client's duty to make sure this doesn't happen. *)

  val pos : ?rev:bool -> int -> 'a conv -> 'a -> info -> 'a t
  (** [pos rev n c v i] is an ['a] argument defined by the [n]th
      positional argument of the command line as converted by [c].
      If the positional argument is absent from the command line
      the argument is [v].

      If [rev] is [true] (defaults to [false]), the computed
      position is [max-n] where [max] is the position of
      the last positional argument present on the command line. *)

  val pos_all : 'a conv -> 'a list -> info -> 'a list t
  (** [pos_all c v i] is an ['a list] argument that holds
      all the positional arguments of the command line as converted
      by [c] or [v] if there are none. *)

  val pos_left :
    ?rev:bool -> int -> 'a conv -> 'a list -> info -> 'a list t
  (** [pos_left rev n c v i] is an ['a list] argument that holds
      all the positional arguments as converted by [c] found on the left
      of the [n]th positional argument or [v] if there are none.

      If [rev] is [true] (defaults to [false]), the computed
      position is [max-n] where [max] is the position of
      the last positional argument present on the command line. *)

  val pos_right :
    ?rev:bool -> int -> 'a conv -> 'a list -> info -> 'a list t
  (** [pos_right] is like {!pos_left} except it holds all the positional
      arguments found on the right of the specified positional argument. *)

  (** {2:argterms Converting to terms} *)

  val value : 'a t -> 'a Term.t
  (** [value a] is a term that evaluates to [a]'s value. *)

  val required : 'a option t -> 'a Term.t
  (** [required a] is a term that fails if [a]'s value is [None] and
      evaluates to the value of [Some] otherwise. Use this in combination
      with {!Arg.some'} for required
      positional arguments. {b Warning} using this on optional arguments
      is {{!page-cookbook.tip_avoid_required_opt}not recommended}. *)

  val non_empty : 'a list t -> 'a list Term.t
  (** [non_empty a] is term that fails if [a]'s list is empty and
      evaluates to [a]'s list otherwise. Use this for non empty lists
      of positional arguments. *)

  val last : 'a list t -> 'a Term.t
  (** [last a] is a term that fails if [a]'s list is empty and evaluates
      to the value of the last element of the list otherwise. Use this
      for lists of flags or options where the last occurrence takes precedence
      over the others. *)

  (** {2:predef Predefined arguments} *)

  val man_format : Manpage.format Term.t
  (** [man_format] is a term that defines a [--man-format] option and
      evaluates to a value that can be used with {!Manpage.print}. *)

  (** {1:converters Predefined converters} *)

  val bool : bool conv
  (** [bool] converts values with {!bool_of_string}. *)

  val char : char conv
  (** [char] converts values by ensuring the argument has a single char. *)

  val int : int conv
  (** [int] converts values with {!int_of_string}. *)

  val nativeint : nativeint conv
  (** [nativeint] converts values with {!Nativeint.of_string}. *)

  val int32 : int32 conv
  (** [int32] converts values with {!Int32.of_string}. *)

  val int64 : int64 conv
  (** [int64] converts values with {!Int64.of_string}. *)

  val float : float conv
  (** [float] converts values with {!float_of_string}. *)

  val string : string conv
  (** [string] converts values with the identity function. *)

  val enum : ?docv:string -> (string * 'a) list -> 'a conv
  (** [enum l p] converts values such that string names in [l] map to
      the corresponding value of type ['a]. [docv] is the converter's
      documentation meta-variable, it defaults to [ENUM].  A
      {{!Completion.make}completion} is added for the names.

      {b Warning.} The type ['a] must be comparable with {!Stdlib.compare}.

      @raise Invalid_argument if [l] is empty. *)

  val list : ?sep:char -> 'a conv -> 'a list conv
  (** [list sep c] splits the argument at each [sep] (defaults to [','])
      character and converts each substrings with [c]. *)

  val array : ?sep:char -> 'a conv -> 'a array conv
  (** [array sep c] splits the argument at each [sep] (defaults to [','])
      character and converts each substring with [c]. *)

  val pair : ?sep:char -> 'a conv -> 'b conv -> ('a * 'b) conv
  (** [pair sep c0 c1] splits the argument at the {e first} [sep] character
      (defaults to [',']) and respectively converts the substrings with
      [c0] and [c1]. *)

  val t2 : ?sep:char -> 'a conv -> 'b conv -> ('a * 'b) conv
  (** {!t2} is {!pair}. *)

  val t3 : ?sep:char -> 'a conv ->'b conv -> 'c conv -> ('a * 'b * 'c) conv
  (** [t3 sep c0 c1 c2] splits the argument at the {e first} two [sep]
      characters (defaults to [',']) and respectively converts the
      substrings with [c0], [c1] and [c2]. *)

  val t4 :
    ?sep:char -> 'a conv -> 'b conv -> 'c conv -> 'd conv ->
    ('a * 'b * 'c * 'd) conv
  (** [t4 sep c0 c1 c2 c3] splits the argument at the {e first} three [sep]
      characters (defaults to [',']) respectively converts the substrings
      with [c0], [c1], [c2] and [c3]. *)

  (** {2:files Files and directories} *)

  val path : string conv
  (** [path] is like {!string} but prints using {!Filename.quote}
      and completes both files and directories. *)

  val filepath : string conv
  (** [filepath] is like {!string} but prints using {!Filename.quote}
      and completes files. *)

  val dirpath : string conv
  (** [dirpath] is like {!string} but prints using {!Filename.quote}
      and completes directories. *)

  (** {b Note.} The following converters report errors whenever the
      requested file system object does not exist. This is only mildly
      useful since nothing guarantees they will still exist at the
      time you act upon them. So you will have to treat these error
      cases anyways in your tool function. It is also unhelpful if the file
      system object may be created by your tool. Rather use
      {!filepath} and {!dirpath}. *)

  val file : string conv
  (** [file] converts a value with the identity function and checks
      with {!Sys.file_exists} that a file with that name exists.  The
      string ["-"] is parsed without checking: it represents [stdio].
      It completes both files directories. *)

  val dir : string conv
  (** [dir] converts a value with the identity function and checks
      with {!Sys.file_exists} and {!Sys.is_directory} that a directory
      with that name exists. It completes directories. *)

  val non_dir_file : string conv
  (** [non_dir_file] converts a value with the identity function and
      checks with {!Sys.file_exists} and {!Sys.is_directory} that a
      non directory file with that name exists. The string ["-"] is
      parsed without checking it represents [stdio].  It completes
      files. *)

  (** {1:doc_helpers Documentation formatting helpers} *)

  val doc_quote : string -> string
  (** [doc_quote s] quotes the string [s]. *)

  val doc_alts : ?quoted:bool -> string list -> string
  (** [doc_alts alts] documents the alternative tokens [alts]
      according the number of alternatives. If [quoted] is:
      {ul
      {- [None], the tokens are enclosed in manpage markup directives
         to render them in bold (manpage convention).}
      {- [Some true], the tokens are quoted with {!doc_quote}.}
      {- [Some false], the tokens are written as is}}
      The resulting string can be used in sentences of
      the form ["$(docv) must be %s"].

      @raise Invalid_argument if [alts] is the empty list.  *)

  val doc_alts_enum : ?quoted:bool -> (string * 'a) list -> string
  (** [doc_alts_enum quoted alts] is [doc_alts quoted (List.map fst alts)]. *)

  (** {1:deprecated Deprecated}

      These identifiers are silently deprecated. For now there is no
      plan to remove them. But you should prefer to use the {!Conv}
      interface in new code. *)

  type 'a printer = 'a Conv.fmt
  (** Deprecated. Use {!Conv.fmt}. *)

  val conv' : ?docv:string -> 'a Conv.parser * 'a Conv.fmt -> 'a conv
  (** Deprecated. Use {!Conv.make} instead. *)

  val conv :
    ?docv:string -> (string -> ('a, [`Msg of string]) result) * 'a Conv.fmt ->
    'a conv
  (** Deprecated. Use {!Conv.make} instead. *)

  val conv_parser : 'a conv -> (string -> ('a, [`Msg of string]) result)
  (** Deprecated. Use {!Conv.val-parser}. *)

  val conv_printer : 'a conv -> 'a Conv.fmt
  (** Deprecated. Use {!Conv.val-pp}. *)

  val conv_docv : 'a conv -> string
  (** Deprecated. Use {!Conv.val-docv}. *)

  val parser_of_kind_of_string :
    kind:string -> (string -> 'a option) ->
    (string -> ('a, [`Msg of string]) result)
  (** Deprecated. [parser_of_kind_of_string ~kind kind_of_string] is an argument
      parser using the [kind_of_string] function for parsing and [kind]
      to report errors (e.g. could be ["an integer"] for an [int] parser.). *)
end
end = struct
(*---------------------------------------------------------------------------
   Copyright (c) 2011 The cmdliner programmers. All rights reserved.
   SPDX-License-Identifier: ISC
  ---------------------------------------------------------------------------*)

module Manpage = Cmdliner_manpage
module Term = Cmdliner_term
module Cmd = struct
  module Exit = Cmdliner_def.Exit
  module Env = Cmdliner_def.Env
  include Cmdliner_cmd
  include Cmdliner_eval
end
module Arg = Cmdliner_arg
end
include Cmdliner
(* mach - OCaml scripting runtime *)

open Mach_lib

let or_exit = function
  | Ok v -> v
  | Error (`User_error msg) ->
    Printf.eprintf "mach: %s\n%!" msg;
    exit 1

(* --- Watch mode --- *)

let parse_event line =
  match String.index_opt line ':' with
  | None -> None
  | Some i ->
    let event_type = String.sub line 0 i in
    let path = String.sub line (i + 1) (String.length line - i - 1) in
    Some (event_type, path)

(* Read a batch of events until empty line, deduplicating paths *)
let read_events ic =
  let paths = Hashtbl.create 16 in
  let rec loop () =
    match input_line ic with
    | "" -> Hashtbl.to_seq_keys paths |> List.of_seq |> List.sort String.compare
    | line -> begin
      Mach_log.log_very_verbose "mach:watch: event: %s" line;
      (match parse_event line with
      | None -> ()
      | Some (_event_type, path) -> Hashtbl.replace paths path ());
      loop ()
    end
  in
  loop ()

let watch config script_path ?run_args () =
  let build_dir_of = Mach_config.build_dir_of config in
  let exception Restart_watcher in
  let code = Sys.command "command -v watchexec > /dev/null 2>&1" in
  if code <> 0 then begin
    Printf.eprintf "mach: watchexec not found. Install it: https://github.com/watchexec/watchexec\n%!";
    exit 1
  end;
  let script_path = Unix.realpath script_path in

  (* Track current state for signal handling and cleanup *)
  let current_process = ref None in
  let current_watchlist = ref None in
  let child_pid : int option ref = ref None in

  let kill_child () =
    match !child_pid with
    | None -> ()
    | Some pid ->
      (match Unix.waitpid [Unix.WNOHANG] pid with
      | 0, _ ->
        Mach_log.log_verbose "mach: stopping previous instance (pid %d)..." pid;
        Unix.kill pid Sys.sigterm;
        ignore (Unix.waitpid [] pid)
      | _ -> ());
      child_pid := None
  in

  let start_child state =
    match run_args with
    | None -> ()
    | Some args ->
      kill_child ();
      let exe_path = Mach_state.exe_path config state in
      let argv = Array.of_list (exe_path :: args) in
      Mach_log.log_verbose "mach: starting %s" script_path;
      let pid = Unix.create_process exe_path argv Unix.stdin Unix.stdout Unix.stderr in
      child_pid := Some pid
  in

  let cleanup () =
    kill_child ();
    !current_process |> Option.iter (fun (pid, ic) ->
      begin try close_in ic with _ -> () end;
      (match Unix.waitpid [Unix.WNOHANG] pid with
      | 0, _ -> Unix.kill pid Sys.sigterm; ignore (Unix.waitpid [] pid)
      | _ -> ());
      current_process := None);
    !current_watchlist |> Option.iter (fun path ->
      begin try Sys.remove path with _ -> () end;
      current_watchlist := None)
  in

  Sys.(set_signal sigint (Signal_handle (fun _ -> cleanup (); exit 0)));

  Mach_log.log_verbose "mach: initial build...";
  (* Don't exit on initial build failure - continue watching for changes *)
  (match build config script_path with
  | Ok (state, _reconfigured) -> start_child state
  | Error (`User_error msg) -> Mach_log.log_verbose "mach: %s" msg);

  let keep_watching = ref true in
  while !keep_watching do
    let state = Option.get (Mach_state.read (Filename.concat (build_dir_of script_path) "Mach.state")) in
    let source_dirs = Mach_state.source_dirs state in
    let source_files =
      let files = Hashtbl.create 16 in
      List.iter (fun (entry : Mach_state.entry) ->
        Hashtbl.replace files entry.ml_path ();
        Option.iter (fun mli -> Hashtbl.replace files mli ()) entry.mli_path
      ) state.entries;
      files
    in
    Mach_log.log_verbose "mach: watching %d directories (Ctrl+C to stop):" (List.length source_dirs);
    List.iter (fun d -> Mach_log.log_verbose "  %s" d) source_dirs;
    let watchlist_path =
      let path = Filename.temp_file "mach-watch" ".txt" in
      Out_channel.with_open_text path (fun oc ->
        List.iter (fun dir ->
          output_string oc "-W\n";
          output_string oc dir;
          output_char oc '\n'
        ) source_dirs);
      path
    in
    current_watchlist := Some watchlist_path;
    let args = [|
      "watchexec";
      "--debounce"; "200ms";
      "--only-emit-events";
      "--emit-events-to=stdio";
      "--exts"; "ml,mli,mlx";
      "@" ^ watchlist_path 
    |] in
    Mach_log.log_very_verbose "mach:watch: running: %s" (String.concat " " (Array.to_list args));
    let pipe_read, pipe_write = Unix.pipe () in
    let pid = Unix.create_process "watchexec" args Unix.stdin pipe_write Unix.stderr in
    Unix.close pipe_write;
    let ic = Unix.in_channel_of_descr pipe_read in
    current_process := Some (pid, ic);

    begin try
      while true do
        let changed_paths = read_events ic in
        let relevant_paths =
          List.fold_left (fun acc path -> if Hashtbl.mem source_files path then path :: acc else acc)
          [] changed_paths
        in
        if relevant_paths <> [] then begin
          List.iter (fun p -> Mach_log.log_verbose "mach: file changed: %s" (Filename.basename p)) relevant_paths;
          match build config script_path with
          | Error (`User_error msg) -> Mach_log.log_verbose "mach: %s" msg
          | Ok (state, reconfigured) ->
            Printf.eprintf "mach: build succeeded\n%!";
            start_child state;
            if reconfigured then begin
              Mach_log.log_verbose "mach:watch: reconfigured, restarting watcher...";
              raise Restart_watcher
            end
        end
      done
    with
    | Restart_watcher -> cleanup ()
    | End_of_file -> cleanup (); keep_watching := false
    end
  done

(* --- Command Line --- *)

open Cmdliner

let verbose_arg =
  let f verbose =
    let verbose =
      match verbose with [] -> Quiet | [_] -> Verbose | _::_::[] -> Very_verbose | _ -> Very_very_verbose
    in
    Mach_log.verbose := verbose
  in
  Term.(
    const f
    $ Arg.(value & flag_all & info ["v"; "verbose"] ~doc:"Log external command invocations to stderr."))

let script_arg =
  Arg.(required & pos 0 (some non_dir_file) None & info [] ~docv:"SCRIPT" ~doc:"OCaml script to run")

let args_arg =
  Arg.(value & pos_right 0 string [] & info [] ~docv:"ARGS" ~doc:"Arguments to pass to the script")

let watch_arg =
  Arg.(value & flag & info ["w"; "watch"]
    ~doc:"Watch for changes and rebuild automatically. Requires watchexec to be installed.")

let run_cmd =
  let doc = "Run an OCaml script" in
  let info = Cmd.info "run" ~doc in
  let f () watch_mode script_path args =
    let config = Mach_config.get () |> or_exit in
    if watch_mode then watch config script_path ~run_args:args ()
    else begin
      let state, _reconfigured = build config script_path |> or_exit in
      let exe_path = Mach_state.exe_path config state in
      let argv = Array.of_list (exe_path :: args) in
      Unix.execv exe_path argv
    end
  in
  Cmd.v info Term.(const f $ verbose_arg $ watch_arg $ script_arg $ args_arg)

let build_cmd =
  let doc = "Build an OCaml script without executing it" in
  let info = Cmd.info "build" ~doc in
  let f () watch_mode script_path =
    let config = Mach_config.get () |> or_exit in
    if watch_mode then watch config script_path ()
    else build config script_path |> or_exit |> ignore
  in
  Cmd.v info Term.(const f $ verbose_arg $ watch_arg $ script_arg)

let source_arg =
  Arg.(required & pos 0 (some non_dir_file) None & info [] ~docv:"SOURCE" ~doc:"OCaml source file to configure")

let configure_cmd =
  let doc = "Generate build files for all modules in dependency graph" in
  let info = Cmd.info "configure" ~doc ~docs:Manpage.s_none in
  let f path =
    let config = Mach_config.get () |> or_exit in
    configure config path |> or_exit |> ignore
  in
  Cmd.v info Term.(const f $ source_arg)

let pp_cmd =
  let doc = "Preprocess source file to stdout (for use with merlin -pp)" in
  let info = Cmd.info "pp" ~doc ~docs:Manpage.s_none in
  Cmd.v info Term.(const pp $ source_arg)

let run_build_command_cmd =
  let doc = "Run a build command, prefixing output with >>>" in
  let info = Cmd.info "run-build-command" ~doc ~docs:Manpage.s_none in
  let cmd_arg = Arg.(non_empty & pos_all string [] & info [] ~docv:"COMMAND") in
  let stderr_only_arg = Arg.(value & flag & info ["stderr-only"] ~doc:"Only capture stderr, let stdout pass through") in
  let f stderr_only args =
    let open Unix in
    let prog, argv = match args with
      | [] -> prerr_endline "mach run-build-command: no command"; exit 1
      | prog :: _ -> prog, Array.of_list args
    in
    let (pipe_read, pipe_write) = pipe () in
    let pid = match fork () with
      | 0 ->
        close pipe_read;
        if not stderr_only then dup2 pipe_write stdout;
        dup2 pipe_write stderr;
        close pipe_write;
        execvp prog argv
      | pid -> pid
    in
    close pipe_write;
    let ic = in_channel_of_descr pipe_read in
    (try while true do
      let line = input_line ic in
      Printf.eprintf ">>>%s\n%!" line
    done with End_of_file -> ());
    close_in ic;
    let _, status = waitpid [] pid in
    match status with
    | WEXITED code -> exit code
    | WSIGNALED n -> exit (128 + n)
    | WSTOPPED _ -> exit 1
  in
  Cmd.v info Term.(const f $ stderr_only_arg $ cmd_arg)

let cmd =
  let doc = "Run OCaml scripts with automatic dependency resolution" in
  let info = Cmd.info "mach" ~doc ~man:[`S Manpage.s_synopsis] in
  let default = Term.(ret (const (`Help (`Pager, None)))) in
  Cmd.group ~default info [run_cmd; build_cmd; configure_cmd; pp_cmd; run_build_command_cmd]

let () = exit (Cmdliner.Cmd.eval cmd)
